{"meta":{"title":"蓝色的博客","subtitle":"RBK","description":null,"author":"Borui Kang","url":"https://bluerbk.top"},"pages":[],"posts":[{"title":"C#基础伪教程（二）","slug":"CSharp-Second-Teaching","date":"2018-03-18T08:53:09.000Z","updated":"2018-03-18T15:20:05.893Z","comments":true,"path":"2018/03/18/CSharp-Second-Teaching/","link":"","permalink":"https://bluerbk.top/2018/03/18/CSharp-Second-Teaching/","excerpt":"","text":"今天啥都没干，干脆写一点C#吧，就当作是第二个教程了，不多说，进入正题。 类类是用class关键字定义声明，具体框架如下1234public class name&#123;...&#125; public属于访问修饰符，表示访问权限，也可以为protected、internal或者private。C#的类同样支持继承，被继承的类称为基类，继承基类的类称作派生类。派生类可以使用基类的数据、行为的基础上创建自己的数据和行为。类的主题成员有 字段属性方法构造函数析构函数 对象的创建使用new关键字 Class class=new Class(); 静态类和静态成员静态类是不能被实例化的，不能通过new创建对象，只能通过类去直接访问内部成员。一般类中也可以包含静态成员，同样，不能被对象访问，只能由类去访问。12345678public static class car&#123; public static string WriteName()&#123; return &quot;这是静态成员&quot;; &#125;&#125;...car.WriteName(); 静态类有以下几个特点： 静态类的所有成员都是静态成员 静态类不能被实例化 静态类是封装的，不能被继承 静态类不能包含实例构造函数，但是可以定义静态构造函数静态成员有以下几个特点： 含有静态成员的类必须有静态构造函数来初始化 静态字段通常用来记录实例对象的个数或存储该类所有对象的共享值 静态方法可以被重载但不能被重写 局部变量不能被声明为静态变量，如方法中不能声明静态变量 字段和属性字段默认为私有，可以被标记为public、private、protected、internal或protected internal，还可以声明为只读变量，用readonly关键字声明。只读字段只能在初始化或者在构造函数中赋值，静态只读字段类似于常量，但是不能在编译的时候访问，而是在运行的时候访问。字段通常具有以下属性： 字段可以被类的多个方法访问，否则可以在方法内部定义变量，而非定义类的字段 字段的生命周期比类中的单个方法的生命期长 字段可以在声明时赋值，若构造函数包含了字段的初始值，则字段声明值将被覆盖。 字段出四肢不能引用其他实例字段，但是可以是其他类的静态字段如定义公共的静态只读字段num1public static readonly int num; 若字段被标记为私有则只能通过属性来进行访问。属性结合了字段的方法和属性，既可以被当作特殊的方法使用，也可以作为普通字段进行使用。除了访问修饰符，属性还可以具有以下标记 static 静态属性virtual 虚属性sealed 它对派生类不再是虚拟的abstract 在派生类中实现 属性具有get访问器或set访问器或同时拥有，两者可以具有不同的访问修饰符。12345可访问类型 类型 名称&#123; get &#123;&#125; set &#123;&#125;&#125; get和set均可省略。若只有get则为只读属性，若只有set则为只写属性。get和set相当于Java中私有封装的getter和setter。具体用法如下： get访问器与方法类似，它必须返回属性类型的值作为属性的值，当引用属性的时候，若没有为属性赋值，则调用get访问器获取属性的值get访问器必须以return或throw结尾，并且控制权不能离开访问器get访问器除了直接返回字段值，还可以通过计算返回字段值set访问器类似于返回类型为void的方法，它使用属性类型的value隐式参数，当对属性赋值时，用提供心智的参数调用set访问器在set访问器中，对据变量声明使用隐式参数名称value是错误的。 使用属性的时候就像是使用方法一样，简单示例代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//第一个public class count&#123; public int num; public int addnum &#123; get &#123; return num + 10; &#125; set &#123;num = value - 100; &#125; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; count id=new count(); id.num=200; Console.WriteLine(id.addnum); &#125;&#125;//输出为300//第二个public class age&#123; public int agenum; public int num &#123; get &#123; return ageuum; &#125; set &#123; if ((value &gt; 0)&amp;&amp;(value &lt; 200)) &#123; value = agenum; &#125; &#125; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; age ageo=new age(); ageo.num=300; Console.WriteLine(ageo.agenum); ageo.agenum=70; Console.WriteLine(ageo.num); &#125;&#125;//输出结果为070 方法方法在类中声明，具体格式如下12访问级别 是否静态 返回值类型 方法名 （参数类型 参数1，参数类型 参数2...）｛...｝ 关于参数分为按值传递和按引用传递。前者即为传入该变量的副本，对其形式参数进行使用，不影响原变量的值。后者即为引用，如C语言中的&amp;，直接对变量本身进行操作，不使用副本。在参数前加修饰符ref或out即可。 构造函数构造函数是类调用中首先执行的函数，构造函数是方法的一种，与方法唯一不同的时构造函数在创建累的对象时执行的类方法，构造函数要与类名同名，不需要写返回值类型。构造函数可以被标记为public、protected、private、internal或者protected internal。若没有写构造函数，在C#编译器中将自动添加一个默认构造函数，来实例化对象，并将所有成员变量设置为各自类型的默认值。静态类也有构造函数，作用于非静态类构造函数一样，但静态类中构造函数为静态构造函数。构造函数可分为静态构造函数、实例化构造函数和私有化构造函数等。静态构造函数特点如下： 静态构造函数访问修饰符和参数静态构造函数在首次访问类的时候自动调用静态构造函数由编译器控制调用，开发人员无法直接调用静态构造函数私有化构造函数是一种特殊的实例构造函数。它通常用在只包含静态成员的类中，如果类中具有一个或多个私有构造函数而没有公共构造函数，则不允许其他类创建该类的实例。多态允许具有多个含不同参数的构造函数，根据参数的不同选用对应的构造函数。在一个构造函数中可以通过this关键字调用其他的构造函数。 析构函数析构函数是用来释放类资源的，它与一般方法有很大区别，主要有以下几点： 一个类只能有一个析构函数 析构函数不能被继承 析构函数由编译器调节，开发人员无法控制何时调用，由垃圾回收起决定 析构函数没有访问修饰符和参数 析构函数不能定义返回值类型，也没有返回值 程序退出时自动执行析构函数 命名的时候在名字前面加’~’以和构造函数区分开通过调用Collect强制进行资源释放，但是可能会导致程序性错误。通过来自IDisposable接口的Dispose（）可以显式地释放一些资源，为对象执行必要的清理。虽然会提高性能但垃圾回收期还是会调用析构函数对对象进行彻底清理。 类的高级应用封装对类本身，内部成员属性及方法确定是否可被访问等，是否该被隐藏。密封类，不可被继承，通常用来限制扩展性。public sealed class D{…}除此之外与其他类区别不大，可以实例，可以私有，可以共有等。 继承C#中，所有类都是直接或间接地继承Object类。类可以被连环继承。继承如下12class News&#123;...&#125;class SportsNews:News&#123;...&#125; 虚方法又被称为虚函数，是一种可以被派生类实现、重载或冲写的方法，虚函数同选择语句一样有执行条件，根据不同情况实现。一般方法在编译时就静态地编译到执行文件中，其相对地址在程序运行期间是不变的。但是虚函数在编译期间不能被静态编译，它相对地址是不变的。虚方法根据运行时期对象实例来动态判断要调用的函数，其中声明时定义的类交声明类，执行时实例化的类叫实例类。虚方法有以下特点，如下所示： 虚方法通过virtual关键字实现 虚方法通过override关键字在派生类中实现 虚方法前不允许有static、abstract或override修饰符 虚方法不能是私有的，因此不能使用private修饰符 虚函数执行过程如下所示 当调用一个对象的函数时，系统会直接去检查这个函数声明所在的类，即声明类，查看函数是否为虚函数 若不是虚函数，那么直接执行该函数。但如果是虚函数，那么程序不会立刻执行该函数，而是检查对象的实例类，即继承函数声明的类 在这个实例类，程序将检查这个实例类的定义中是否包含实现该虚函数或者重写虚函数的方法 如果有，执行实例类中实现的虚函数的方法。如果没有，系统就会不停地往上找实例类的父类，并对父类重复刚才在实例类里的检查，直到找到第一个重载该虚函数的父类为止，然后执行该父类里冲在后的方法 抽象类抽象类是一种仅用于继承的类。定义一个抽象类的目的主要是为派生类提供可共享的基类成员的公共生命。抽象类对象的抽象成员只有声明部分，没有实现部分。抽象类中的成员实现完全由继承抽象类的派生了来实现。123public abstract class A&#123; public abstract int B();&#125; 抽象类的继承必须实现对抽象类中所有未实现的成员，包括属性和方法。抽象类中抽象成员的实现和虚函数的实现一样，在方法名前用override关键字。 多态类的方法有三种多态形式 定义同名但参数列表不同的方法，被称为方法的重载定义同名且参数列表也相同的方法，并且父类中的方法用abstract/virtual进行修饰，成为方法的覆盖。子类中的同名方法也用override进行修饰，如虚方法和抽象类的覆盖定义相同且参数列表也相同的方法，其父类中的方法没有用abstract/virtual进行修饰，称为方向的隐藏。 方法的重载 方法名必须相同。 返回值可以相同也可以不同，但参数列表不能相同，因为编译器首先根据方法名选择方法，再根据参数列表在众多重载函数中找到合适的。 匹配函数时，编译器将不区分类型引用和类型本身，也不区分const和非const变量。 方法的重写有两种形式，覆盖（只能重写被abstract和virtual关键字修饰的方法，在中写的时候需要关键字override）和隐藏（直接使用new关键字重写基类中的一般方法）。重写时针对方法名相同，擦书列表也相同的方法的多态，通常时在子类中重写基类的方法。重写有以下几个特点 静态方法、密封方法和非虚方法不能被覆盖。 非虚方法可以被隐藏，但静态方法和密封方法不能被隐藏。 重写方法和已重写了的基方法具有相同的返回类型。 重写声明和已重写了的基方法具有相同的声明可访问性。重写声明不能更改所对应的虚方法的可访问性。如果已重写的基方法时protected internal，并且生命它的程序集不是包含重写方法的程序集，则重写方法声明的可访问性必须是protected。 关于后面的几个概念的举例，我懒得写了，需要的时候上网查一下就好了（估计一般也用不太上），就这样 OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"C#","slug":"C","permalink":"https://bluerbk.top/tags/C/"},{"name":"dotnet","slug":"dotnet","permalink":"https://bluerbk.top/tags/dotnet/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://bluerbk.top/tags/Microsoft/"}],"keywords":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}]},{"title":"C#基础伪教程（一）","slug":"C-First-Teaching","date":"2018-03-17T15:56:30.000Z","updated":"2018-03-17T16:13:04.653Z","comments":true,"path":"2018/03/17/C-First-Teaching/","link":"","permalink":"https://bluerbk.top/2018/03/17/C-First-Teaching/","excerpt":"","text":"由于之前学过Java的相关知识，但是由于Java在桌面程序表现的无力，决定选择新的语言，在QT和C#中还是选择了C#，不瞎扯了，我也不会扯，简单粗暴一点，C#语法和Java也很类似。老规矩，我写的教程一向都是伪教程，指不定哪天我都看不懂的那种。 配置环境我采用的是VSCode工具，虽然我也有VS2013，但是它的体积真的很庞大，写点小代码不太划算，还相当占内存。于是我采用VSCode。首先得添加C#插件，点击此处下载.NET Core SDK随后安装，成功后重启VSCode打开cmd控制台，任意进入一个路径，执行命令 dotnet new console dotnet run 第一个是在当前目录下创建C#控制台程序，第二个命令是运行程序，默认为输出”HelloWorld！“。随后在VSCode中打开对应目录下的.cs文件，进行编写，编译执行即可 初识下面一段C#的代码 using System; namespace C_ { class Program { static void Main(string[] args) { Console.Write(&quot;Hello,&quot;); Console.WriteLine(&quot;World&quot;); } } } 由上可见，C#代码包含命名空间，类名和函数名。与其他语言的区别有这些，主函数名为Main，而不是main，类Console在System命名空间中，调用Console类中的Write()和WriteLine()方法向控制台进行输出。Ps.第一个末尾不带换行，第二个自带换行。一个简单的C#程序就编写成功了。 装箱与拆箱如下代码示例装箱123int val=100;object obj=val;Console.WriteLine(&quot;对象的值为=&#123;0&#125;&quot;,obj); object为任意类型，使用一个非泛型容器，保证其通用性。拆箱示例如下1234int val=100;object obj=val;int num=(int)obj;Console.WrtieLine(&quot;num=&#123;0&#125;&quot;,num); 可以转换成原本属于的类型，也可以强制转换到任意可以相容的容易，所以必须显式强制类型转换。 循环控制语句像for(;;)、while()、do … while ();、if、switch等几乎通用，便不多赘述。在此写一个C#新见的一种循环，和用过的迭代器很像。foreach (变量生命 in 数组名或集合类），代码如下。12345int[] num=new int [5]&#123;1,2,3,4,5&#125;;foreach (int i in num)&#123; Console.Write(i);&#125; 输出为：12345 跳转语句，例如goto，continue等，也和其他语言区别不大。 数组按照Java的方式，如获得一个int数组12int[] num=new int[3]&#123;1,2,3&#125;;int[] num=&#123;1,2,3&#125;; 可以通过这样进行数组的初始化赋值。二维数组，如下例12345int[,] num=new int[3,3]&#123;...&#125;;int[,] num=&#123; &#123;3,3,3&#125;, &#123;2,2,2&#125; &#125;; 多维数组同二维数组，如[,]变为[,,]即可。 交错数组即不规则数组如如下定义1234int[][] inter=new int[3][];inter[0]=new int[4]&#123;1,2,3,4&#125;;inter[1]=new int[3]&#123;1,2,3&#125;;inter[2]=new int[5]&#123;1,2,3,4,5&#125;; 即inter数组内容为下1231 2 3 41 2 31 2 3 4 5 上面说的数组都是静态数组，在System.Array类中针对静态数组提供了一些操作的属性及方法1234567891011121314151617181920212223242526Length //数组长度，为32位整数LongLength //数组长度，为64位整数Rank //数组的秩，即维度IsReadOnly //数组是否可读IsFixedSize //数组大小是否固定IsSynchronized //是否同步访问数组SyncRoot //获取同步访问数组的对象GetValue() //获取指定元素的值SetValue() //设置指定元素的值Clear（） //清除数组的所有元素IndexOf() //获取匹配的第一个元素的索引LaseIndexOf() //获取匹配的最后一个元素的索引Sort() //对一维数组排序Reverse() //反转一维数组的元素GetLength() //获取指定唯独数组的元素数量，32位整数GetLongLength //获取指定维度的数组的元素数量，64位整数FindIndex() //搜索指定元素，并获取第一个匹配元素的索引FindLastIndex() //搜索指定元素，并获取最后一个匹配元素的索引Copy() //复制一个数组的部分元素到另一个数组CopyTo() //将一维数组中的所有元素复制到另一个一维数组中Clone() //复制数组ConstrainedCopy() //指定开始位置，并复制一系列元素到另一个数组BinarySearch() //二进制搜索算法在一维的排序数组中搜索指定元素GetLowerBound() //获取数组中指定维度的下限GetUpperBound() //获取数组中指定维度的上限 动态数组动态数组能够在程序的执行中改变数组的长度，可以增加、释放元素所占的空间，又被称为可变数组。这里主要说由System.ArrayList实现得动态数组。需要导入命名空间1using System.Collections; 创建动态数组对象1ArrayList list=new ArrayList(); ArrayList类的属性及方法如下1234567891011121314151617181920212223242526272829303132333435363738Capacity //数组容量Count //数组元素的数量IsFixedSize //数组大小是否固定IsReadOnly //数组是否为只读IsSynchronized //是否同步访问数组SyncRoot //获取同步访问数组的对象Adapter() //为指定的IList创建ArrayList包装Add() //将对象添加到ArrayList的尾部AddRange() //将ICollection的元素添加到ArrayList的尾部BinarySearch() //使用对分检索算法在已排序的ArrayList或它的一部分查找特定元素Clear() //移除所有元素Clone() //创建ArrayList的浅表副本Contains //确定某元素是否在ArrayList中CopyTo() //将ArrayList或它的一部分复制到一维数组中Equals() //确定两个Object实例是否相等FixedSize() //返回具有固定大小的列表包装，其中的元素允许修改，但不允许添加或移除GetEnumerator() //返回循环访问ArrayList的枚举数GetHashCode() //用于特定类型的哈希函数，GetHshCode适合在哈希算法和数据结构（哈希表等）中使用GetRange() //返回ArrayList，它表示源ArrayList中元素的子集GetType() //获取当前实例的TypeIndexOf() //返回ArrayList或它的一部分中某个值的第一个匹配项的从零开始的索引Insert() //将元素插入ArrayList指定的索引处InsertRange() //将集合中的某个元素插入ArrayList的指定索引处LastIndexOf() //返回ArrayList或它的一部分中某个值的最后一个匹配项的从零开始的索引ReadOnly() //返回只读的列表包装ReferenceEquals() //确定指定的Object实例是否是相同的实例Remove() //从ArrayList移除特定对象的第一个匹配项RemoveAt() //移除ArrayList的指定索引处的元素RemoveRange() //从ArrayList中移除一定范围的元素Repeat() //返回ArrayList，它元素是指定值的副本Reverse() //将ArrayList或它的一部分元素顺序反转SetRange() //将集合中的元素复制到ArrayList中的一定范围的元素上Sort() //堆ArrayList或它的一部分的元素进行排序Synchronized() //返回同步的（线程安全）列表包装ToArray() //将ArrayList的元素复制到新的数组中ToString() //返回当前Object的StringTrimTpSize() //将容量设置为ArrayList中元素的实际数目 动态数组的应用添加数组元素123ArrayList list=new ArrayList();list.Add(1);list.insert(3,0); 由于ArrayList中元素的类型位Object，若要使用foreach语句则为1234foreach (object obj in list)&#123; ...&#125; 删除数组元素123list.Remove(2);list.RemoveAt(1);list.RemoveRange(2,5); 打这么多名字有点累，可能会出错，但是报错应该还是很友好的，百度一下就知道该怎么用了。 OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"C#","slug":"C","permalink":"https://bluerbk.top/tags/C/"},{"name":"dotnet","slug":"dotnet","permalink":"https://bluerbk.top/tags/dotnet/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://bluerbk.top/tags/Microsoft/"}],"keywords":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}]},{"title":"使用HEXO+GITHUB搭建自己的博客","slug":"hexo_use","date":"2018-03-15T15:47:44.000Z","updated":"2018-03-17T15:53:01.433Z","comments":true,"path":"2018/03/15/hexo_use/","link":"","permalink":"https://bluerbk.top/2018/03/15/hexo_use/","excerpt":"","text":"博客这个东西很多网站都有，什么博客园、CSDN、简书之类的。上周还在考虑在网站上写博客，因为我一直都是自己在本地写word或者txt来记录的。突发奇想自己搭一个博客来写，又高大上还记录了还练手了。说做就做，用了两天时间差不多把基本功能实现了。 使用的工具和环境 Windows7 x64 node.js v8.1 Git 2.16.2 MarkdownPad 2 本文主要说一下博客的搭建，hexo和github联系起来，初步发布文章，修改主题，还会说一些存在的坑。（随缘配图）点击此处查看Markdown语法说明 环境的搭建node.js的安装运行node.js安装包，一路next，完成安装，退出。随后打开控制台界面（ctrl-R，输入cmd回车）运行如下命令 12node -vnpm -v 如果依次出现相对应的版本号，则表示安装成功。 Git的安装和配置运行下载的Git安装包，进入Git的安装当到了Git PATH的步骤时，选择“Use Git from the Windows Command Prompt“这个选项，这是为了将Git添加到系统环境变量里，不用再单独打开git bash运行命令了，cmd即可运行。安装成功后，执行如下命令，若安装成功则会出现Git的版本号1git -version github账号的注册和配置点击此处或打开链接https://github.com/，进行账号注册之后进入注册时填的邮箱，确认账号，不然无法成功。注册成功后，点击右上角的头像，点击 New repository，在Repository name下填写yourname.github.io，即你的github page网站的名字（比如我的是 RBK.github.io)创建成功后，代码库的右上角点击 Setting，向下找Github Page，选择master然后配置主题什么的，之后直接登录你的网站即可看到你的github page。如登陆 blueprok.github.io/RBK.github.io 就是我的主页。在Setting页面的最右下也有写你的网站地址。 HEXO的安装和配置最关键的地方来了，我在搭建的时候就在这折腾了一天。后面会写碰到的问题。关于安装hexo好像很有争议，在此我写一个我用的方法：在一个位置新建一个文件夹，最好是某个盘的根目录吧，比如我的位置时 D：\\hexo，然后运行以下命令，Hexo就安装成功了。可以通过查看版本判断是否安装成功。12npm install hexo-cli -ghexo -v 随后进行创建站点。以此执行以下命令123hexo init [new empty folder]cd [new empty folder]npm install 切记一定要是一个空的文件夹不然会报错，之后的所有步骤都要在[new empty folder]这个目录下执行命令还有要注意node.js版本，最开始我就因为node.js版本太低，导致安装hexo失败，因为npm安装的hexo是最新的，node版本也需要更新。执行完命令后执行以下命令，来生成静态页面hexo g或者hexo generate 执行hexo s或者hexo server来开启本地web服务,会提示INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.在浏览器中输入http://localhost:4000/即可看到网页了。 将github page和hexo联系起来执行命令来设置Git账户 12git config --global user.name &quot;BluePROK&quot;git config --global user.email &quot;568406972@qq.com&quot; 生成密钥（登录时需要，执行命令后按三次回车即可)ssh-keygen -t rsa -C &quot;568406972@qq.com&quot;如果提示找不到命令，说明ssh-keygen没有配置环境变量，切换路径到Git\\usr\\bin即可运行ssh-keygen。在Users文件夹里搜索密钥文件***.pub，把它打开，复制里面的内容。打开github的账户Setting，设置SSH安全，标题随便写，把pub内容复制出来完成即可，不然后面会出现无法提交网页到github的情况。在根目录的_config.yml里找到Deploy，修改信息 deploy: type: git repo: git@github.com:BluePROK/RBK.github.io.git branch: master这样就配置完成了 新建博客，执行命令hexo new post &quot;article title&quot; 会在hexo的根目录source_post里看到artitle title.md，这就是发布的文章，语法为Markdown。执行命令发布文章，每次修改都要这样hexo d -g或者 12hexo ghexo d 到目前为止hexo博客搭建完成，访问 blueprok.github.io/RBK.github.io即可看到我的网页。 PS.可能需要一个扩展，命令如下npm install hexo-deployer-git --save 在此列出借鉴的两个文章 12http://blog.csdn.net/gdutxiaoxu/article/details/53576018https://www.cnblogs.com/blogjun/articles/8289977.html 主题的设置这是HEXO的主页：https://hexo.io/，上面有关于hexo的安装、命令、使用、主题等各种内容。我在这个网站上找的一个主题BlueLake，巧了，正好也是Blue，地址是这个http://chaoo.oschina.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.html这是完整的教程，可以跟着做，我就不一一写出来了。更换主题的时候也有一个小问题，hexo s本地网站主题更换了，但是更新github主题却无法显示出来。这是第二个难题，经过多方查找，需要修改以下配置文件，根_config.yml里的URL属性修改一下，我是这样修改的12url: https://blueprok.github.io/RBK.github.io/root: /RBK.github.io url的属性即为github page网站的地址，root属性为github page仓库项目的名字。然后再hexo d -g就可以成功修改github page的主题了。 域名的绑定解析购买了域名之后，供应商都应该提供解析服务，我用的是阿里云，以这个为例。 在阿里云控制台，设置主机记录www，记录类型为A，记录值是IP192.30.252.153。其中192.30.252.153是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Github Pages。 在阿里云控制台，设置主机记录www，记录类型为A，记录值是IP192.30.252.154。同上。 在阿里云控制台，设置主机记录@，记录类型为CNAME，记录值是bluerbk.github.io.。表示将http://bluerbk.top这个主域名映射bluerbk.github.io。在这里千万不要忘记记录值中.io后面还有一个点.！ 解析设置完成之后，在本地hexo\\source新建一个文件，名字为CNAME，不要后缀，内容为域名即可（即bluerbk.top)。因为如果在github上建立文件的话下次上传的时候这个文件就被覆盖了，所以添加到本地文件，以便每次都可以保证上传，不丢失。但是此时需要修改一下根_config.yml的配置信息，即上文所说的URL信息，修改为如下，否则主题又将不能应用。12url: https://bluerbk.top/root: / OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://bluerbk.top/categories/Hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://bluerbk.top/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"https://bluerbk.top/tags/hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://bluerbk.top/categories/Hexo/"}]},{"title":"","slug":"article-title","date":"2018-03-14T15:29:26.697Z","updated":"2018-03-14T15:38:04.378Z","comments":true,"path":"2018/03/14/article-title/","link":"","permalink":"https://bluerbk.top/2018/03/14/article-title/","excerpt":"","text":"Welcome to MarkdownPad 2MarkdownPad is a full-featured Markdown editor for Windows. Built exclusively for MarkdownEnjoy first-class Markdown support with easy access to Markdown syntax and convenient keyboard shortcuts. Give them a try: Bold (Ctrl+B) and Italic (Ctrl+I) Quotes (Ctrl+Q) Code blocks (Ctrl+K) Headings 1, 2, 3 (Ctrl+1, Ctrl+2, Ctrl+3) Lists (Ctrl+U and Ctrl+Shift+O) See your changes instantly with LivePreviewDon’t guess if your hyperlink syntax is correct; LivePreview will show you exactly what your document looks like every time you press a key. Make it your ownFonts, color schemes, layouts and stylesheets are all 100% customizable so you can turn MarkdownPad into your perfect editor. A robust editor for advanced Markdown usersMarkdownPad supports multiple Markdown processing engines, including standard Markdown, Markdown Extra (with Table support) and GitHub Flavored Markdown. With a tabbed document interface, PDF export, a built-in image uploader, session management, spell check, auto-save, syntax highlighting and a built-in CSS management interface, there’s no limit to what you can do with MarkdownPad.","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2018-03-14T15:06:10.005Z","updated":"2018-03-14T15:06:10.005Z","comments":true,"path":"2018/03/14/hello-world/","link":"","permalink":"https://bluerbk.top/2018/03/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}