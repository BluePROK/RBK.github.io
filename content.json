{"meta":{"title":"蓝色的博客","subtitle":"RBK","description":null,"author":"Borui Kang","url":"https://bluerbk.top"},"pages":[],"posts":[{"title":"C#从入门到放弃 - 魔塔","slug":"Game-MoTa","date":"2018-05-21T13:56:32.000Z","updated":"2018-05-21T15:42:05.770Z","comments":true,"path":"2018/05/21/Game-MoTa/","link":"","permalink":"https://bluerbk.top/2018/05/21/Game-MoTa/","excerpt":"","text":"关于项目的开发具体也不多说吧，主要说一下具体思路和碰到的问题，简单的就这么放上来了，难的项目再放具体实例。 简介主要是在B站上看到了C++版本的魔塔视频，勾起了这个游戏的回忆，但是又不想去学习C++，就在网上搜了一下C#版本的，果然不少，我找了一些代码看了卡，借鉴了一下，再糅合一些元素，写出了我的魔塔。我就是不放图，自己脑补吧。 关于魔塔《魔塔》是一种策略类的固定数值RPG游戏。游戏需要动很多脑筋，任何一个轻率的选择都可能导致游戏的失败。魔塔游戏虽不大，但是制作精美，道具很多，而且难度不低，对智商是一次艰巨的考验。 思路设计从简介里可以看出啦，这个游戏的逻辑还是很简单的，而且界面设计是类似像素风的，主界面也是一格一格，这就相对更好设计了。主界面采用PictureBox控件，这个空间可以设置BackGroundImage和Image两个属性，后者可以覆盖前者，可以让地面和墙作为背景，怪物和物品等放在前景。地图我的是13x13的，背景和怪物分别为13x13的二维数组，算上楼层，构成三维数组。数组中可以最简单的直接采用string类型，直接保存图片的地址，但这样很不好判断什么图形是什么物体，我采用了类，分为怪物物品类和背景类，分别具有不同的属性，比如怪物物品类具有攻击力，防御力等数值，至于我为什么把这两个不相关的东西放在一起，因为我还不太懂继承的一些东西，分成两个类不太好写数组类型，所以就只能这样了，共同属性也有，比如ID，名称，图片路径等，后面可以通过ID判定这个物体是什么东西，简化了判断的过程。角色的移动、打怪、捡物品及开门等操作，即对PictureBox.Image进行操作，比如角色移动，先将这个PictureBox.Image=null，再对角色下一个位置的PictureBox.Image=cp.Image，即可完成角色的移动。关于角色的移动，先判定是否有路，也就是不撞墙，可以通过判定PictureBox的背景Image，如果为Ground就可以走，然后再进行Image的判定，进行相关动作。采用模块化编程思想，将楼层信息，主体信息，角色信息等分为不同的类进行编写，可以采用静态类读取内容，也可以实例化一个类，通过参数的传入进行各种操作。答题逻辑就是这些，下面说一下注意事项和碰到的问题。 bulabula首先，可以重写Form_Load方法，这个方法和Init方法不一样，后者是在初始化的时候进行的操作，比如变量赋值等，但是如果是对界面进行某个操作可能出现报错等问题，因为初始化阶段界面可能还没有加载好，如果想要设置界面的图形之类的，可以考虑将其加在前者重写中，当然初始化也可以，只不过可能会随缘报错。其次，可以在Form_Load重写方法中设置窗口打开的大小，比如我们在编写的过程中需要显示胜利的界面狂，在这里我还是采用的PictureBox，没有地方放，我不得已把屏幕拉宽了，即便设置PictureBox的Visible，运行了还是宽边，这时候就可以重写加载函数，重新编辑窗口大小即可。使用Thread.Sleep函数的时候，PictureBox.Image的动态设置不会生效，至于为什么，我没有查到具体的内容，不过我想可能是和缓冲区什么的有关吧，因为在休眠之后才会执行休眠之前的内容，可能和流的传输一样，需要刷新等操作将数据挤出流进行立刻传输。在此，只需要刷新一下PictureBox.Refresh即可，然后进行休眠操作，这时候就可以动态显示PictureBox的图像了。我想想还有什么，ammmmmm好像就这些吧，具体还有的话想到了再补充吧。就这样，散了散了。下一步准备写玩玩java的模拟web操作，登陆啊，点击啊什么的，然后有空了好好看看C# 的网络编程，我那个文章写了个开头一直没动，就这样。 OK,Bye","categories":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"C#","slug":"C","permalink":"https://bluerbk.top/tags/C/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://bluerbk.top/tags/Microsoft/"},{"name":"项目开发","slug":"项目开发","permalink":"https://bluerbk.top/tags/项目开发/"},{"name":"游戏开发","slug":"游戏开发","permalink":"https://bluerbk.top/tags/游戏开发/"}],"keywords":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}]},{"title":"Python从入门到放弃：利用爬虫抓取文字和图片","slug":"Python-WebBug-First","date":"2018-04-26T11:05:51.000Z","updated":"2018-04-26T15:12:30.640Z","comments":true,"path":"2018/04/26/Python-WebBug-First/","link":"","permalink":"https://bluerbk.top/2018/04/26/Python-WebBug-First/","excerpt":"","text":"在别提今天了，下午睡了至少三四个小时，看这个文章的建立时间，这不我才睡醒。写完这个得去写作业了，然后呢，有空了或者五一之后把网络编程看一看，就要去攻项目了。具体深入的我不说，我也不知道，概念我也不知道，我就会用，就这么耿直。先说说爬虫主要import的东西，requests、BeautifulSoup和urllib(3.x里urlib和urllib2合为urllib了)。 库的介绍urllibUrllib是python内置的HTTP请求库，3.x版本中urllib2已经被整合到urllib.request里了包括以下模块urllib.request 请求模块urllib.error 异常处理模块urllib.parse url解析模块urllib.robotparser robots.txt解析模块12345678import urllib.requestresponse = urllib.request.urlopen(&apos;http://www.baidu.com&apos;)print(response.read().decode(&apos;utf-8&apos;))//上面是一种，下面是包含header头部信息的方法，防止某些网页反爬虫headers=&#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0&apos;&#125;req=urllib.request.Request(url,headers=headers)page=urllib.request.urlopen(req)soup=bs(content,&apos;html.parser&apos;) post就不写了，用了再说 requestsrequests是python实现的简单易用的HTTP库，使用起来比urllib简洁很多。request也称urllib3模块。 BeautifulSoupBeautifulSoup是Python的一个库，最主要的功能就是从网页爬取我们需要的数据。BeautifulSoup将html解析为对象进行处理，全部页面转变为字典或者数组，相对于正则表达式的方式，可以大大简化处理过程。 我以前在公众号写过一个爬虫的文章。（其实乍一看，微信的排版是真的可以，这个博客还是有点太简约了）点击此处跳转这是关于新浪新闻内容的爬取，下面说一下关于图片等其他数据的爬取。因为我今天太困了，就不弄下载视屏什么的了。 利用python爬虫抓取图片抓图片重点就是，找到图片所在的链接，就是我每次用极简图床出来的那个连接一样，然后使用request.get(url).content获取图片的二进制信息，然后直接写入本地文件，修改后缀即可。上面新闻的爬取是静态网页，这里我爬王者荣耀官网，下载所有英雄的皮肤图片，他这个就是一个动态网页，什么是动态呢？动态就是说信息不在网页源代码里，而是在加载网页的时候才进行下载的。那么怎么判断是动态还是静态呢？有一个简单粗暴的技巧，右键查看网页源代码，ctrl-F搜索关键字，如果搜不出来那就是动态的了。当然动态的其实也不难分析，按F12或者右键审查元素，点击网络栏，然后刷新就会出现收到的包，挨个看找需要的就好了。直接上代码123456789101112131415import requestsimport jsonwith open(r&apos;herolist.json&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f: jsonFile=json.load(f)for i in range(0,79): ename=jsonFile[i][&apos;ename&apos;] cname=jsonFile[i][&apos;cname&apos;] skin_name=jsonFile[i][&apos;skin_name&apos;].split(&apos;|&apos;) skin_name_num=len(skin_name) for j in range(1,skin_name_num+1): url=&quot;http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/&quot;+str(ename)+&quot;/&quot;+str(ename)+&quot;-bigskin-&quot;+str(j)+&quot;.jpg&quot; html=requests.get(url).content with open(&quot;F:\\\\Programming\\\\Sublime\\\\Python\\\\Web_Bug\\\\Honor\\\\&quot;+cname+&quot;_&quot;+skin_name[j-1]+&quot;.jpg&quot;,&apos;wb&apos;) as picf: picf.write(html) print(&quot;获取英雄 &#123;0&#125; 的皮肤--&#123;1&#125; 成功&quot;.format(cname,skin_name[j-1])) 解释一下以上代码，首先根据上面说的，发现他的数据是一个json格式的文件，然后呢要审查是吧，这就比较坑，360显示不出来，谷歌浏览器乱码，让我专门下了个火狐才能看到正确的，就很坑，如下图。json文件操作用json.load导入，json其实也算是一个列表，用类似数组的方式访问，对于其中每个属性，用中括号访问即可，用split分割皮肤名，并计数，然后第一个for循环是循环每个英雄，第二个for循环是对每个皮肤进行循环，然后依次构造链接，获取图片信息，写入本地文件，下图是成果。以下代码是获取静态网页的示例，这里注释的部分是使用urllib库，没注释的用的requests库获取的网页信息，可以都参考一下123456789101112131415161718192021from bs4 import BeautifulSoup as bsimport urllib.requestimport requestsfor p in range(3,6): url=&quot;https://www.dbmeinv.com/dbgroup/show.htm?cid=7&amp;pager_offset=&quot;+str(p) #headers=&#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0&apos;&#125; #req=urllib.request.Request(url,headers=headers) #page=urllib.request.urlopen(req) #content=page.read().decode(&apos;utf-8&apos;) res=requests.get(url) res.encoding=&apos;utf-8&apos; #soup=bs(content,&apos;html.parser&apos;) soup=bs(res.text,&apos;html.parser&apos;) src=soup.find_all(&apos;img&apos;) for i in src: pic_src=requests.get(i[&apos;src&apos;]).content name=i.get(&apos;title&apos;) #i.get(&apos;title&apos;)或者i[&apos;title&apos;]都可以 with open(&apos;F:\\\\Programming\\\\Sublime\\\\Python\\\\Web_Bug\\\\ttui\\\\&apos;+name+&apos;.jpg&apos;,&apos;wb&apos;) as f: f.write(pic_src) print(name+&quot;\\t写入完成&quot;) OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"Python","slug":"Python","permalink":"https://bluerbk.top/categories/Python/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"Python","slug":"Python","permalink":"https://bluerbk.top/tags/Python/"},{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://bluerbk.top/tags/网络爬虫/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://bluerbk.top/categories/Python/"}]},{"title":"C#基础伪教程（五）网络编程","slug":"CSharp-Seventh-NetConnection","date":"2018-04-24T14:59:42.000Z","updated":"2018-04-24T15:11:21.234Z","comments":true,"path":"2018/04/24/CSharp-Seventh-NetConnection/","link":"","permalink":"https://bluerbk.top/2018/04/24/CSharp-Seventh-NetConnection/","excerpt":"","text":"高产似那啥，今天可能出不来这个文章了，明天发吧。其实这个不用重点介绍概念什么的了，突然想起来之前写过java的网络编程，可以把这两个文章结合起来看。最后写一个实例是Java和C#进行通信的例子，有GUI的。 网络编程有UDP啊，TCP啊，喜闻乐见的Socket啊什么的，打算把这些都搞一下，以前一直用java的Socket，也用Socket在Java和C#发送消息，看了看好像C#的TCP不难，那就试试吧，都可以给一个实例的，是实例不是示例。 Socketsocket非常类似于电话插座。以一个电话网为例：电话的通话双方相当于相互通信的2个程序，电话号码就是ip地址。任何用户在通话之前，首先要占有一部电话机，相当于申请一个socket；同时要知道对方的号码，相当于对方有一个固定的socket。然后向对方拨号呼叫，相当于发出连接请求。对方假如在场并空闲，拿起电话话筒，双方就可以正式通话，相当于连接成功。双方通话的过程，是一方向电话机发出信号和对方从电话机接收信号的过程，相当于向socket发送数据和从socket接收数据。通话结束后，一方挂起电话机相当于关闭socket，撤销连接。套接字分类 流式套接字（SOCK_STREAM）：提供了一种可靠的、面向连接的双向数据传输服务。实现了数据无差错，无重复的发送，内设流量控制，被传输的数据被看做无记录边界的字节流。在TCP/IP协议簇中，使用TCP实现字节流的传输，当用户要发送大批量数据，或对数据传输的可靠性有较高要求时使用流式套接字。 数据报套接字（SOCK_DGRAM）：提供了一种无连接、不可靠的双向数据传输服务。数据以独立的包形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端数据按发送顺序接收。在TCP/IP协议簇中，使用UDP实现数据报套接字。 原始套接字（SOCK_RAW）：该套接字允许对较低层协议（如IP或ICMP）进行直接访问。一般用于对TCP/IP核心协议的网络编程。","categories":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"C#","slug":"C","permalink":"https://bluerbk.top/tags/C/"},{"name":"dotnet","slug":"dotnet","permalink":"https://bluerbk.top/tags/dotnet/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://bluerbk.top/tags/Microsoft/"},{"name":"网络编程","slug":"网络编程","permalink":"https://bluerbk.top/tags/网络编程/"}],"keywords":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}]},{"title":"C#基础伪教程（六）SQL数据库访问及线程操作","slug":"CSharp-Sixth-SQLCon","date":"2018-04-24T06:36:33.000Z","updated":"2018-04-24T11:21:01.443Z","comments":true,"path":"2018/04/24/CSharp-Sixth-SQLCon/","link":"","permalink":"https://bluerbk.top/2018/04/24/CSharp-Sixth-SQLCon/","excerpt":"","text":"关于这个线程今天看了看，还是没有找到停止的方法，文档写的Abort()方法，但是这个说明是一般情况下可以停止，就是说他可能调用之后没有停止，在完成某些逻辑之后才停止，而且它是通过抛出异常来执行的，有说调用方法之后用while一直检测线程状态，可是好像并没有什么用，再看看吧。这次主要是线程的一点小操作和大头的SQL数据库访问，之前用JDBC已经实现了用JAVA访问数据库，现在用ADO.NET实现。 ADO.NET是一组用语和数据源交换的面向对象类库，位于System.Data.dll中，与System.Xml.dll中的XML集成，在.NET Framework中提供最直接的数据访问方法。.NET Framework对数据进行操作，访问读写等，将获得的结果存储于DataSet中。.NET Framework提供以下数据提供程序 用于SQL Server的数据提供程序（System.Data.SqlClient） 用于OLE DB的数据提供程序（System.Data.OleDb） 用于ODBC的数据提供程序（System.Data.Odbc） 用于Oracle的数据提供程序（System.Data.Oracle） 问题来了，我写了好些，还睡了一觉，起来发现，我写错了，书上用的是Microsoft SQL Server对吧，这玩意不是MySql！！！！不是！！我说我咋试了半天没成功，真辣鸡，我暂时不用Sql Server，所以我就不写了，以后用不用我也不知道，到时候再说下面说说C#链接！！！ 准备工具(我的环境如下，工具点击下载） VS 2013 Windows 7 x64 mysql-community-5.5.60.1 mysql-connector-net-6.9.11.msi VS2013对应的版本应该是C#5.0和.NET4.5这里使用的MySQL Connector Net的dll版本为4.5，可能是因为我的连接器版本太高了，只有4.5的，我的文件在C:\\Program Files(x86)\\MySQL里面。慎用高版本，8.0.11果然用不了，它支持.NET4.5.2，我是4.5.坑，用6.9.11版本，不知道是不是我安装的问题。 工具的安装及配置MySql关于MySql的安装我去年装过，在本地写了一点，以下内容，应该能用。（均可在mysql.com官网下载）运行mysql-5.5.57-winx64.msi安装MySQL控制台。在C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin中运行MySQLInstanceConfig.exe配置MySQL。MySQL命令行安装完成。在官网找MySQL Workbench下载MySQL的图形化界面mysql-workbench-gpl-5.2.47-win32.msi。在webyog官网（webyog.com/cn）中下载最受追捧的图形化工具SQLyog711EntTrial.exe。可直接百度sqlyog。官网进不去。 MySql-Connector-Net这个的安装直接运行mysql-connector-net-6.9.11.msi即可。 使用先启动MySql服务，然后在VS的C#项目里添加引用C:\\Program Files (x86)\\MySQL\\MySQL Connector Net 6.9.11\\Assemblies\\v4.5\\MySql.Data.dll，.cs文件前添加引用using MySql.Data.Connection，即可使用。 C#链接MySql首先需要一个包含数据库相关信息的一个字符串，如下所示，从变量名应该能看出什么是什么，就不解释了，server是服务器的IP地址。1string connectionString = &quot;server=localhost;User Id=root;password=root;Database=text_java&quot;; 以下代码分别是 建立数据库连接 打开数据库 建立数据库查询语句 执行语句 释放资源 关闭数据库123456MySqlConnection conn = new MySqlConnection(connectionString);conn.Open();MySqlCommand myc = new MySqlCommand(&quot;insert into baseinfo values (&apos;Kang&apos;,&apos;111111&apos;,10);&quot;, conn);myc.ExecuteNonQuery()conn.Dispose();conn.Close(); ExecuteNonQuery()这个方法返回一个int好像，如果里面有内容，即返回值&gt;0，则执行成功。以下是向数据库插入一条信息的完整代码。增删改除都可以用这样，只需要修改一下Command中的命令即可。12345678910111213141516171819202122string connectionString = &quot;server=localhost;User Id=root;password=root;Database=text_java&quot;; public void sql() &#123; Console.WriteLine(&quot;正在连接数据库&quot;); MySqlConnection conn = new MySqlConnection(connectionString); try &#123; conn.Open(); Console.WriteLine(&quot;连接成功&quot;); MySqlCommand myc = new MySqlCommand(&quot;insert into baseinfo values (&apos;Kang&apos;,&apos;111111&apos;,10);&quot;, conn); Console.WriteLine(myc.CommandText); if (myc.ExecuteNonQuery() &gt; 0) &#123; Console.WriteLine(&quot;数据插入成功！&quot;); &#125; conn.Dispose(); conn.Close(); &#125; catch (Exception) &#123; Console.Write(&quot;超时&quot;); &#125; &#125; 从MySql读取数据使用DataSet，这个还可以直接把里面的数据输出到GUI的DataGridView表格里，就是我的音乐列表那个东西。关于DatSet一个DataSet里头可以有多个表，可以用过Add添加DataTableCollection，也可以通过Remove移除表。（题外话，如果想把数据放到表格里，这样dataGridView1.DataSource = ds.Tables[“table”];，没试过不清楚）然后用以下这个方法依次获取每个表的每一行的每一列1234567891011121314private void PrintRows(DataSet dataSet)&#123; // For each table in the DataSet, print the row values. foreach(DataTable table in dataSet.Tables) &#123; foreach(DataRow row in table.Rows) &#123; foreach (DataColumn column in table.Columns) &#123; Console.WriteLine(row[column]); &#125; &#125; &#125;&#125; 一个完整的打印Select * from baseinfo;的结果的代码如下123456789101112131415161718192021222324252627282930313233343536string connectionString = &quot;server=localhost;User Id=root;password=root;Database=text_java&quot;; private void PrintRows(DataSet dataSet) &#123; // For each table in the DataSet, print the row values. foreach (DataTable table in dataSet.Tables) &#123; foreach (DataRow row in table.Rows) &#123; foreach (DataColumn column in table.Columns) &#123; Console.WriteLine(row[column]); &#125; &#125; &#125; &#125; public void sql() &#123; Console.WriteLine(&quot;正在连接数据库&quot;); DataSet ds = new DataSet(); MySqlConnection conn = new MySqlConnection(connectionString); try &#123; conn.Open(); Console.WriteLine(&quot;连接成功&quot;); MySqlCommand myc = new MySqlCommand(&quot;select * from baseinfo&quot;, conn); Console.WriteLine(myc.CommandText); MySqlDataAdapter da = new MySqlDataAdapter(&quot;select * from baseinfo&quot;, conn); da.Fill(ds, &quot;table&quot;); Console.WriteLine(&quot;数据获取成功&quot;); PrintRows(ds); conn.Dispose(); conn.Close(); &#125; catch (Exception) &#123; Console.Write(&quot;超时&quot;); &#125; &#125; 最后插一点线程操作吧如下构造一个新线程12Thread t=new Thread([一个方法]);//方法为对象.方法，或者new 类.方法 目前我还是没有找到让线程停止的好办法！！！！！！！！！ 线程启动的方法为Start（） 挂起方法为Suspend() 挂起后恢复的方法为Resume() 中止方法Abort()(我还没成功过） 线程休眠方法Sleep（），也就是暂停 等待线程中止Join（），就是当我需要这个线程结束的时候再执行下一个线程，可以对这个线程调用这个方法，可以带一个时间参数，如果时间到了这个线程没有执行，那么下一个线程依旧可以执行以下是一个分别输出.和=的两个线程的代码，其中=延迟两秒输出。12345678910111213141516171819202122232425262728293031using System;using System.Threading;namespace C_&#123; class my&#123; public void x()&#123; for (int i=0;i&lt;300;i++)&#123; Console.Write(&quot;.&quot;); Thread.Sleep(30); &#125; &#125; public void y()&#123; for (int j=0;j&lt;300;j++)&#123; Console.Write(&quot;=&quot;); Thread.Sleep(30); &#125; &#125; &#125; class Program &#123; static void Main()&#123; my m=new my(); Thread t1=new Thread(m.x); Thread t2=new Thread(m.y); t1.Start(); Thread.Sleep(2000); t2.Start(); &#125; &#125;&#125; 执行效果如下图，同时可以浅显地解释多线程的原理，实际上就是多个线程交替使用资源，交替执行，因为交替的速度和执行一条命令的速度之快，以至于我们认为这是同时进行的。顺便附上我写的那个文件扫描的小工具，忽略那个线程不能终止的小问题，其他我觉得很ok啊。 OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"C#","slug":"C","permalink":"https://bluerbk.top/tags/C/"},{"name":"dotnet","slug":"dotnet","permalink":"https://bluerbk.top/tags/dotnet/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://bluerbk.top/tags/Microsoft/"},{"name":"SQL数据库","slug":"SQL数据库","permalink":"https://bluerbk.top/tags/SQL数据库/"}],"keywords":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}]},{"title":"C#基础伪教程（五）C#的流操作","slug":"CSharp-Fifth-Stream","date":"2018-04-20T06:03:09.000Z","updated":"2018-04-22T06:03:56.961Z","comments":true,"path":"2018/04/20/CSharp-Fifth-Stream/","link":"","permalink":"https://bluerbk.top/2018/04/20/CSharp-Fifth-Stream/","excerpt":"","text":"上次写还是差不多两周前了，最近也不知道在干什么。先吐槽这个该死的迅雷的下载机制，一下载东西我的电脑就卡，我还不想限速，只能看ppt了。最近还想着再把Java看一看，C#再深入一点然后直接去攻前端，用Java做后端。这次说这个流，流这个东西很常见，Java里经常用到，比如文件操作，Socket通信之类的，功能的强大与否其实取决于你的流选择的是否正确。 System.IO命名空间System.IO命名空间提供了所有与文件、目录和流相关操作的类，直接使用这些方法即可。如下是常用的类 内存流（MemoryStream）是一种非缓冲流，可以直接在内存中访问数据。以下是常用的属性和方法简单示例如下123456789101112131415161718192021222324252627byte[] String=uniEncoding.GetBytes(&quot;sss&quot;);//使用这个类中的这个方法将指定字符串转换为byte字节数组using (MemoryStream memStream=new MemoryStream(100))&#123; memStream.Write(String,0,String.Length); 或者 count=0; while (cunt&lt;String.Length)&#123; memStream.WriteByte(String[count++]); &#125;&#125;//通过属性调用获取关于流的相关信息memStream.Length.ToString() //输出流的长度//从流中读取数据并输出//定位流的开始位置memStream.Seek(0,SeekOrigin.Begin);byteArray=new byte[memStream.Length];//从0开始读取20个字节给ByteArraycount=memStream.Read(byteArray,0,20);//另一种方法继续读取while(count &lt; memStream.Length)&#123; byte[count++]=Convert.ToByte(memStream.ReadByte());&#125;//转为char数组，然后再转为中文charArray=new char[uniEncoding.GetCharCount(byteArray,0,count)];uniEncoding.GetDecoder().GetChars(byteaRRAY,0,COUNT,CHARaRRAY,0);Console.Write(charArray); 文件流（FileStream）使用文件流可以对文件进行的打开，关闭，查看相关信息等操作。可以指定是同步还是异步操作，相关属性方法如下FileStram最常用的构造函数如下FileStream(String filepath,FileMode)FileMode是一个枚举类型，具有以下几个值 Create 创建一个新的文件，如果存在则覆盖 CreateNew 创建一个新的文件，如果存在则会异常，提示文件已存在 Open 打开一个存在的文件 OpenOrCreate 打开一个文件，若不存在则创建一个新文件 Truncate 打开现有文件，一旦打开，将被截断为零字节大小 Append 如果文件存在，则进行追加写操作 以下是简单示例好像需要catch异常 123456789101112131415161718string filepath=&quot;text.txt&quot;;string str=&quot;Sss&quot;;FileStream fs=ne FileStream(filepath,FileMode.Create);byteArray=System.Text.Default.GetBytes(str);fs.Write(byteArray,0,byteArray.Length);fs.close();Console(&quot;ok&quot;);//下面是读取内容fs=new FileStream(filepath,FileMode.Open);int count=fs.Length;byteArray=new byte[count];fs.Seek(o,SeekOrigin.Begin);fs.Read(byteArray,0,count);//数据转换Decoder d=Encoding.Default.GetDecoder();charArray=new Char[count];d.GetChars(byteArray,0,byteArray.Length,charArray,0);Console.Write(&quot;内容为&quot;+charArray); 获取文件系统信息获取文件信息（FileInfo）这个类提供有关文件操作的相关操作，比如删除，移动，打开文件等，需要实例化才可以使用。使用这个类可以编写类似文件管理器之类的程序（这就作为这章的作业吧）。以下为常用的属性方法简单示例如下123456789101112String filepath=@&quot;C:\\Program\\iexplore.exe&quot;;FileInfo fi=new FileInfo(filepath);//文件大小，文件名，文件扩展名，文件完整目录，最后一个更新时间，时间操作都差不多，两个时间加起来fi.Length(字节)fi.Name;fi.Extensionfi.FullName;fi.LastWriteTime.ToLongDateString()+fi.LastWriteTime.ToLongTimeString();//写文件using(StreamWriter sw=fi.CreateText())&#123; sw.WriteLine(&quot;sss&quot;);&#125; 目录信息（DirectoryInfo）获取某个目录的信息需要用到这个类，提供了四个属性获取目录的名称、父目录和根目录等，如下 Exists 判断指定路径是否存在，返回一个boolean Name 获取目录的名称 Parent 获取指定子目录的父目录名称 Root 获取目录的根部分简单示例1234567DirectoryInfo d=new DirectoryInfo(filepath);//修改目录属性fi.Attributes=FileAttributes.ReadOnly;//父路径、目录创建时间、最后一次访问时间di.Parent;di.CreationTime.ToString();di.LastAccessTime.ToString(); 驱动器信息（DriveInfo）可以对计算机的驱动器进行操作，仅包含一个静态方法，GetDrives()，可以检索所有逻辑驱动器的名称，返回一个包含驱动器列表的数组。提供一下相关属性 AvaliableFreeSpace 指示驱动器上的可用空闲空间量 DriveFormat 指示文件系统的名称，如NTFS或者FAT32 IsReady 获取一个指示驱动器是否已准备好 Name 获取驱动器的名称 RootDirectory 获取驱动器根目录 TotalFreeSpace 获取驱动器上的可用空闲空间总量 TotalSize 获取驱动器上存储空间的总大小 VolumeLabel 获取或设置驱动器的卷标 DriveType 驱动器类型 Unknown 无法确定驱动器类型Removable 可移动媒体驱动器，软盘驱动器等Fixed 固定媒体驱动器，硬盘等Network 网络驱动器，包括共享驱动器CDROM CDROM驱动器RAM RAM磁盘 简单示例12345DriveInfo drvInfo=new DriveInfo(&quot;C:\\&quot;);//输出名称，卷标文件系统类型，总共空间大小drvInfo.Name;drvInfo.DriveFormat;drvInfo.TotalSize; 操作目录（DirectoryInfo）提供对目录信息进行获取的方法，是实例类。如果对目录操作的话需要用Directory类，这是静态类，不需要实例化即可使用。创建一个可以调用Directory类的CreateDirectory（）方法1234public static DirectoryInfo CreateDirectory(string path);//示例，在C盘创建一个名为MyDir的目录，输出该目录的信息Directory di=Directory.CreateDirectory(&quot;C:\\MyDir&quot;);Console.Write(&quot;&#123;0&#125;目录创建成功，创建时间&#123;1&#125;&quot;,&quot;C:\\&quot;,Directory.GetCreationTime(&quot;C:\\MyDir&quot;)); 移动和重命名目录1public static void Move(string sourceDieName,string destDirName); 删除目录12public static void Delete(string path);public static void Delete(string path,bool recursive); 第一个参数为删除的目录，如果不为空会抛出异常，第二个参数为true时会删除目录所有的子目录和文件，否则会抛出异常。 遍历目录获取指定目录下的子目录和文件，调用Directory类中的GetFiles（）方法和GetDirectories（）方法123public static string[] GetFiles(string path);public static string[] GetFiles(string path,string searchPattern);public static string[] GetFiles(string path,string SearchPattern,SearchOption searchOption); 第一个参数表示目录名，执行之后会返回目录中包含的所有文件，第二个参数表示指定目录中匹配的文本名，第三个指定搜索操作包含所有子目录还是仅当前目录。简单示例如下12//获取C盘中所有的exe文件string[] fileName=Directory.GetFiles(dir,&quot;*exe&quot;); GetDirectories（）方法构造函数和上面一样，参数也一样。 操作文件File.Create()创建一个文件1234public static FileStream Create(string path);public static FileStream Create(string path,int bufferSize);public static FileStream Create(string path,int bufferSize,SileOptions);public static FileStream Create(string path,int bufferSize,SileOptions,FileSecuroty); 复制文件1File.Copy(path1,path2); 读取和写入文件读取文件（StreamReader）提供读取文件的功能，不仅可以读取文件，还可以处理任何流信息。构造函数如下12public StreamReader(string path);public StreamReader(string path,System.Text.Encpding encoding); 魔人编码为UTF8，不是系统的ANSI编码，UTF8可以正确处理Unicode字符并提供一个一直的结果，可以通过第二个参数选择指定编码。常用方法如下 Read（） 读取输入流中的下一个字符，没有可用时返回-1 ReadLine（） 读取一行字符并作为字符串返回，如果达到文件末尾则为空引用 ReadToEnd（） 从文件当前位置读取到文件末尾，如果当前为止为开头，则读取整个文件 Close（） 关闭读取并释放资源 Peek（） 返回文件的下一个字符，但是不使用，如果没有可用的字符或者文件不支持查找返回-1 简单示例123456//选择文件并逐行显示StreamReader reader=new StreamReader(path,System.Text.Encoding.Default);while (!reader.EndOfStream)&#123; this.textBpx1.Text+=reader.ReaderLine()+&quot;\\r\\n&quot;;&#125;reader.Close(); 写入文件（StreamWriter）写入文件的前提是具有文件的写入权限。写入文件的步骤为：先实例化一个StreamWriter对象，调用它的方法将字符流写入文件中，最后调用Close（）保存写入的字符并释放资源。构造函数如下1234public StreamWriter(Stream stream);public StreamWriter(string path);public StreamWriter(string path,System.Text.Encoding encoding);public StreamWriter(string path,bool append,System.Text.Encoding encoding); 如果文件不存在则会自动创建新文件，bool append决定是改写文件还是追加文件。常用方法 Write（） 字符串写入文件 WriteLine（） 项文件写入一行字符串，即写入换行符 Flush（） 清理当前缓冲区，将缓冲区的数据写入文件 Close（） 关闭写入刘并释放资源，即保存文件 简单示例1234567//以打开方式创建实例FileStream fs=new FileStream(filepath,System.IO.FileMode.Open);//以默认编码创建StreamWriter实例StreamWriter bw=new StreamWriter(fs,System.Text.Encoding.Default);bw.Write(this.textbox1.Text);bw.Write(&quot;\\r\\n&quot;);bw.Close(); 二进制文件的读写BinaryWriter和BinaryReader类。自己去学吧，我不玩。 写的一个小案例是磁盘文件扫描系统，GUI是Winform。有一个小BUG，就是线程进行的时候用Abort()停不下来，不能结束线程，只能处于挂起状态，除非彻底关闭应用程序才可以，但是不影响使用应该，点击开始总是会新建一个线程，但是不知道会不会覆盖原来的线程，如果不会的话就不能开太多，不然内存就大了 OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"C#","slug":"C","permalink":"https://bluerbk.top/tags/C/"},{"name":"dotnet","slug":"dotnet","permalink":"https://bluerbk.top/tags/dotnet/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://bluerbk.top/tags/Microsoft/"},{"name":"流","slug":"流","permalink":"https://bluerbk.top/tags/流/"}],"keywords":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}]},{"title":"C#基础伪教程（四）内置类","slug":"CSharp-Forth-Teaching","date":"2018-04-06T16:53:09.000Z","updated":"2018-04-07T06:43:53.572Z","comments":true,"path":"2018/04/07/CSharp-Forth-Teaching/","link":"","permalink":"https://bluerbk.top/2018/04/07/CSharp-Forth-Teaching/","excerpt":"","text":"有十来天没有写了，继续上次的摊子写，这次是C#的内置类编程，也就是一些实用的封装好了的方法类，主要有五个，分别是String类、StringBuilder类、日期和时间处理类、Regex类和Thread类，这是实际开发中最常用的五个类，下面就各个类依次讲解。 String类字符串String类位于System命名空间里，使用sealed关键字修饰,所以不能被继承，但是String类里提供了大量字符串操作方法可供使用。 创建一个字符串变量1string str=&quot;hello,C#&quot;; String也就是一个字符串数组，同样可以用下标来访问对应元素。除了以上方法创建字符串，还提供了八个构造函数12345678910111213141516public String(char* value);//将String类的新实例初始化为由指向Unicode字符数组的指定指针指示的值public String(char[] value);//将String类的新实例初始化为由Unicode字符数组指示的值public String(sbyte* value);//将String类的新实例初始化为由指向8位有符号整数数组的指针指示的值public String(char c,int count);//将String类的新实例初始化为由重复指定次数的指定Unicode字符指示的值public String(char* value,int startIndex,int length);//将String类的新实例初始化为由指定Unicode字符数组的指定指针、该数组内的起始字符位置和一个长度指示的值public String(char[] value,int startIndex,int length);//将String类的新实例初始化为由指定Unicode字符数组、该数组内的起始字符位置和一个长度指示的值public String(sbyte* value,int startIndex,int length);//将String类的新实例初始化为由指向8位有符号整数数组的指针指示、该数组内的起始字符位置和一个长度指示的值public String(sbyte* value,int startIndex,int length,Encoding enc);//将String类的新实例初始化为由指向8位有符号整数数组的指针指示、该数组内的起始字符位置、长度和Encoding对象指示的值 简单示例如下所示12345678char[] charStr=&#123;&apos;明&apos;,&apos;天&apos;,&apos;会‘，’更&apos;,&apos;好&apos;&#125;;string str=&quot;春夏秋冬&quot;;string str-=str;string str1=new string(charStr);string str2=new string(charStr,2,3);string str3=new string(&quot;*&quot;,10);//str0、str1、str2、str3的值分别为//春夏秋冬、明天更美好、更美好，********** 转换大小写12public string ToUpper();public string ToLower(); 对string字符串直接调用方法即可，如str.ToUpper(); 除去空格和特定字符123456Trim() //去除字符串前后空白TrimStart()//从字符串开始位置删除空白字符或指定字符TrimEnd()//从字符串结尾删除空白字符或指定字符 括号里不带参数则除去空白字符，若带字符参数则删除指定字符。 连接字符串1234Concat();//参数直接为需要链接的多个字符串join(a,b,c,d);//join()方法可以将指定字符串数组中的所有字符串链接在一起，a为链接的间隔符，间隔为空白，斜杠等，b为字符串数组，c为起始下标，d为链接字符的个数 替换字符String类的Replace()方法可以替换字符。1234string Replace(char oldchar,char newchar);//将字符串中指定的字符替换为新的字符string Replace(string oldvalue,string newvalue);//将字符串中指定的字符串替换为新的字符串 比较字符串可以直接使用“==”进行比较，看两个字符串是否相等，也可以使用Equals(),Contains(),Compare()和CompareTo()函数 Equals()方法构造函数如下12345public override bool Equals(object obj);public bool Equals(string value);public static bool Equals(string a,string b);public bool Equals(string value,StringComparison comparisonType);public static bool Equals(string a,string b,StringComparison comparisonType); 在比较的时候区分大小写，返回值为bool的时候，返回true表示相等，false表示不等。 Contains()用于确认某个字符串中是否包含另一个字符串。1public bool Contains(string value); 返回bool型，若value在该字符串中则返回true，否则返回false。 Compare()和CompareTo()12str1.CompareTo(str2);string.Compare(str1,str2); 均为比较两个字符串 str1&gt;str2 返回1str1==str2 返回0str1&lt;str2 返回-1两者均实现了方法重载，在此列出比较实用的几个1Compare(str1,index1,str2,index2,length,boolean); index1和index2为响应整数偏移量，length表示比较的字符串字符的最大数量，boolean表示是否忽略大小写。 查找字符串相关方法如下123456789101112IndexOf(str);//返回子字符串或字符串中第一次出现的索引位置.若没找到返回-1IndexOfAny(str);//返回子字符串或部分匹配第一次出现的索引位置，若没找到返回-1LastIndexOf(str);//返回指定子字符串的最后一个索引位置，如果没有找到返回-1LastIndexOfAny(str);//返回指定子字符串或部分匹配的最后一个位置，如果没有找到子字符串返回-1StartsWith(str);//判断字符串是否已制定子字符串开始，返回值为true或falseEndsWith(str);//判断字符串是否以指定子字符串结束，返回值为true或false 分隔字符串C#中实现分隔字符串使用System类中的Split()方法，这和Java很类似，有以下构造函数123456string[] Split(params char[] separator);string[] Split(char[] separator,int count);string[] Split(char[] separator,StringSplitOptions options);string[] Split(string[] separator,StringSplitOptions options);string[] Split(char[] separator,int count,StringSplitOptions options)string[] Split(string[] separator,int count,StringSplitOptions options); separator表示需要分隔的字符或字符串数组，count表示返回的字符串最大数量，options表示分隔选项，是一个枚举类型，主要有以下两个值System.StringSplitOptions.RemoveEmptyEntries 省略返回的空数组System.StringSplitOptions.None 包含返回的空数组例如，分隔如下字符串123char[] separator=&#123;&apos;,&apos;,&apos;|&apos;,&apos;/&apos;&#125;;string str=...;str.Split(separator); 截取子字符串使用String类中的Substring()方法，有以下两个重载12String Substring(int index1);String Substring(int index1,int index2); 很显然，分别为从指定位置开始截取和从指定位置截取指定字符数的字符串。 移除字符串使用String类中的Remove()方法，该方法有以下两个重载12public string Remove(int startindex);public string Remove(int startindex,int count); 同样，分别为从指定位置开始删除和从指定位置删除特定字符数的字符串。 ##StringBuilder类字符串String类的字符串内容是不可变的，每次使用ystem.String类中的方法的时候都需要创建一个新的字符串对象，这就需要重新分配控件，因此在对字符串进行重复修改等操作的时候，与创建新的String对象相关的系统开销可能会十分昂贵。因此可以使用System.Text.StringBuilder类，在修改字符串的时候不必创建新的对象，可以提升性能。StringBuilder提供以下六个构造函数123456789101112public StringBuilder();//初始化一个空的StringBuilder实例public StringBuilder(int capacity);//使用指定容量初始化StringBuilder新实例public StringBuilder(string value);//使用指定字符串初始化StringBuilder类的新实例public StringBuilder(int capacity,int maxCapacity);//吃石化StringBuilder实例，该类起始于指定容量并可增长到最大容量public StringBuilder(string value,int capacity);//使用指定字符串和容量初始化StringBuilder类的新实例public StringBuilder(string value,int startIndex,int length,int capacity);//用指定的子字符串和容量初始化StringBuilder类的新实例。 插入字符串可以再指定位置插入特定的字符数字或字符串等内容。使用StringBuilder类中的Insert()方法实现，该方法提供18个重载，几乎可以将任意类型的值插入到字符串的指定位置，以下列出常用的12345678Insert(int index,double value);Insert(int index,string value);Insert(int index,char value);Insert(int index,bool value);//将布尔型的表现形式插入到指定位置Insert(int index,int value);Insert(int index,string value,int count);//将指定字符串的一个或多个副本插入到指定位置 追加字符串StringBuilder类提供了以下方法追加字符串 Append()AppendLine() 在追加的字符串后再加一个换行符AppendFormat() 先格式化被追加字符串，再将其追加到字符串末尾 Append()方法Append()方法提供了19个重载，几乎可以追加任何类型的值，以下列出常用的几个12345678Append(double value);Append(string value);Append(char value);Append(bool value);//将布尔型的表现形式追加到指定位置Append(int value);Append(string value,int index,int count);//在实例结尾处追加指定字符串的副本 AppendLine()方法在Append()方法基础上，每次追加一个换行符，有以下两个重载 AppendLine() 默认追加换行符（行终止符）。AppendLine(string value) 将后面跟有默认换行符的指定字符串副本追加到当前对象末尾 AppendFormat()方法我不想写了，有用的话自己百度吧。 移除字符串同样适用Remove()方法public StringBuilder Remove(int startIndex,int length);从指定位置删除指定字符数的字符串。 替换字符串这个功能其实挺有用的，比如敏感词汇，密码什么的，适用Replace()，这个方法String和StringBuilder里都可以用。1234public StringBuilder Replace(char oldChar,char newChar);public StringBuilder Replace(string oldValue,string newValue);public StringBuilder Replace(char oldChar,char newChar,int startIndex,int count);public StringBuilder Replace(string oldValue,string newValue,int startIndex,int count); StringBuilder的其他常用方法Equals()，若相等，则返回true否则false。EnsureCapacity()，保证StringBuilder有最小指定容量。ToString()，将实例转为String类型。ToString(int startIndex,int length),将制定子字符串转为String类型。 时间和日期的处理.NET Framework提供了DateTime结构和TimeSpan结构。 TimeSpan结构表示时间间隔或持续时间，按正负天数，小时数，分钟数，秒数以及秒的小数部分进行度量，最大单位为天。TimeSpan的值等于所表示的时间间隔的刻度值，一个刻度为100ns，TimeSpan对象的值范围是MinValue和MaxValue之间。TimeSpan值表示时间形式如下1[-]d.hh:mm:ss.ff [-]可选，表示负时间间隔。可以自行设置时间，构造函数如下1234public TimeSpan(long ticks);public TimeSpan(int hours,int minutes,int seconds,int millisconds);public TimeSpan(int days,int hours,int minutes,int seconds);public TimeSpan(int days,int hours,int minutes,int seconds,int millisconds); TimeSpan包含八个静态字段，三个只读字段和五个常数字段 MaxValue 最大TimeSpan值MinValue 最小TimeSpan值Zero 零TimeSpan值TicksPerDay 一天的刻度值TicksPerHour 一小时的刻度值TicksPerMillisecond 一毫秒的刻度值TicksPerMinute 一分钟的刻度值TicksPerSecond 一秒钟的刻度值例如，TimeSpan.TicksPerSecond；输出为10000000.TimeSpan有以下11个属性12345678Days 获取TimeSpan结构所表示的时间间隔的天数Hours 获取TimeSpan结构所表示的时间间隔的小时Milliseconds 获取TimeSpan结构所表示的时间间隔的毫秒数Minutes 获取TimeSpan结构所表示的时间间隔的分钟数Seconds 获取TimeSpan结构所表示的时间间隔的秒数Ticks 获取当前结构的刻度值TotalDays 获取以整天数和天的小数部分表示当前TimeSpan结构的值...以此类推 TimeSpan有以下几个静态方法1234567891011121314151617Compare()//比较两个TimeSpan的值，返回职位1、0或-1Equals()//判断两个值是否相等，相等为true，否则为falseFromDays()//根据指定天数创建一个TimeSpan()实例...以此类推fROMtICKS()//根据刻度值创建TimeSpan实例Parse()//将时间间隔字符串转换为TimeSpanParseExact()//将时间间隔字符串转换为TimeSpan，该字符串格式必须与指定格式一样。TryParse()//将时间间隔字符串转换为TimeSpan，并返回是否成功。TryParseExact()//将时间间隔字符串转换为TimeSpan，该字符串格式必须与指定格式一样，并返回是否成功。 TimePare有以下几个实例方法1234567891011121314Add()//将指定TimeSpan添加到实例中CompareTo()//将该实例与指定TimeSpan进行比较，返回-1、0或1Duration()//返回新的TimeSpan值，为当前对象绝对值GetHashCode()//返回该实例的哈希代码GetType()//返回该实例的TypeSubtract()//从实例中减去指定TimeSpaceToString()//将该实例转换为等效字符串 DateTime结构这个鬼东西好多啊，我不想写了，突然想到我可以放图，我太机智了。感觉今天外网流量要爆炸了。 正则表达式这是个好东西，真的，好东西。好好写一写。 基本语法字符匹配用于检查一个字符串是否包含欧中字符串，如[-a-z]与”abc-“匹配，和”123”不匹配。匹配含义如下表所示。用于排除字符的常规用法 [^0-9]匹配除数字以外的所有字符 [^a-z]匹配除小写字母以外的所有字符 [^A-Z]匹配除大写字母以外的所有字符 [^\\\\/\\^]匹配除’\\’、’/‘和’^’以外的所有字符 [^\\”\\’]匹配除双引号和单引号以外的所有字符重复匹配比如一个单词重复出现多次，可以用{}确定次数。语法如下。示例如下12345678910\\a&#123;3&#125;//匹配\\a\\a\\a，不匹配\\a\\a\\a\\d或者\\a\\a&#123;1,3&#125;//匹配\\a、\\a\\a\\a、\\a\\a，不匹配\\a\\a\\a\\a5?//匹配5或0，不匹配非5和0\\S+//匹配一次以上\\S\\W*//匹配0次以上\\W，不匹配非N*\\W 字符定位定位字符所代表的是一个虚的字符，代表一个位置，可以直观认为定位字符所代表的的是某个字符与字符之间的间隙，语法如下所示。 转义匹配转义匹配的工作方式与C#的转义序列相同，如下表所示 Regex类的使用在System.Text.RegularExpression命名空间中提供了包含Regex在内的8个正则表达式类主要说明Regex，常用的三个方法，IsMatch(),Replace(),Split()和Match() IsMatch()对字符串进行正则匹配验证，满足返回true，否则false。例如，首先定义正则表达式字符串在调用方法进行验证输出结果12string regex=@&quot;([0-9]&#123;4&#125;)-([0-9]&#123;1,2&#125;)-([0-9]&#123;1,2&#125;)&quot;;Console.WriteLine(Regex.IsMatch(str,regex)); Replace()使用指定字符串替换原始字符串中满足正则表达式的部分。例如，替换多个空白和空格，统一使用空格。12345string input=&quot;北 京 欢 迎 你&quot;;string pattern=&quot;\\\\s+&quot;;string replacement=&quot; &quot;;Regex rgx=new Regex(pattern);string result=rgx.Replace(input,replacement); Split()用正则表达式拆分字符串，根据匹配的正则表达式把原始字符串匹配的字符拆分保存到数组中。某个字符串用短横线分隔，输出每一项123Regex regex=new Regex(&quot;-&quot;);string[] substrings=regrex.Split(&quot;ouda-dsa-sda-asdsa-as&quot;);//输出substrings即可 Match()获取字符串中第一个与正则表达式匹配的项，返回结果是一个Match()类型。不写了不写了，赶紧传点图搞定得了，这个文章我抄的太厉害了，没有消化多少，不过也没办法，这种全是概念的东西就这样。 线程快收尾快收尾 就这样吧，这个文章真的一点用也没有，浪费了好多时间，下次写GUI设计，要好好学了，不能这样没水分的抄了。over。 OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"C#","slug":"C","permalink":"https://bluerbk.top/tags/C/"},{"name":"dotnet","slug":"dotnet","permalink":"https://bluerbk.top/tags/dotnet/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://bluerbk.top/tags/Microsoft/"}],"keywords":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}]},{"title":"C#基础伪教程（三）","slug":"CSharp-Third-Teaching","date":"2018-03-25T11:48:38.000Z","updated":"2018-03-25T14:29:09.008Z","comments":true,"path":"2018/03/25/CSharp-Third-Teaching/","link":"","permalink":"https://bluerbk.top/2018/03/25/CSharp-Third-Teaching/","excerpt":"","text":"现在说一说关于枚举，很久之前才C语言里面用过一点点，但是没有深入，C#学习之后想真正深入一下，就得好好学习。枚举是一个被命名的整型常数集合，如一周只能为周一到周日等，只有固定的几种取值的时候可以定义为枚举。 枚举所谓枚举是将变量值一一列举出来，变量取值仅限于列举出来的值的范围内。C#的枚举属于值类型，而且所有枚举都派生字System.Enum类，而值类型都继承于System.ValueType类，派生于该类的不一定全是值类型，枚举是唯一的例外。 枚举的好处 枚举使代码更易于维护，有助于确保给变量指定合法的、期望的值。枚举使代码更加清晰，允许用描述性的名称表示整数值，而不用含义模糊的数来表示。 枚举的特点体现 枚举不能继承其他的类，也不能被其他的类继承。枚举类型实现了IComparable接口，可以实现多个接口。枚举类型只能拥有私有构造器。枚举类型中成员的访问修饰符是public static final。枚举类型中成员列表名称是区分大小写的。 声明枚举使用关键字enum进行声明，还需要定义枚举的名称、访问修饰符和类型等。具体用法如下123456[修饰符] enum 枚举类型 [:类型]&#123; 标识符[=整型常数], ... 标识符[=整型常数], 标识符[=整型常数]&#125;; 上述各部分含义如下 枚举类型修饰符为public、private或internal，默认为public。 枚举名称必须符合C#标识符定义规则。 枚举类型可以使byte、short、sbyte、ushort、int、unit、long或ulong，默认为int。 整型常数必须符合枚举类型。如下创建一个四季的枚举类型123456public enum Season:int&#123; Spring=0, Summer=1, Autumn, Winter=2&#125;; 可以指定整型常数，如果都不指定，默认第一个元素为0，后一个元素的值总是第一个元素的值加1，如Autumn和Winter均为2。 使用枚举以一个具体的代码来示例，枚举类型就用上面的Season1234...Season se;se=Season.Spring;... 枚举类型的转换12345678//成员对应的数字Console.WriteLine((Season)Spring);Console.WriteLine((int)Season.Winter);//输出0//输出2//数字对应的成员Console.WriteLine((Season)1);//输出Summer 枚举的相关方法123456Enum.GetName(typeof(Season),1);(Season)Enum.Parse(typeof(Season),&quot;Spring&quot;,true);(Season)Enum.Parse(typeof(Season),3,true);//以下两个方法可用于遍历，如foreach语句里Enum.GetName(typeof(Season));Enum.GetValues(typeof(Season)); Parse()方法有三个参数，第一个数枚举类型，第二个是要转换的字符串，第三个true是忽略大小写。该方法返回的是一个引用，需要强制类型转换。 结构结构和类很相似，都可以表示包含数据成员和函数成员的数据结构，但是结构是一种值类型，不用堆分配。结构派生System.ValueType类，适用于具有值语义的小的数据结构，比如平面世界的点，几何世界的一个边，一个矩形等，都是少量数据成员，不要求使用继承或引用表示，而且他们适合值语义（赋值的时候直接复制值，而不是复制引用）方便地实现。结构和类的区别如下 结构是值类型，而类是引用类型。 结构早栈中分配空间，类在堆中分配空间。 在结构中所有成员默认为public修饰符，类中默认为private。 结构支持构造函数，但无构造函数不能自定义，类可以。 结构不支持析构函数，类支持。 在结构中不对成员进行初始化操作，类可以。 结构派生自System.ValueType，类派生自System.Object。 结构不支持继承，也不能被继承，类可以。 结构可以不用new初始化，类必须要用类初始化。结构和类在使用时有很多区别，因此实际编程时应遵循以下规则使用结构还是类 堆栈空间有限，对于大量的逻辑对象，创建类比创建结构好。 大多数情况下该类型只是一些数据时，结构是最好的选择，否则创建类。 在表现抽象或者多层次的数据时，类是最好的选择。 如果该类型不继承自任何类型时使用结构，否则使用类。 该类型的实例不会被频繁用于集合中时使用结构，否则使用类。声明结构C#中声明一个结构用关键字struct，语法如下：123[修饰符] struct 结构名称 [接口]&#123; 结构体&#125;; 上述语法主要参数含义： 修饰符主要为public、private、internal、protected或new，默认为public。 结构名称必须符合C#标识符定义规则。 接口是可选参数。结构可以实现接口，但是不能从另一个结构或者类继承，而且不能作为一个类的基类。 结构体包括数据成员和成员函数，它们不能使用protected或protected internal修饰符，也不能使用abstract或sealed修饰符。简单示例代码如下：12345678struct Point&#123; public int X&#123;get;set;&#125; public int Y&#123;get;set;&#125;&#125;struct Student&#123; public int ID; public string name;&#125; 结构的使用结构成员分为两类：数据成员和成员函数以及类型。数据成员包括常量和字段。函数成员包括属性、方法、事件、索引器、运算符以及构造函数。具体如下： 常量：表示常量的值。 字段：结构中声明的变量。 属性：用于访问对象或结构特性的成员。 方法：包含一系列语句的代码块，通过这些代码能够实现预先定义的计算或操作。 事件：一种使对象或结构能够提供通知的成员。 索引器：又被称为含参属性，是一种含有参数的属性，提供以索引的方式访问对象。 运算符：通过表达式运算符可以对该结构体的实例进行运算。 构造函数：包括静态构造函数和实例构造函数。静态构造函数用static修饰，实例构造函数不必static。简单代码如下：123456789101112131415161718192021222324252627282930313233343536373839struct Time&#123; public bool off; private int hour,minute,second; public Time(int h,int m,int s)&#123; this.h=h; this.s=s; this.m=m; this.off=false; &#125; public int Hour&#123; get&#123;return this.hour;&#125; set&#123; if (value &gt;= 0&amp;&amp; value &lt;= 23) this.hour=value; &#125; &#125; public int Minute&#123; get&#123;return this.minute;&#125; set&#123; if (value&gt;=0&amp;&amp;value&lt;=59) this.minute=value; &#125; &#125; public int Second&#123; get&#123;return this.second;&#125; set&#123; if (value&gt;=0&amp;&amp;value&lt;=59) this.second=value; &#125; &#125; public void Show()&#123; string s=&quot;&quot;; if (off)&#123; s=this.hoir&gt;12?&quot;PM&quot;:&quot;AM&quot;; this.hour=this.hour&gt;12?this.hour-12:this.hour; &#125; Console.WriteLine(&quot;当前时间是：&#123;0&#125;时&#123;1&#125;分&#123;2&#125;秒&#123;3&#125;&quot;,this.hour,this.minute,this.second,s); &#125;&#125; 以下是简单应用1234567891011121314static void Main(string[] args)&#123; Time t1=new Time(); t1.hour=19; t1.minute=32; t1.second=50; t1.Show(); Time t2=new Time(10,15,58); t2.Show(); Time t3=new Time(23,4,27); t3.off=true; t3.Show();&#125; 接口和类一样，接口也定义了一系列属性、方法和事件。不同的是接口不提供实现，由类去实现，从类中被定义为单独的实体。接口表示一种约定。C#中的接口和雷一样都属于引用类型，用来描述属于类或结构的一组相关功能，即定义了一种协议或者规范和标准。使用借接口注意以下几点： 接口中只能包含属性、方法、事件和索引器，但是都不能够实现。 接口名称通常是以”I”开头的，例如IList，IComparable。 实现一个接口的语法和继承类似，如class Person ： IPerson。 通常都称继承了一个类，实现了一个接口。 如果累已经继承了一个父类，以逗号”,”分隔父类和接口。接口的声明123[修饰符] interface 接口名称&#123; 接口主体&#125;； 上述语法主要参数如下： 接口的修饰符包括private，public，protected，internal和new，默认为public。 接口名称必须符合C#标识符的定义规则。 接口的主体是接口的详细定义，可以包括属性、方法以及事件等。如下为一个简单示例123public interface ISubject&#123; //接口代码&#125; 定义接口成员接口成员可以是方法、属性、索引器或者事件，而不能包括常量、字段、运算符、构造函数、析构函数或类型等，也不能包含任何类的静态成员。 方法12345public interface IProduct&#123; void AddProduct(Product P); void DeleteProduct(Product P); void ModifyProduct(Product P);&#125; 属性1234567int ProductID&#123;get&#125;;string MadeDate&#123;set&#125;;string ProductName&#123;get;set;&#125; 索引器123int this[int index]&#123; //添加一个int类型索引器get;set;&#125; 事件1event EventHandler Expired; 接口的实现简单示例如下：创建一个表示商品基本信息的Product类12345public class Product&#123; public int pid; public string MadeDate; public string ProductName;&#125; 创建ProducrDao类并实现IProduct接口12class ProductDao:IProduct&#123;&#125; 在Product类中声明一个Product类的实例P，并在ProductDao类的构造函数中对P进行初始化12345Product p;public ProductDao(Product p)&#123; this.p=new pRODUCT(); this.p=p;&#125; 字ProductDao类中实现接口中的方法123456789public void AddProduct(Product p)&#123; Console.WriteLie(&quot;添加&quot;);......public Product QueryById(int ProductId)&#123; ConsoleWriteLine(&quot;实现商品编号为&#123;0&#125;的查询功能&quot;,ProductId); Product p=new Product(); return p;&#125; 实现接口中的属性1234567public int ProductId&#123; get&#123;return p.pid;&#125;&#125;public string MadeDate&#123; set&#123; p.MadeDate=value;&#125;&#125;... 在ProductDao类中实现对IProduct接口中定义的索引器进行实现123456789101112public int this[int index]&#123; get&#123; if (indes&lt;0||index&gt;=100) return 0; else return index; &#125; set&#123; if (!(index&lt;0||index&gt;=100)) index=value; &#125;&#125; 在ProductDao中对事件进行实现1234public event EventHandler Expired&#123; add&#123;Expired+=value;&#125; //注册事件 remove &#123;Expired-=value;&#125; //移除事件&#125; 接下来就是进行主函数的编写12345678910static void Main(string[] args)&#123; product p=new p=roduct(); p.pid=123456; p.madeDate&quot;2018-03-25&quot;; p.ProductName=&quot;手套&quot;; ProductDao=new PriductDao(p); Console.WriteLine(&quot;jjj&quot;); pd.ADDProduct(o); ... IComparable程序中常用到对数据进行排序，如结构数组或其他对象数组等。.NET Framework内置了一个通用的比较方法，由值类型或类实现以创建类型的特定比较方法IComparable接口声明如下123public interface IComparable&#123; int CompareTo(Object obj);&#125; 仅提供一个方法，该方法作用是将当前实例与同一类型的另一个对象进行比和奥并返回一个帧数，该整数指示当前实例在排序顺序中的位置是位于另一个对象之前还是之后还是位置相当。 小于零 当前实例小于obj参数 等于零 当前实例等于obj参数 大于零 当前实例大于obj参数对一个课程类Course，包含了趁机和课程名称，进行成绩排序。12345678910111213141516171819202122class Course : IComparable&#123; public string Name; public int Score; public Course(stringname,int score) &#123; Name=name; Score=score; &#125; public int CompareTo(object obj) &#123; if (obj is Course) //obj是否为Course类型 &#123; Course otherCourse=obj as Course; return this.Score-otherCourse.Score; &#125; else &#123; throw new ArgumentException(&quot;当前比较的对象不是Course类型&quot;); &#125; &#125;&#125; 在主函数中进行测试，创建一个集合，添加多个Course类对象，分别输出排序前后的结构，具体代码如下：1234567891011121314151617static void Main(string[] args)&#123; ArrayList list=new ArrayList(); list.Add(new Course(&quot;ASP.NET&quot;,60)); list.Add(new Course(&quot;SQL&quot;,85)); list.Add(new Course(&quot;C#&quot;,73)); list.Add(new Course(&quot;PHP&quot;,90)); Console.WriteLine(&quot;按成绩排序前结果如下：&quot;); for (int i=0;i&lt;list.Count;i++)&#123; Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;,(list[i]as Course).Name,(list[i] as Course).Score); &#125; Console.WriteLine(&quot;按成绩排序后结果如下&quot;); list.Sort(); //调用Course类中CompareTo()方法进行排序 for (int i=0;i&lt;list.Count;i++)&#123; Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;,(list[i]as Course).Name,(list[i] as Course).Score); &#125;&#125; 在调用Sort()方法时会对每个实例调用CompareTo()方法进行比较排序。 IComparer.NET Framework还提供一个IComparer接口进行排序。以上两个接口区别主要有两点： IComparable在需要比较的对象的类中实现，可以比较该对象和另外一个对象。 IComparer在单独的一个类中实现，可以比较任意两个对象。 IComparer接口声明如下1234public interface IComparer&#123; int Compare(object x,object y);&#125; 仅包含一个Compare()方法，比较两个对象并返回一个值，指示一个对象是小于、等于还是大于另一个对象。 小于零 x参数小于y参数 等于零 x参数等于y参数 大于零 x参数大于y参数以下为实现接口的简单示例1234567891011121314public class ComparerName:IComparer&#123; public int Compare(object x,object y) &#123; if (x is Course &amp;&amp;y is Course) &#123; return Comparer.Default.Compare(((Course)x).Name,((Course)y).Name); &#125; else &#123; throw new ArgumentException(&quot;要比较的对象不是Course类型&quot;); &#125; &#125;&#125; 接下来使用代码测试排序结果12345678Console.WriteLine(&quot;排序后的结果&quot;）;IComparer SortByName=new ComparerName();//创建一个按名称排序的实例，以下会调用ComparerName类中的Compare()方法进行排序list.Sort(SortByName);for (int i=0;i&lt;list.Count;i++)&#123; ConsoleWriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;,(list[i] as Course).Name,(list[i] s Course).Score);&#125; 这次就写到这里，突然发现要真的一字不差的写出来，真的太多了，下次真得精简一下了，难怪这么累。 OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"C#","slug":"C","permalink":"https://bluerbk.top/tags/C/"},{"name":"dotnet","slug":"dotnet","permalink":"https://bluerbk.top/tags/dotnet/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://bluerbk.top/tags/Microsoft/"}],"keywords":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}]},{"title":"使用aircrack进行WiFi监听和密码破解以及在Markdown插入图片","slug":"aircrack-and-ali-s-oss","date":"2018-03-23T14:09:12.000Z","updated":"2018-04-06T08:46:09.976Z","comments":true,"path":"2018/03/23/aircrack-and-ali-s-oss/","link":"","permalink":"https://bluerbk.top/2018/03/23/aircrack-and-ali-s-oss/","excerpt":"","text":"先说点题外话，写了几篇文章一直都是纯文字，并不是我觉得简约，而是我不会在MarkdownPad里插入图片。。。本地图片路径没问题，但就是显示不出来，无奈之下我只好进行万能的百度，找到了一个东西叫对象存储oss，鬼知道这是干啥的，反正它可以保存我的图片，这样可以生成一个链接然后我就可以在md里插入图片了。我选择的是阿里云的对象存储服务，在控制台点击开通即可，因为博客等小网站用量不是很多，采取按量计费的措施即可，具体部分价目如下表 如图，有三种计费方式，标准，低频和归档。标准就是标准模式，低频是指访问量较低，当然便宜，但是有最低存储期限，单个文件必须存储一个月能删除，不然会多收费。归档是几乎不用来进行访问，更多情况用来进行文件的备份存储的。推荐使用低频计费方式。oss开通之后，点击此处进入极简图床，这里可以帮助你上传图片到你的oss里，只需要简单的配置即可。因为是按量计费，还是得少弄图，不过也无所谓，也没多少人看我的博客（手动大滑稽）。 好了，进入正题吧，使用aircrack进行无线网络的监听和WiFi密码的破译等功能。这属于无线安全范畴的知识，以前有人稍微的教过一点，在加上我自己百度的一些，写一篇文章稍微总结一下。 这是正文使用的平台以及工具： linux（我用的是kali） aircrack - ng工具 无线网卡 LK-110 USB无线网卡 开始操作先启动kali linux，然后插入网卡，输入命令查看网卡是否正确接入，至于这个和Windows主机装不装驱动有没有关系我就不太了解了1iwconfig 如图，wlan0便是我的网卡网卡正确识别之后，使用如下命令改变网卡模式，使之监听模式12airmon-ng start wlan0 airmon-ng stop wlan0mon 如图所示，改变模式之后网卡的名字也随之而变，wlan0mon即为wlan0的监听模式的名字，之后的网卡名字都要使用这个监听模式的名字。启动监听了之后，监听范围内所有的AP，并显示相关AP信息1airodump-ng wlan0mon bssid为AP的MAC地址，essid为AP的名字，ch为信道，这是常用的参数信息，之后的操作都要用到MAC地址。然后使用如下命令监听具体的AP的信息123airodump-ng --ivs -w 包名 --bssid 目标MAC -c 信道 mon0（接口名称）//下面是我用的命令airodump-ng --ivs -w a --bssid F4:83:CD:C6:29:CE -c 1 wlan0mon 命令里的–ivs表示抓取的文件格式为*.ivs格式，包名表示给抓取的包重命名，但是他会默认加上数字，比如你的命令是…-w a…，那么出来的文件不是a.ivs，而是a-01.ivs。station表示这个AP连接了两个设备，一个是我的手机一个是我的电脑，第二个是我的手机，下面我需要获取握手包，里面有关于密码的一些信息，怎么获取呢？有这么一个命令，aireplay-ng攻击命令，有很多种攻击模式和不同的参数，功能很多，但此处只需要使用一个，使用冲突模式攻击指定MAC设备，使其强制断开连接，因为设备终端会重新自动连接AP，此时便可以抓到握手包，如果抓到握手包会在监听终端的右上角看到提示1aireplay-ng -0 10 –a F4:83:CD:C6:29:CE -c 14:1F:78:30:73:C8 wlan0mon 如果获取到了握手包，如图所指的地方就会出现这个字样提示你获取到指定MAC设备的握手包，接下来就可以进行密码破解了，采用的是暴力破解方法，众所周知，暴力破解关键就是强大的字典，在此我写一个十分简单的字典，其中包含了我的AP密码，以及其他几个干扰，字典格式可以为.lst，.txt等格式不知道可不可以，还没有试过，理论上可以。这是我的字典，作为实验，随便写一点就好了。随后执行命令1aircrack-ng /root/a-01.ivs -w wordlist.lst 参数解释一下，第一个参数是上一步获取握手包时候生成的*.ivs文件，-w参数就是你的字典文件，可以用相对路径也可以用绝对路径，执行之后就是等待，如果你是真的在暴力破解密码的话，可能你会等一段时间，等成功破解出来密码之后，会出现如下的图到此为止，恭喜，成功破解了这个AP的密码，其实看起来还是很有用的是不是呢（再此手动滑稽），当然，前提是你需要有一个强大的字典。无线其实挺好玩的，比如抓包可以进行相应分析啊，像是校园网这种网络，很多都是不加密的，甚至可以把目标的学号密码什么都找出来，是不是很好玩呢？有时间我会学一下关于抓包和分析的相关知识然后再写出来。 OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"无线安全","slug":"无线安全","permalink":"https://bluerbk.top/categories/无线安全/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"kali","slug":"kali","permalink":"https://bluerbk.top/tags/kali/"},{"name":"aircrack-ng","slug":"aircrack-ng","permalink":"https://bluerbk.top/tags/aircrack-ng/"},{"name":"无线安全","slug":"无线安全","permalink":"https://bluerbk.top/tags/无线安全/"}],"keywords":[{"name":"无线安全","slug":"无线安全","permalink":"https://bluerbk.top/categories/无线安全/"}]},{"title":"基于Socket的Java网络通信讲解与实例","slug":"Java-SocketProgramming","date":"2018-03-22T15:55:20.000Z","updated":"2018-03-22T17:06:58.173Z","comments":true,"path":"2018/03/22/Java-SocketProgramming/","link":"","permalink":"https://bluerbk.top/2018/03/22/Java-SocketProgramming/","excerpt":"","text":"在之前学Jva的时候看到了这个Socket编程，觉得网络通信还是很有意思，比如说啊，可以通过Socket进行客户端和服务器端的通信，文字消息啊、文件传输啊之类的。这次说一下关于Socket阻塞式和非阻塞式通信，进行文件传输和字符串的传输。同时，Socket的使用关键主要是对Java中的流的正确使用，主要是用DataInputStream、DataOutputStream、BufferedReader、PrintWriter等流，对文件的操作主要是FileInputStream和FileOutputStream。 阻塞式通信阻塞式通信是最简单的一种通信，通过缓冲区的相关方法（瞎扯）进行输出等操作，但是随之的问题便是，只能是一句一句的传输，比如我给服务器发送一个字符串，如果服务器端不进行回复的话，客户端只能处于等待状态，此时输入任何字符都没有用，但严格地说不是没有用，而是在缓冲区中，并没有显示出来，如果服务器端回复了会发现客户端的终端里有刚才输入的字符串。非阻塞式通信还是比较简单易懂，代码如下：客户端代码如下1234567891011121314151617181920212223242526272829303132333435363738import java.net.*;import java.io.*;public class Socket_Client&#123; @SuppressWarnings(&quot;deprecation&quot;) public static void main(String[] args)&#123; System.out.println(&quot;\\n\\nClient Stsrted&quot;); Date date=new Date(); try&#123; //构造socket连接，端口4700 Socket socket=new Socket(&quot;127.0.0.1&quot;,4700); //系统标准输入设备 BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); //构造socket的输出流，输出给客户端 PrintWriter os=new PrintWriter(socket.getOutputStream()); //构造socket的输入流，获取信息 BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream())); try&#123; Thread.sleep(2000); System.out.println(is.readLine()+&quot;\\n&quot;); &#125;catch(InterruptedException e)&#123;&#125; String readline; readline=br.readLine(); while (!readline.equals(&quot;bye&quot;))&#123; date=new Date(); //将消息输出到socket os.println(readline+&quot;\\t\\t\\t#&quot;+date.toString()); //使服务器端立刻接收到消息 os.flush(); System.out.println(&quot;Server：&quot;+is.readLine()); readline=br.readLine(); &#125; System.out.println(&quot;\\nConnection has closed\\nBYE BYE&quot;); os.close(); is.close(); socket.close(); &#125;catch(IOException e)&#123;System.out.println(&quot;Error&quot;+e);&#125; &#125;&#125; 使用Socket创建一个Socket对象用以进行连接，使用BufferedReader进行标准输入，如从控制台获取字符串或者从服务器端接受字符串信息。构造PrintWriter对象以输出字符串到服务器端。使用（PrintWriter）.println即可输出字符串到服务器端，在输出之后一定要记得调用（PrintWriter）.flush（）函数强制刷新缓冲区，相当于把字符串挤出去了，不然无法正确传输。程序结束之后要记得关闭相应的流，有些流垃圾回收器是不会进行处理的。下面是服务器端的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.net.*;import java.io.*;import java.util.*;public class Socket_Server&#123; @SuppressWarnings(&quot;deprecation&quot;) public static void main(String[] args)&#123; Date date=new Date(); System.out.println(&quot;\\n\\nServer Started&quot;); try&#123; ServerSocket server=null; try&#123; //创建一个serversocket监听4700端口 server=new ServerSocket(4700); System.out.println(&quot;Waiting for connection......\\n&quot;); &#125;catch(Exception e)&#123;System.out.println(&quot;Open Port falied &quot;+e);&#125; Socket socket=null; try&#123; //accept（）阻塞方法，如果有请求产生一个socket对象 socket=server.accept(); System.out.println(&quot;Socket get successfully&quot;+&quot;\\t\\t\\t#&quot;+date.toString()+&quot;\\n\\n&quot;); &#125; catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125; String line; //由socket构造得到输入流，从socket获取输入信息 BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream())); //由socket构造输出信息，从socket输出信息 PrintWriter os=new PrintWriter(socket.getOutputStream()); //标准输入设备获取输入 BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); //获取客户端的消息 os.println(&quot;Socket get successfully...Connection linked\\t#&quot;+date.toString()); os.flush(); System.out.println(&quot;Client：&quot;+is.readLine()+&quot;\\t\\t\\t#&quot;+date.toString()); //获取服务端的信息 line=br.readLine(); while (!line.equals(&quot;bye&quot;))&#123; date=new Date(); //向客户端输出信息 os.println(line+&quot;\\t\\t\\t#&quot;+date.toString()); //刷新输出流，使客户端立刻接收消息 os.flush(); System.out.println(&quot;Client：&quot;+is.readLine()); line=br.readLine(); &#125; System.out.println(&quot;\\nConnection has closed\\nBYE BYE&quot;); //关闭socket输出流 os.close(); //关闭socket输出流 is.close(); //关闭socket和serversocket socket.close(); server.close(); &#125;catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125; &#125;&#125; 有了上面的客户端代码，服务器端应该也就更好理解了。服务器端的Socket是通过SocketServer建立一个对象server，负责监听指定端口是否有一个连接，如有链接，通过server.accept()阻塞式获取一个socket连接对象，进行通信传输。输入输出的相关函数用法同客户端，所以很好记的。同样，在程序结束之后记得关闭相应的流。 非阻塞式通信有了上面说的阻塞式通信的例子，对非阻塞式通信从名字上应该有一点懂了吧，顾名思义就是不会碰到阻塞的情况，也就是不用等待服务器端的回复，我都可以一直想服务器端发送字符串，这就是非阻塞式通信。从思路上来看，我们需要使用到多线程，通过两个线程的运行，分别控制消息的接受和消息的发送，这样不用去等待对方回复。但是非阻塞式带来的问题就是不好判定对方是否结束，一方中断连接的时候只可以中断一个线程，由于另一个线程在等待消息，可能是在一直等待输入也可能是在等待接收消息，即便是使用同步的方法也无法在两个这样的线程里传递信息，导致不能在一方就进行双向切断。代码如下：客户端：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.net.*;import java.io.*;import java.util.*;public class Socket_Client&#123; @SuppressWarnings(&quot;deprecation&quot;) public static void main(String[] args)&#123; System.out.println(&quot;\\n\\nClient Stsrted&quot;); String ip=&quot;127.0.0.1&quot;; Date date=new Date(); try&#123; //构造socket连接，端口4700 Socket socket=new Socket(ip,4700); //系统标准输入设备 BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); //构造socket的输出流，输出给客户端 PrintWriter os=new PrintWriter(socket.getOutputStream()); //构造socket的输入流，获取信息 BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream())); try&#123; Thread.sleep(2000); System.out.println(is.readLine()+&quot;\\n&quot;); &#125;catch(InterruptedException e)&#123;&#125; Client_SendThread send=new Client_SendThread(os); Client_PrintThread print=new Client_PrintThread(is,socket.getInetAddress().toString()); Thread sendthread=new Thread(send); sendthread.start(); Thread printthread=new Thread(print); printthread.start(); printthread.join(); sendthread.join(); System.out.println(&quot;\\nConnection has closed\\nBYE BYE&quot;); os.close(); is.close(); socket.close(); &#125;catch(Exception e)&#123;System.out.println(&quot;Error&quot;+e);&#125; &#125;&#125;class Client_PrintThread implements Runnable&#123; private BufferedReader is; private String ip; public Client_PrintThread(BufferedReader is,String ip)&#123; super(); this.is=is; this.ip=ip; &#125; @Override public void run()&#123; System.out.println(&quot;print thread started&quot;); boolean ifrun=true; String s=new String(); String Server_Name=&quot;Server&quot;; while (ifrun)&#123; try&#123; s=is.readLine(); System.out.println(Server_Name+&quot;\\t&quot;+s); if (s.split(&quot;:&quot;)[3].trim().equals(&quot;bye&quot;))&#123; ifrun=false; &#125; &#125;catch(IOException e)&#123;&#125; &#125; System.out.println(&quot;Sorry The link has been cut(Please input &quot;bye&quot; to end the link)\\tprint thread closed&quot;); &#125;&#125;class Client_SendThread implements Runnable&#123; private PrintWriter os; public Client_SendThread(PrintWriter os)&#123; super(); this.os=os; &#125; @Override public void run()&#123; System.out.println(&quot;send thread started&quot;); String s=new String(); Date date; boolean ifrun=true; BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); while (ifrun)&#123; date=new Date(); try&#123; s=br.readLine(); os.println(&quot;[&quot;+date.toString()+&quot;]: &quot;+s); os.flush(); if (s.equals(&quot;bye&quot;)) ifrun=false; &#125;catch(IOException e)&#123;&#125; &#125; System.out.println(&quot;Sorry The link has been cut\\tsend thread closed&quot;); &#125;&#125; 这里有两个线程Client_SendThread和Client_PrintThread，分别控制消息的发送和接受。也没有太多的难点，主要就是开两个线程即可。服务器端：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import java.net.*;import java.io.*;import java.util.*;public class Socket_Server&#123; @SuppressWarnings(&quot;deprecation&quot;) public static void main(String[] args)&#123; Date date=new Date(); System.out.println(&quot;\\n\\nServer Started&quot;); try&#123; ServerSocket server=null; try&#123; //创建一个serversocket监听4700端口 server=new ServerSocket(4700); System.out.println(&quot;Waiting for connection......\\n&quot;); &#125;catch(Exception e)&#123;System.out.println(&quot;Open Port falied &quot;+e);&#125; Socket socket=null; try&#123; //accept（）阻塞方法，如果有请求产生一个socket对象 socket=server.accept(); System.out.println(&quot;Socket get successfully&quot;+&quot;\\t\\t\\t#&quot;+date.toString()+&quot;\\n\\n&quot;); &#125; catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125; String line; //由socket构造得到输入流，从socket获取输入信息 BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream())); //由socket构造输出信息，从socket输出信息 PrintWriter os=new PrintWriter(socket.getOutputStream()); //标准输入设备获取输入 BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); //获取客户端的消息 os.println(&quot;Socket get successfully...Connection linked\\t#&quot;+date.toString()); os.flush(); Server_SendThread send=new Server_SendThread(os); Server_PrintThread print=new Server_PrintThread(is,socket.getInetAddress().toString()); Thread sendthread=new Thread(send); sendthread.start(); Thread printthread=new Thread(print); printthread.start(); printthread.join(); sendthread.join(); System.out.println(&quot;The MAINTHRED closed\\t\\tMAIN&quot;); System.out.println(&quot;\\nConnection has closed\\nBYE BYE&quot;); //关闭socket输出流 os.close(); //关闭socket输出流 is.close(); //关闭socket和serversocket socket.close(); server.close(); &#125;catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125; &#125;&#125;class Server_PrintThread implements Runnable&#123; private BufferedReader is; private String ip; Date date=new Date(); public Server_PrintThread(BufferedReader is,String ip)&#123; super(); this.is=is; this.ip=ip; &#125; @Override public void run()&#123; System.out.println(&quot;print thread started&quot;); boolean ifrun=true; String s=new String(); String Client_Name=&quot;Client&quot;; while (ifrun)&#123; try&#123; s=is.readLine(); System.out.println(Client_Name+&quot;\\t&quot;+s); if (s.split(&quot;:&quot;)[3].trim().equals(&quot;bye&quot;)) ifrun=false; &#125;catch(IOException e)&#123;&#125; &#125; System.out.println(&quot;Sorry The link has been cut(Please input &quot;bye&quot; to end the link)\\tprint thread closed&quot;); &#125;&#125;class Server_SendThread implements Runnable&#123; MyObj obj=new MyObj(); private PrintWriter os; public Server_SendThread(PrintWriter os)&#123; super(); this.os=os; &#125; @Override public void run()&#123; System.out.println(&quot;send thread started&quot;); String s=new String(); Date date; boolean ifrun=true; BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); while (ifrun)&#123; date=new Date(); try&#123; s=br.readLine(); os.println(&quot;[&quot;+date.toString()+&quot;]: &quot;+s); os.flush(); if (s.equals(&quot;bye&quot;)) ifrun=false; &#125;catch(IOException e)&#123;&#125; &#125; System.out.println(&quot;Sorry The link has been cut\\tsend thread closed&quot;); &#125;&#125; 同样也没有太多好说的。。。下面是两个关于Socket有关的小栗子 关于传输和接收的格式和方式文件，不能像字符串那样直接发送，所幸的是Java中有一个强大的东西叫流，可以把文件转化成字节流，然后通过DataOutputStream将字节流发送出去，服务器端可以通过DataInputStream接受字节流，然后对字节流进行相应的处理，比如转换成字符串、写入某一个文件等等。点击此处查看以下内容原文以下是DataOutputStream的有关方法123456789101112131415161718192021222324252627构造函数：DataOutputStream(OutputStream out);//创建一个将数据写入指定输出流out的数据输出流。字段摘要：int written;//到目前为止写入数据流的字节数。主要方法：void write(byte[] b,int off,int len);//将byte数组off角标开始的len个字节写到OutputStream 输出流对象中。void write(int b);//将指定字节的最低8位写入基础输出流。void writeBoolean(boolean b);//将一个boolean值以1-byte形式写入基本输出流。void writeByte(int v);//将一个byte值以1-byte值形式写入到基本输出流中。void writeBytes(String s);//将字符串按字节顺序写入到基本输出流中。void writeChar(int v);//将一个char值以2-byte形式写入到基本输出流中。先写入高字节。void writeInt(int v);//将一个int值以4-byte值形式写入到输出流中先写高字节。void writeUTF(String str);//以机器无关的的方式用UTF-8修改版将一个字符串写到基本输出流。该方法先用writeShort写入两个字节表示后面的字节数。int size();//返回written的当前值。 以下是有关DataInputStream的一些方法12345678910111213141516171819构造方法：DataInputStream(InputStream in);主要方法：int read(byte[] b);//从输入流中读取一定的字节，存放到缓冲数组b中。返回缓冲区中的总字节数。int read(byte[] buf,int off,int len);//从输入流中一次读入len个字节存放在字节数组中的偏移off个字节及后面位置。String readUTF();//读入一个已使用UTF-8修改版格式编码的字符串String readLine();boolean readBoolean;int readInt();byte readByte();char readChar(); 转换成二进制格式也可以进行传输，使用InputStream和OutputStream进行发送和接受。 简单的客户端和服务器端进行文件传输的例子由于是一个很简单的文件传输，但是使用的方法还是相当实用的，甚至比上面的阻塞式通信还实用（本人觉得），具体代码如下客户端：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.*;import java.net.*;class SendMsg&#123; public SendMsg(String[] args)throws Exception&#123; int Length; File file=new File(args[0]); FileInputStream fis=new FileInputStream(file); System.out.println(&quot;Get File Name Successfully\\t&quot;); System.out.println(file.getName()); DataInputStream in=new DataInputStream(fis); Length=fis.available(); byte[] Byte=new byte[Length]; in.read(Byte); Socket_FileSend(Byte,Length,file.getName()); System.out.println(Length+&quot;\\t&quot;+file.getName()); fis.close(); in.close(); &#125; public void Socket_FileSend(byte[] Byte,int Length,String name)&#123; System.out.println(&quot;Socket is ready to start&quot;); try&#123; Socket socket=new Socket(&quot;127.0.0.1&quot;,4700); DataOutputStream dos=new DataOutputStream(socket.getOutputStream()); dos.writeUTF(name); dos.flush(); dos.writeInt(Length); dos.flush(); dos.write(Byte); dos.flush(); socket.close(); &#125;catch(Exception e)&#123; System.out.println(e); System.exit(1); &#125; System.out.println(&quot;File send successfully&quot;); &#125;&#125;public class Socket_Client&#123; public static void main(String[] args) throws Exception&#123; if (args.length&lt;1)&#123; System.out.println(&quot;Cannot find the file.Please input filename&quot;); System.exit(1); &#125; SendMsg send=new SendMsg(args); &#125;&#125; 在使用的时候记得传入一个正确的文件路径，否则会报错。 服务器端：12345678910111213141516171819202122232425262728293031323334353637383940import java.io.*;import java.net.*;import java.lang.*;class GetMsg&#123; public GetMsg()throws Exception&#123; String name=new String(); int Length; System.out.println(&quot;Waiting for Connection...&quot;); ServerSocket server=new ServerSocket(4700); Socket socket=server.accept(); System.out.println(&quot;Connection get Successfully&quot;); DataInputStream dis=new DataInputStream(socket.getInputStream()); name=dis.readUTF(); Length=dis.readInt(); System.out.println(name+&quot;\\t&quot;+Length); byte[] Byte=new byte[Length]; System.out.println(&quot;Get File successfully&quot;+Byte.length); File file=new File(name); FileOutputStream fos=new FileOutputStream(file); dis.read(Byte); fos.write(Byte); fos.flush(); fos.close(); System.out.println(&quot;write successfullt&quot;); server.close(); socket.close(); dis.close(); &#125;&#125;public class Socket_Server&#123; public static void main(String[] args) throws Exception&#123; GetMsg send=new GetMsg(); &#125;&#125; 一定要有这一步dis.read(Byte);不然Byte里面什么都没有，即便Byte.length也会出来正确的字节数，因为数组初始化了这么多的字节，即便里面没有内容。 基于Socket的CSC模式通信重头戏来了，这才是Socket应该做的事，我们进行通信当然是在客户端之间进行了，毕竟不可能点对点进行，我们需要使用服务器进行中转处理我们希望传输的内容以达到我们的要求。基本思路如下，传输还是采用双线程的非阻塞式，客户端代码变动不大，服务器代码需要修改，在这里我假设是两台客户端进行通信，多个客户端相互通信或者群组通信原理差不多，可以类推。所有对象都需要两个，分别代表两个不同的客户端，如果是多客户端采用多线程建立多个对象即可。重点的部分在这里，需要将接受的客户端1的信息发送给客户端2，接受的客户端2的信息发送给客户端1，这样就实现了信息的交换，建议实际写代码的时候可以画一个草图方便缕清思路，因为流真的有点多，稍微一乱的话就会搞不清了。客户端：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.net.*;import java.io.*;import java.util.*;public class Socket_Client&#123; @SuppressWarnings(&quot;deprecation&quot;) public static void main(String[] args)&#123; System.out.println(&quot;\\n\\nClient Started&quot;); String ip=&quot;204.44.91.156&quot;; Date date=new Date(); try&#123; //构造socket连接，端口4700 Socket socket=new Socket(ip,4700); //系统标准输入设备 BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); //构造socket的输出流，输出给客户端 PrintWriter os=new PrintWriter(socket.getOutputStream()); //构造socket的输入流，获取信息 BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream())); try&#123; Thread.sleep(2000); System.out.println(is.readLine()+&quot;\\n&quot;); &#125;catch(InterruptedException e)&#123;&#125; Client_SendThread send=new Client_SendThread(os); Client_PrintThread print=new Client_PrintThread(is,socket.getInetAddress().toString()); Thread sendthread=new Thread(send); sendthread.start(); Thread printthread=new Thread(print); printthread.start(); printthread.join(); sendthread.join(); System.out.println(&quot;\\nConnection has closed\\nBYE BYE&quot;); os.close(); is.close(); socket.close(); &#125;catch(Exception e)&#123;System.out.println(&quot;Error&quot;+e);&#125; &#125;&#125;class Client_PrintThread implements Runnable&#123; private BufferedReader is; private String ip; public Client_PrintThread(BufferedReader is,String ip)&#123; super(); this.is=is; this.ip=ip; &#125; @Override public void run()&#123; System.out.println(&quot;print thread started&quot;); boolean ifrun=true; String s=new String(); while (ifrun)&#123; try&#123; s=is.readLine(); System.out.println(s); if (s.split(&quot;:&quot;).length&gt;3)&#123; if (s.split(&quot;:&quot;)[3].trim().equals(&quot;bye&quot;))&#123; ifrun=false; &#125; &#125; &#125;catch(IOException e)&#123;&#125; &#125; System.out.println(&quot;Sorry The link has been cut(Please input &apos;bye&apos; to end the link)\\tprint thread closed&quot;); &#125;&#125;class Client_SendThread implements Runnable&#123; private PrintWriter os; public Client_SendThread(PrintWriter os)&#123; super(); this.os=os; &#125; @Override public void run()&#123; System.out.println(&quot;send thread started&quot;); String s=new String(); Date date; boolean ifrun=true; BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); while (ifrun)&#123; date=new Date(); try&#123; s=br.readLine(); os.println(s); os.flush(); if (s.equals(&quot;bye&quot;)) ifrun=false; &#125;catch(IOException e)&#123;&#125; &#125; System.out.println(&quot;Sorry The link has been cut\\tsend thread closed&quot;); &#125;&#125; 服务器端：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import java.net.*;import java.io.*;import java.util.*;//CSC模式经由服务器使得两个客户端之间进行非阻塞式通信public class Socket_Server&#123; @SuppressWarnings(&quot;deprecation&quot;) public static void main(String[] args)&#123; Date date=new Date(); System.out.println(&quot;\\n\\nServer Started&quot;); try&#123; ServerSocket server=null; try&#123; //创建一个serversocket监听4700端口 server=new ServerSocket(4700); System.out.println(&quot;Waiting for connection......\\n&quot;); &#125;catch(Exception e)&#123;System.out.println(&quot;Open Port falied &quot;+e);&#125; Socket socket_1=null,socket_2=null; //第一个客户端链接 try&#123; //accept（）阻塞方法，如果有请求产生一个socket对象 socket_1=server.accept(); System.out.println(&quot;First Socket got successfully&quot;+&quot;\\t\\t\\t#&quot;+date.toString()+&quot;\\n\\n&quot;); &#125; catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125; String line_1; //由socket构造得到输入流，从socket获取输入信息 BufferedReader is_1=new BufferedReader(new InputStreamReader(socket_1.getInputStream())); //由socket构造输出信息，从socket输出信息 PrintWriter os_1=new PrintWriter(socket_1.getOutputStream()); //向第一个客户端发出信号 os_1.println(&quot;You have got the Socket linked.Please waiting for another.\\t#&quot;+date.toString()); os_1.flush(); //第二个客户端链接 try&#123; //accept（）阻塞方法，如果有请求产生一个socket对象 socket_2=server.accept(); System.out.println(&quot;Second Socket got successfully&quot;+&quot;\\t\\t\\t#&quot;+date.toString()+&quot;\\n\\n&quot;); &#125; catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125; String line_2; //由socket构造得到输入流，从socket获取输入信息 BufferedReader is_2=new BufferedReader(new InputStreamReader(socket_2.getInputStream())); //由socket构造输出信息，从socket输出信息 PrintWriter os_2=new PrintWriter(socket_2.getOutputStream()); //向第二个客户端发出信号 os_2.println(&quot;You have got the Socket linked.Please waiting for another.\\t#&quot;+date.toString()); os_2.flush(); //链接成功，发出信号 os_1.println(&quot;Both Socket Linked Successfully&quot;); os_1.flush(); os_2.println(&quot;Both Socket Linked Successfully&quot;); os_2.flush(); System.out.println(&quot;Both linked successfully&quot;); //开始通信 Two_to_One two_to_one=new Two_to_One(is_2,socket_2,os_1); One_to_Two one_to_two=new One_to_Two(is_1,socket_1,os_2); Thread two_to_one_thread=new Thread(two_to_one); two_to_one_thread.start(); Thread one_to_two_thread=new Thread(one_to_two); one_to_two_thread.start(); one_to_two_thread.join(); two_to_one_thread.join(); System.out.println(&quot;The MAINTHRED closed\\t\\tMAIN&quot;); System.out.println(&quot;\\nConnection has closed\\nBYE BYE&quot;); //关闭socket输出流 os_1.close(); os_2.close(); //关闭socket输出流 is_1.close(); is_2.close(); //关闭socket和serversocket socket_1.close(); socket_2.close(); server.close(); &#125;catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125; &#125;&#125;class One_to_Two implements Runnable&#123; private BufferedReader is; private PrintWriter os; private String ip=new String(); Date date=new Date(); public One_to_Two(BufferedReader is_1,Socket socket_1,PrintWriter os_2)&#123; super(); this.os=os_2; this.is=is_1; this.ip=socket_1.getInetAddress().getHostAddress(); &#125; @Override public void run()&#123; System.out.println(&quot;print thread started&quot;); boolean ifrun=true; String s=new String(); String Client_Name_1=ip; while (ifrun)&#123; try&#123; s=is.readLine(); System.out.println(Client_Name_1+&quot;\\t[&quot;+date.toString()+&quot;]: &quot;+s); os.println(Client_Name_1+&quot;\\t[&quot;+date.toString()+&quot;]: &quot;+s); os.flush(); if (s.equals(&quot;bye&quot;)) ifrun=false; &#125;catch(IOException e)&#123;&#125; &#125;// os.println(&quot;Sorry The link has been cut(Please input &apos;bye&apos; to end the link)\\tprint thread closed&quot;);// os.flush(); System.out.println(ip+&quot;has cut his sendthread\\nanother has been cut the printthread&quot;); &#125;&#125;class Two_to_One implements Runnable&#123; private PrintWriter os; private BufferedReader is; Date date=new Date(); String ip=new String(); public Two_to_One(BufferedReader is_2,Socket socket_2,PrintWriter os_1)&#123; super(); this.is=is_2; this.ip=socket_2.getInetAddress().getHostAddress(); this.os=os_1; &#125; @Override public void run()&#123; System.out.println(&quot;send thread started&quot;); String s=new String(); String Client_Name_2=ip; boolean ifrun=true; while (ifrun)&#123; date=new Date(); try&#123; s=is.readLine(); System.out.println(Client_Name_2+&quot;\\t[&quot;+date.toString()+&quot;]: &quot;+s); os.println(Client_Name_2+&quot;\\t[&quot;+date.toString()+&quot;]: &quot;+s); os.flush(); if (s.equals(&quot;bye&quot;)) ifrun=false; &#125;catch(IOException e)&#123;&#125; &#125; System.out.println(&quot;Sorry The link has been cut\\tsend thread closed&quot;); &#125;&#125; 其实难点也没有太多，处理好两个服务器之间输入输出流的关系就可以了，之后就像普通的Socket通信一样即可。今天就到这吧，可能因为今天代码有点多，已经两万个字符了。我现在在进行C#和Java的通信学习，也是通过Socket，Java负责编写服务器端，目前已经可以正常连接了，下面需要的就是进行相应的数据传输任务即可。等有成效了还会写一个文章的。PS.这些代码都是经过测试的，不仅是在我本地测试过，还用同学的电脑进行真实CSC模式的连接，完美成功实现了。 OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"Java","slug":"Java","permalink":"https://bluerbk.top/categories/Java/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"网络编程","slug":"网络编程","permalink":"https://bluerbk.top/tags/网络编程/"},{"name":"Java","slug":"Java","permalink":"https://bluerbk.top/tags/Java/"},{"name":"Socket","slug":"Socket","permalink":"https://bluerbk.top/tags/Socket/"},{"name":"多线程","slug":"多线程","permalink":"https://bluerbk.top/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://bluerbk.top/categories/Java/"}]},{"title":"C#基础伪教程（二）","slug":"CSharp-Second-Teaching","date":"2018-03-18T08:53:09.000Z","updated":"2018-03-18T15:20:05.893Z","comments":true,"path":"2018/03/18/CSharp-Second-Teaching/","link":"","permalink":"https://bluerbk.top/2018/03/18/CSharp-Second-Teaching/","excerpt":"","text":"今天啥都没干，干脆写一点C#吧，就当作是第二个教程了，不多说，进入正题。 类类是用class关键字定义声明，具体框架如下1234public class name&#123;...&#125; public属于访问修饰符，表示访问权限，也可以为protected、internal或者private。C#的类同样支持继承，被继承的类称为基类，继承基类的类称作派生类。派生类可以使用基类的数据、行为的基础上创建自己的数据和行为。类的主题成员有 字段属性方法构造函数析构函数 对象的创建使用new关键字 Class class=new Class(); 静态类和静态成员静态类是不能被实例化的，不能通过new创建对象，只能通过类去直接访问内部成员。一般类中也可以包含静态成员，同样，不能被对象访问，只能由类去访问。12345678public static class car&#123; public static string WriteName()&#123; return &quot;这是静态成员&quot;; &#125;&#125;...car.WriteName(); 静态类有以下几个特点： 静态类的所有成员都是静态成员 静态类不能被实例化 静态类是封装的，不能被继承 静态类不能包含实例构造函数，但是可以定义静态构造函数静态成员有以下几个特点： 含有静态成员的类必须有静态构造函数来初始化 静态字段通常用来记录实例对象的个数或存储该类所有对象的共享值 静态方法可以被重载但不能被重写 局部变量不能被声明为静态变量，如方法中不能声明静态变量 字段和属性字段默认为私有，可以被标记为public、private、protected、internal或protected internal，还可以声明为只读变量，用readonly关键字声明。只读字段只能在初始化或者在构造函数中赋值，静态只读字段类似于常量，但是不能在编译的时候访问，而是在运行的时候访问。字段通常具有以下属性： 字段可以被类的多个方法访问，否则可以在方法内部定义变量，而非定义类的字段 字段的生命周期比类中的单个方法的生命期长 字段可以在声明时赋值，若构造函数包含了字段的初始值，则字段声明值将被覆盖。 字段出四肢不能引用其他实例字段，但是可以是其他类的静态字段如定义公共的静态只读字段num1public static readonly int num; 若字段被标记为私有则只能通过属性来进行访问。属性结合了字段的方法和属性，既可以被当作特殊的方法使用，也可以作为普通字段进行使用。除了访问修饰符，属性还可以具有以下标记 static 静态属性virtual 虚属性sealed 它对派生类不再是虚拟的abstract 在派生类中实现 属性具有get访问器或set访问器或同时拥有，两者可以具有不同的访问修饰符。12345可访问类型 类型 名称&#123; get &#123;&#125; set &#123;&#125;&#125; get和set均可省略。若只有get则为只读属性，若只有set则为只写属性。get和set相当于Java中私有封装的getter和setter。具体用法如下： get访问器与方法类似，它必须返回属性类型的值作为属性的值，当引用属性的时候，若没有为属性赋值，则调用get访问器获取属性的值get访问器必须以return或throw结尾，并且控制权不能离开访问器get访问器除了直接返回字段值，还可以通过计算返回字段值set访问器类似于返回类型为void的方法，它使用属性类型的value隐式参数，当对属性赋值时，用提供心智的参数调用set访问器在set访问器中，对据变量声明使用隐式参数名称value是错误的。 使用属性的时候就像是使用方法一样，简单示例代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//第一个public class count&#123; public int num; public int addnum &#123; get &#123; return num + 10; &#125; set &#123;num = value - 100; &#125; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; count id=new count(); id.num=200; Console.WriteLine(id.addnum); &#125;&#125;//输出为300//第二个public class age&#123; public int agenum; public int num &#123; get &#123; return ageuum; &#125; set &#123; if ((value &gt; 0)&amp;&amp;(value &lt; 200)) &#123; value = agenum; &#125; &#125; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; age ageo=new age(); ageo.num=300; Console.WriteLine(ageo.agenum); ageo.agenum=70; Console.WriteLine(ageo.num); &#125;&#125;//输出结果为070 方法方法在类中声明，具体格式如下12访问级别 是否静态 返回值类型 方法名 （参数类型 参数1，参数类型 参数2...）｛...｝ 关于参数分为按值传递和按引用传递。前者即为传入该变量的副本，对其形式参数进行使用，不影响原变量的值。后者即为引用，如C语言中的&amp;，直接对变量本身进行操作，不使用副本。在参数前加修饰符ref或out即可。 构造函数构造函数是类调用中首先执行的函数，构造函数是方法的一种，与方法唯一不同的时构造函数在创建累的对象时执行的类方法，构造函数要与类名同名，不需要写返回值类型。构造函数可以被标记为public、protected、private、internal或者protected internal。若没有写构造函数，在C#编译器中将自动添加一个默认构造函数，来实例化对象，并将所有成员变量设置为各自类型的默认值。静态类也有构造函数，作用于非静态类构造函数一样，但静态类中构造函数为静态构造函数。构造函数可分为静态构造函数、实例化构造函数和私有化构造函数等。静态构造函数特点如下： 静态构造函数访问修饰符和参数静态构造函数在首次访问类的时候自动调用静态构造函数由编译器控制调用，开发人员无法直接调用静态构造函数私有化构造函数是一种特殊的实例构造函数。它通常用在只包含静态成员的类中，如果类中具有一个或多个私有构造函数而没有公共构造函数，则不允许其他类创建该类的实例。多态允许具有多个含不同参数的构造函数，根据参数的不同选用对应的构造函数。在一个构造函数中可以通过this关键字调用其他的构造函数。 析构函数析构函数是用来释放类资源的，它与一般方法有很大区别，主要有以下几点： 一个类只能有一个析构函数 析构函数不能被继承 析构函数由编译器调节，开发人员无法控制何时调用，由垃圾回收起决定 析构函数没有访问修饰符和参数 析构函数不能定义返回值类型，也没有返回值 程序退出时自动执行析构函数 命名的时候在名字前面加’~’以和构造函数区分开通过调用Collect强制进行资源释放，但是可能会导致程序性错误。通过来自IDisposable接口的Dispose（）可以显式地释放一些资源，为对象执行必要的清理。虽然会提高性能但垃圾回收期还是会调用析构函数对对象进行彻底清理。 类的高级应用封装对类本身，内部成员属性及方法确定是否可被访问等，是否该被隐藏。密封类，不可被继承，通常用来限制扩展性。public sealed class D{…}除此之外与其他类区别不大，可以实例，可以私有，可以共有等。 继承C#中，所有类都是直接或间接地继承Object类。类可以被连环继承。继承如下12class News&#123;...&#125;class SportsNews:News&#123;...&#125; 虚方法又被称为虚函数，是一种可以被派生类实现、重载或冲写的方法，虚函数同选择语句一样有执行条件，根据不同情况实现。一般方法在编译时就静态地编译到执行文件中，其相对地址在程序运行期间是不变的。但是虚函数在编译期间不能被静态编译，它相对地址是不变的。虚方法根据运行时期对象实例来动态判断要调用的函数，其中声明时定义的类交声明类，执行时实例化的类叫实例类。虚方法有以下特点，如下所示： 虚方法通过virtual关键字实现 虚方法通过override关键字在派生类中实现 虚方法前不允许有static、abstract或override修饰符 虚方法不能是私有的，因此不能使用private修饰符 虚函数执行过程如下所示 当调用一个对象的函数时，系统会直接去检查这个函数声明所在的类，即声明类，查看函数是否为虚函数 若不是虚函数，那么直接执行该函数。但如果是虚函数，那么程序不会立刻执行该函数，而是检查对象的实例类，即继承函数声明的类 在这个实例类，程序将检查这个实例类的定义中是否包含实现该虚函数或者重写虚函数的方法 如果有，执行实例类中实现的虚函数的方法。如果没有，系统就会不停地往上找实例类的父类，并对父类重复刚才在实例类里的检查，直到找到第一个重载该虚函数的父类为止，然后执行该父类里冲在后的方法 抽象类抽象类是一种仅用于继承的类。定义一个抽象类的目的主要是为派生类提供可共享的基类成员的公共生命。抽象类对象的抽象成员只有声明部分，没有实现部分。抽象类中的成员实现完全由继承抽象类的派生了来实现。123public abstract class A&#123; public abstract int B();&#125; 抽象类的继承必须实现对抽象类中所有未实现的成员，包括属性和方法。抽象类中抽象成员的实现和虚函数的实现一样，在方法名前用override关键字。 多态类的方法有三种多态形式 定义同名但参数列表不同的方法，被称为方法的重载定义同名且参数列表也相同的方法，并且父类中的方法用abstract/virtual进行修饰，成为方法的覆盖。子类中的同名方法也用override进行修饰，如虚方法和抽象类的覆盖定义相同且参数列表也相同的方法，其父类中的方法没有用abstract/virtual进行修饰，称为方向的隐藏。 方法的重载 方法名必须相同。 返回值可以相同也可以不同，但参数列表不能相同，因为编译器首先根据方法名选择方法，再根据参数列表在众多重载函数中找到合适的。 匹配函数时，编译器将不区分类型引用和类型本身，也不区分const和非const变量。 方法的重写有两种形式，覆盖（只能重写被abstract和virtual关键字修饰的方法，在中写的时候需要关键字override）和隐藏（直接使用new关键字重写基类中的一般方法）。重写时针对方法名相同，擦书列表也相同的方法的多态，通常时在子类中重写基类的方法。重写有以下几个特点 静态方法、密封方法和非虚方法不能被覆盖。 非虚方法可以被隐藏，但静态方法和密封方法不能被隐藏。 重写方法和已重写了的基方法具有相同的返回类型。 重写声明和已重写了的基方法具有相同的声明可访问性。重写声明不能更改所对应的虚方法的可访问性。如果已重写的基方法时protected internal，并且生命它的程序集不是包含重写方法的程序集，则重写方法声明的可访问性必须是protected。 关于后面的几个概念的举例，我懒得写了，需要的时候上网查一下就好了（估计一般也用不太上），就这样 OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"C#","slug":"C","permalink":"https://bluerbk.top/tags/C/"},{"name":"dotnet","slug":"dotnet","permalink":"https://bluerbk.top/tags/dotnet/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://bluerbk.top/tags/Microsoft/"}],"keywords":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}]},{"title":"C#基础伪教程（一）","slug":"C-First-Teaching","date":"2018-03-17T15:56:30.000Z","updated":"2018-03-17T16:13:04.653Z","comments":true,"path":"2018/03/17/C-First-Teaching/","link":"","permalink":"https://bluerbk.top/2018/03/17/C-First-Teaching/","excerpt":"","text":"由于之前学过Java的相关知识，但是由于Java在桌面程序表现的无力，决定选择新的语言，在QT和C#中还是选择了C#，不瞎扯了，我也不会扯，简单粗暴一点，C#语法和Java也很类似。老规矩，我写的教程一向都是伪教程，指不定哪天我都看不懂的那种。 配置环境我采用的是VSCode工具，虽然我也有VS2013，但是它的体积真的很庞大，写点小代码不太划算，还相当占内存。于是我采用VSCode。首先得添加C#插件，点击此处下载.NET Core SDK随后安装，成功后重启VSCode打开cmd控制台，任意进入一个路径，执行命令 dotnet new console dotnet run 第一个是在当前目录下创建C#控制台程序，第二个命令是运行程序，默认为输出”HelloWorld！“。随后在VSCode中打开对应目录下的.cs文件，进行编写，编译执行即可 初识下面一段C#的代码 using System; namespace C_ { class Program { static void Main(string[] args) { Console.Write(&quot;Hello,&quot;); Console.WriteLine(&quot;World&quot;); } } } 由上可见，C#代码包含命名空间，类名和函数名。与其他语言的区别有这些，主函数名为Main，而不是main，类Console在System命名空间中，调用Console类中的Write()和WriteLine()方法向控制台进行输出。Ps.第一个末尾不带换行，第二个自带换行。一个简单的C#程序就编写成功了。 装箱与拆箱如下代码示例装箱123int val=100;object obj=val;Console.WriteLine(&quot;对象的值为=&#123;0&#125;&quot;,obj); object为任意类型，使用一个非泛型容器，保证其通用性。拆箱示例如下1234int val=100;object obj=val;int num=(int)obj;Console.WrtieLine(&quot;num=&#123;0&#125;&quot;,num); 可以转换成原本属于的类型，也可以强制转换到任意可以相容的容易，所以必须显式强制类型转换。 循环控制语句像for(;;)、while()、do … while ();、if、switch等几乎通用，便不多赘述。在此写一个C#新见的一种循环，和用过的迭代器很像。foreach (变量生命 in 数组名或集合类），代码如下。12345int[] num=new int [5]&#123;1,2,3,4,5&#125;;foreach (int i in num)&#123; Console.Write(i);&#125; 输出为：12345 跳转语句，例如goto，continue等，也和其他语言区别不大。 数组按照Java的方式，如获得一个int数组12int[] num=new int[3]&#123;1,2,3&#125;;int[] num=&#123;1,2,3&#125;; 可以通过这样进行数组的初始化赋值。二维数组，如下例12345int[,] num=new int[3,3]&#123;...&#125;;int[,] num=&#123; &#123;3,3,3&#125;, &#123;2,2,2&#125; &#125;; 多维数组同二维数组，如[,]变为[,,]即可。 交错数组即不规则数组如如下定义1234int[][] inter=new int[3][];inter[0]=new int[4]&#123;1,2,3,4&#125;;inter[1]=new int[3]&#123;1,2,3&#125;;inter[2]=new int[5]&#123;1,2,3,4,5&#125;; 即inter数组内容为下1231 2 3 41 2 31 2 3 4 5 上面说的数组都是静态数组，在System.Array类中针对静态数组提供了一些操作的属性及方法1234567891011121314151617181920212223242526Length //数组长度，为32位整数LongLength //数组长度，为64位整数Rank //数组的秩，即维度IsReadOnly //数组是否可读IsFixedSize //数组大小是否固定IsSynchronized //是否同步访问数组SyncRoot //获取同步访问数组的对象GetValue() //获取指定元素的值SetValue() //设置指定元素的值Clear（） //清除数组的所有元素IndexOf() //获取匹配的第一个元素的索引LaseIndexOf() //获取匹配的最后一个元素的索引Sort() //对一维数组排序Reverse() //反转一维数组的元素GetLength() //获取指定唯独数组的元素数量，32位整数GetLongLength //获取指定维度的数组的元素数量，64位整数FindIndex() //搜索指定元素，并获取第一个匹配元素的索引FindLastIndex() //搜索指定元素，并获取最后一个匹配元素的索引Copy() //复制一个数组的部分元素到另一个数组CopyTo() //将一维数组中的所有元素复制到另一个一维数组中Clone() //复制数组ConstrainedCopy() //指定开始位置，并复制一系列元素到另一个数组BinarySearch() //二进制搜索算法在一维的排序数组中搜索指定元素GetLowerBound() //获取数组中指定维度的下限GetUpperBound() //获取数组中指定维度的上限 动态数组动态数组能够在程序的执行中改变数组的长度，可以增加、释放元素所占的空间，又被称为可变数组。这里主要说由System.ArrayList实现得动态数组。需要导入命名空间1using System.Collections; 创建动态数组对象1ArrayList list=new ArrayList(); ArrayList类的属性及方法如下1234567891011121314151617181920212223242526272829303132333435363738Capacity //数组容量Count //数组元素的数量IsFixedSize //数组大小是否固定IsReadOnly //数组是否为只读IsSynchronized //是否同步访问数组SyncRoot //获取同步访问数组的对象Adapter() //为指定的IList创建ArrayList包装Add() //将对象添加到ArrayList的尾部AddRange() //将ICollection的元素添加到ArrayList的尾部BinarySearch() //使用对分检索算法在已排序的ArrayList或它的一部分查找特定元素Clear() //移除所有元素Clone() //创建ArrayList的浅表副本Contains //确定某元素是否在ArrayList中CopyTo() //将ArrayList或它的一部分复制到一维数组中Equals() //确定两个Object实例是否相等FixedSize() //返回具有固定大小的列表包装，其中的元素允许修改，但不允许添加或移除GetEnumerator() //返回循环访问ArrayList的枚举数GetHashCode() //用于特定类型的哈希函数，GetHshCode适合在哈希算法和数据结构（哈希表等）中使用GetRange() //返回ArrayList，它表示源ArrayList中元素的子集GetType() //获取当前实例的TypeIndexOf() //返回ArrayList或它的一部分中某个值的第一个匹配项的从零开始的索引Insert() //将元素插入ArrayList指定的索引处InsertRange() //将集合中的某个元素插入ArrayList的指定索引处LastIndexOf() //返回ArrayList或它的一部分中某个值的最后一个匹配项的从零开始的索引ReadOnly() //返回只读的列表包装ReferenceEquals() //确定指定的Object实例是否是相同的实例Remove() //从ArrayList移除特定对象的第一个匹配项RemoveAt() //移除ArrayList的指定索引处的元素RemoveRange() //从ArrayList中移除一定范围的元素Repeat() //返回ArrayList，它元素是指定值的副本Reverse() //将ArrayList或它的一部分元素顺序反转SetRange() //将集合中的元素复制到ArrayList中的一定范围的元素上Sort() //堆ArrayList或它的一部分的元素进行排序Synchronized() //返回同步的（线程安全）列表包装ToArray() //将ArrayList的元素复制到新的数组中ToString() //返回当前Object的StringTrimTpSize() //将容量设置为ArrayList中元素的实际数目 动态数组的应用添加数组元素123ArrayList list=new ArrayList();list.Add(1);list.insert(3,0); 由于ArrayList中元素的类型位Object，若要使用foreach语句则为1234foreach (object obj in list)&#123; ...&#125; 删除数组元素123list.Remove(2);list.RemoveAt(1);list.RemoveRange(2,5); 打这么多名字有点累，可能会出错，但是报错应该还是很友好的，百度一下就知道该怎么用了。 OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://bluerbk.top/tags/编程/"},{"name":"C#","slug":"C","permalink":"https://bluerbk.top/tags/C/"},{"name":"dotnet","slug":"dotnet","permalink":"https://bluerbk.top/tags/dotnet/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://bluerbk.top/tags/Microsoft/"}],"keywords":[{"name":"C#","slug":"C","permalink":"https://bluerbk.top/categories/C/"}]},{"title":"使用HEXO+GITHUB搭建自己的博客","slug":"hexo_use","date":"2018-03-15T15:47:44.000Z","updated":"2018-03-17T15:53:01.433Z","comments":true,"path":"2018/03/15/hexo_use/","link":"","permalink":"https://bluerbk.top/2018/03/15/hexo_use/","excerpt":"","text":"博客这个东西很多网站都有，什么博客园、CSDN、简书之类的。上周还在考虑在网站上写博客，因为我一直都是自己在本地写word或者txt来记录的。突发奇想自己搭一个博客来写，又高大上还记录了还练手了。说做就做，用了两天时间差不多把基本功能实现了。 使用的工具和环境 Windows7 x64 node.js v8.1 Git 2.16.2 MarkdownPad 2 本文主要说一下博客的搭建，hexo和github联系起来，初步发布文章，修改主题，还会说一些存在的坑。（随缘配图）点击此处查看Markdown语法说明 环境的搭建node.js的安装运行node.js安装包，一路next，完成安装，退出。随后打开控制台界面（ctrl-R，输入cmd回车）运行如下命令 12node -vnpm -v 如果依次出现相对应的版本号，则表示安装成功。 Git的安装和配置运行下载的Git安装包，进入Git的安装当到了Git PATH的步骤时，选择“Use Git from the Windows Command Prompt“这个选项，这是为了将Git添加到系统环境变量里，不用再单独打开git bash运行命令了，cmd即可运行。安装成功后，执行如下命令，若安装成功则会出现Git的版本号1git -version github账号的注册和配置点击此处或打开链接https://github.com/，进行账号注册之后进入注册时填的邮箱，确认账号，不然无法成功。注册成功后，点击右上角的头像，点击 New repository，在Repository name下填写yourname.github.io，即你的github page网站的名字（比如我的是 RBK.github.io)创建成功后，代码库的右上角点击 Setting，向下找Github Page，选择master然后配置主题什么的，之后直接登录你的网站即可看到你的github page。如登陆 blueprok.github.io/RBK.github.io 就是我的主页。在Setting页面的最右下也有写你的网站地址。 HEXO的安装和配置最关键的地方来了，我在搭建的时候就在这折腾了一天。后面会写碰到的问题。关于安装hexo好像很有争议，在此我写一个我用的方法：在一个位置新建一个文件夹，最好是某个盘的根目录吧，比如我的位置时 D：\\hexo，然后运行以下命令，Hexo就安装成功了。可以通过查看版本判断是否安装成功。12npm install hexo-cli -ghexo -v 随后进行创建站点。以此执行以下命令123hexo init [new empty folder]cd [new empty folder]npm install 切记一定要是一个空的文件夹不然会报错，之后的所有步骤都要在[new empty folder]这个目录下执行命令还有要注意node.js版本，最开始我就因为node.js版本太低，导致安装hexo失败，因为npm安装的hexo是最新的，node版本也需要更新。执行完命令后执行以下命令，来生成静态页面hexo g或者hexo generate 执行hexo s或者hexo server来开启本地web服务,会提示INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.在浏览器中输入http://localhost:4000/即可看到网页了。 将github page和hexo联系起来执行命令来设置Git账户 12git config --global user.name &quot;BluePROK&quot;git config --global user.email &quot;568406972@qq.com&quot; 生成密钥（登录时需要，执行命令后按三次回车即可)ssh-keygen -t rsa -C &quot;568406972@qq.com&quot;如果提示找不到命令，说明ssh-keygen没有配置环境变量，切换路径到Git\\usr\\bin即可运行ssh-keygen。在Users文件夹里搜索密钥文件***.pub，把它打开，复制里面的内容。打开github的账户Setting，设置SSH安全，标题随便写，把pub内容复制出来完成即可，不然后面会出现无法提交网页到github的情况。在根目录的_config.yml里找到Deploy，修改信息 deploy: type: git repo: git@github.com:BluePROK/RBK.github.io.git branch: master这样就配置完成了 新建博客，执行命令hexo new post &quot;article title&quot; 会在hexo的根目录source_post里看到artitle title.md，这就是发布的文章，语法为Markdown。执行命令发布文章，每次修改都要这样hexo d -g或者 12hexo ghexo d 到目前为止hexo博客搭建完成，访问 blueprok.github.io/RBK.github.io即可看到我的网页。 PS.可能需要一个扩展，命令如下npm install hexo-deployer-git --save 在此列出借鉴的两个文章 12http://blog.csdn.net/gdutxiaoxu/article/details/53576018https://www.cnblogs.com/blogjun/articles/8289977.html 主题的设置这是HEXO的主页：https://hexo.io/，上面有关于hexo的安装、命令、使用、主题等各种内容。我在这个网站上找的一个主题BlueLake，巧了，正好也是Blue，地址是这个http://chaoo.oschina.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.html这是完整的教程，可以跟着做，我就不一一写出来了。更换主题的时候也有一个小问题，hexo s本地网站主题更换了，但是更新github主题却无法显示出来。这是第二个难题，经过多方查找，需要修改以下配置文件，根_config.yml里的URL属性修改一下，我是这样修改的12url: https://blueprok.github.io/RBK.github.io/root: /RBK.github.io url的属性即为github page网站的地址，root属性为github page仓库项目的名字。然后再hexo d -g就可以成功修改github page的主题了。 域名的绑定解析购买了域名之后，供应商都应该提供解析服务，我用的是阿里云，以这个为例。 在阿里云控制台，设置主机记录www，记录类型为A，记录值是IP192.30.252.153。其中192.30.252.153是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Github Pages。 在阿里云控制台，设置主机记录www，记录类型为A，记录值是IP192.30.252.154。同上。 在阿里云控制台，设置主机记录@，记录类型为CNAME，记录值是bluerbk.github.io.。表示将http://bluerbk.top这个主域名映射bluerbk.github.io。在这里千万不要忘记记录值中.io后面还有一个点.！ 解析设置完成之后，在本地hexo\\source新建一个文件，名字为CNAME，不要后缀，内容为域名即可（即bluerbk.top)。因为如果在github上建立文件的话下次上传的时候这个文件就被覆盖了，所以添加到本地文件，以便每次都可以保证上传，不丢失。但是此时需要修改一下根_config.yml的配置信息，即上文所说的URL信息，修改为如下，否则主题又将不能应用。12url: https://bluerbk.top/root: / OK,THANKS FOR READING.BYE BYE~","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://bluerbk.top/categories/Hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://bluerbk.top/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"https://bluerbk.top/tags/hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://bluerbk.top/categories/Hexo/"}]},{"title":"","slug":"article-title","date":"2018-03-14T15:29:26.697Z","updated":"2018-03-23T11:42:04.482Z","comments":true,"path":"2018/03/14/article-title/","link":"","permalink":"https://bluerbk.top/2018/03/14/article-title/","excerpt":"","text":"Welcome to MarkdownPad 2MarkdownPad is a full-featured Markdown editor for Windows. Built exclusively for MarkdownEnjoy first-class Markdown support with easy access to Markdown syntax and convenient keyboard shortcuts. Give them a try: Bold (Ctrl+B) and Italic (Ctrl+I) Quotes (Ctrl+Q) Code blocks (Ctrl+K) Headings 1, 2, 3 (Ctrl+1, Ctrl+2, Ctrl+3) Lists (Ctrl+U and Ctrl+Shift+O) See your changes instantly with LivePreviewDon’t guess if your hyperlink syntax is correct; LivePreview will show you exactly what your document looks like every time you press a key. Make it your ownFonts, color schemes, layouts and stylesheets are all 100% customizable so you can turn MarkdownPad into your perfect editor. A robust editor for advanced Markdown usersMarkdownPad supports multiple Markdown processing engines, including standard Markdown, Markdown Extra (with Table support) and GitHub Flavored Markdown. With a tabbed document interface, PDF export, a built-in image uploader, session management, spell check, auto-save, syntax highlighting and a built-in CSS management interface, there’s no limit to what you can do with MarkdownPad.","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2018-03-14T15:06:10.005Z","updated":"2018-03-14T15:06:10.005Z","comments":true,"path":"2018/03/14/hello-world/","link":"","permalink":"https://bluerbk.top/2018/03/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}