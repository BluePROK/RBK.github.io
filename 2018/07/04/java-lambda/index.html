<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这是我的博客在github的镜像。"><meta name="keywords" content="C#,闲谈,Java,C语言,Python,Hexo,前端,html,css,js"><title>匿名内部类和lambda表达式 | 蓝色的博客</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/RBK.github.io/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/RBK.github.io/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/RBK.github.io/favicon.ico"><link rel="bookmark" href="/RBK.github.io/favicon.ico"><link rel="apple-touch-icon" href="/RBK.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/RBK.github.io/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/RBK.github.io/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">匿名内部类和lambda表达式</h1><a id="logo" href="/RBK.github.io/.">蓝色的博客</a><p class="description">github</p></div><div id="nav-menu"><a href="/RBK.github.io/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/RBK.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/RBK.github.io/about/"><i class="fa fa-user"> 关于</i></a><a href="/RBK.github.io/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">匿名内部类和lambda表达式</h1><div class="post-meta"><a href="/RBK.github.io/2018/07/04/java-lambda/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2018/07/04/java-lambda/"></i>留言,<i id="changyan_parti_unit" data-xid="2018/07/04/java-lambda/"></i>参与</a><p><span class="date">Jul 04, 2018</span><span><a href="/RBK.github.io/categories/内部类/" class="category">内部类</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>今天很烦，我想学点东西冷静一下。就来说一说这个匿名内部类，用Java做例子，后面插一点c#，如果区别大了或者有时间了再说一下其他的语言具体写法。主要这个东西我之前也知道了很久，一直没有认真去看过，这次就来看看吧，今天的代码量相对很多。</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p><s>这里就说匿名内部类，关于其他内部类老规矩，以后有空了再说</s></p>
<h3 id="匿名内部类的使用"><a href="#匿名内部类的使用" class="headerlink" title="匿名内部类的使用"></a>匿名内部类的使用</h3><p>好像很多地方都不说这具体是个什么东西，都是直接上代码说话。<br>顾名思义，是没有名字的内部类，举个栗子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new View.OnClickListener()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这就是一个典型的常用的内部类，在对按钮等进行事件监听的时候会用到这个，但是明显一看很容易发现这是一个接口，对接口进行new是错误的。<br>下面来还原一个完整的匿名内部类应该就很清楚了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">abstract class Person &#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Person &#123;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;eat something&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Child();</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person是一个抽象类，Child继承这个类成为一个子类，main函数里实例化这个类，其中我们需要在匿名内部类中隐藏Child这个类，如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">abstract class Person &#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Person() &#123;</span><br><span class="line">            public void eat() &#123;</span><br><span class="line">                System.out.println(&quot;eat something&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，这样相当于在实例化的时候直接重写了Child这个类，这就是匿名内部类。</p>
<hr>
<p>匿名内部类没有名字，创建格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 父类构造器（参数列表）|实现接口（）  </span><br><span class="line">    &#123;  </span><br><span class="line">     //匿名内部类的类体部分  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>必须继承一个父类或者实现一个接口，没有class关键字，直接使用new生成一个对象的引用。再如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Bird &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public abstract int fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    </span><br><span class="line">    public void test(Bird bird)&#123;</span><br><span class="line">        System.out.println(bird.getName() + &quot;能够飞 &quot; + bird.fly() + &quot;米&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        test.test(new Bird() &#123;</span><br><span class="line">            </span><br><span class="line">            public int fly() &#123;</span><br><span class="line">                return 10000;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            public String getName() &#123;</span><br><span class="line">                return &quot;大雁&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------</span><br><span class="line">Output：</span><br><span class="line">大雁能够飞 10000米</span><br></pre></td></tr></table></figure></p>
<p>test方法接收一个Bird类型参数，但是我们都知道一个抽象类是不能进行实例化的，也就是直接new，所以我们必须要有一个实现类才可以进行new操作，但是由于它是一个抽象类，所以通过匿名内部类创建一个Bird实例。又因为匿名内部类不能是抽象类，所以我们必须要实现抽象父类或者接口里的所有抽象方法才行。</p>
<h3 id="匿名内部类的注意事项"><a href="#匿名内部类的注意事项" class="headerlink" title="匿名内部类的注意事项"></a>匿名内部类的注意事项</h3><ol>
<li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</li>
<li>匿名内部类中是不能定义构造函数的。</li>
<li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li>
<li>匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li>
</ol>
<h3 id="匿名内部类的初始化"><a href="#匿名内部类的初始化" class="headerlink" title="匿名内部类的初始化"></a>匿名内部类的初始化</h3><p>它没有构造函数，name怎么进行相应初始化呢？<br>使用构造代码块进行初始化，可以达到一个构造器的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class OutClass &#123;</span><br><span class="line">    public InnerClass getInnerClass(final int age,final String name)&#123;</span><br><span class="line">        return new InnerClass() &#123;</span><br><span class="line">            int age_ ;</span><br><span class="line">            String name_;</span><br><span class="line">            //构造代码块完成初始化工作</span><br><span class="line">            &#123;</span><br><span class="line">                if(0 &lt; age &amp;&amp; age &lt; 200)&#123;</span><br><span class="line">                    age_ = age;</span><br><span class="line">                    name_ = name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            public String getName() &#123;</span><br><span class="line">                return name_;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            public int getAge() &#123;</span><br><span class="line">                return age_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OutClass out = new OutClass();</span><br><span class="line">        </span><br><span class="line">        InnerClass inner_1 = out.getInnerClass(201, &quot;chenssy&quot;);</span><br><span class="line">        System.out.println(inner_1.getName());</span><br><span class="line">        </span><br><span class="line">        InnerClass inner_2 = out.getInnerClass(23, &quot;chenssy&quot;);</span><br><span class="line">        System.out.println(inner_2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="既然说到了这里，顺便说一说代码块"><a href="#既然说到了这里，顺便说一说代码块" class="headerlink" title="既然说到了这里，顺便说一说代码块"></a>既然说到了这里，顺便说一说代码块</h3><p>代码块就是用{}包起来的代码，进行封装，形成一个独立的数据体，用于实现特定的算法。代码块不能单独运行，必须要有一个运行主体。<br>Java的代码块主要分为四种</p>
<ol>
<li><p>普通代码块<br>普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;普通代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态代码块<br>想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步代码块<br>使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。</p>
</li>
<li>构造代码块<br>在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 构造代码</span><br><span class="line">     */</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;执行构造代码块...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 无参构造函数</span><br><span class="line">     */</span><br><span class="line">    public Test()&#123;</span><br><span class="line">        System.out.println(&quot;执行无参构造函数...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 有参构造函数</span><br><span class="line">     * @param id  id</span><br><span class="line">     */</span><br><span class="line">    public Test(String id)&#123;</span><br><span class="line">        System.out.println(&quot;执行有参构造函数...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 无参构造函数</span><br><span class="line">     */</span><br><span class="line">    public Test()&#123;</span><br><span class="line">        System.out.println(&quot;执行构造代码块...&quot;);</span><br><span class="line">        System.out.println(&quot;执行无参构造函数...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 有参构造函数</span><br><span class="line">     * @param id  id</span><br><span class="line">     */</span><br><span class="line">    public Test(String id)&#123;</span><br><span class="line">        System.out.println(&quot;执行构造代码块...&quot;);</span><br><span class="line">        System.out.println(&quot;执行有参构造函数...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        new Test();</span><br><span class="line">        System.out.println(&quot;----------------&quot;);</span><br><span class="line">        new Test(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">------------</span><br><span class="line">Output:</span><br><span class="line">执行构造代码块...</span><br><span class="line">执行无参构造函数...</span><br><span class="line">----------------</span><br><span class="line">执行构造代码块...</span><br><span class="line">执行有参构造函数...</span><br></pre></td></tr></table></figure></p>
<p>从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。<br>各个代码块执行顺序为：静态代码块 &gt; 构造代码块 &gt; 构造函数。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><strong>本部分转自：</strong><a href="http://www.cnblogs.com/chenssy/p/3413229.html" target="_blank" rel="noopener">点击这里</a><br><strong>作者：</strong><a href="http://www.cnblogs.com/chenssy/" target="_blank" rel="noopener">chenssy</a><br><strong>出处：</strong><a href="http://www.cnblogs.com/chenssy/" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/</a><br>匿名内部类就说到这吧，下面是我想看的lambda表达式。</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><h3 id="先划重点，写到这里我才意识到lambda是Java8的新特性，我抱着我的Java6不说话"><a href="#先划重点，写到这里我才意识到lambda是Java8的新特性，我抱着我的Java6不说话" class="headerlink" title="先划重点，写到这里我才意识到lambda是Java8的新特性，我抱着我的Java6不说话"></a>先划重点，写到这里我才意识到lambda是Java8的新特性，我抱着我的Java6不说话</h3><p>“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。<br>Java8发布已经有一段时间了，这次发布的改动比较大，很多人将这次改动与Java5的升级相提并论。Java8其中一个很重要的新特性就是lambda表达式，允许我们将行为传到函数中。想想看，在Java8之前我们想要将行为传入函数，仅有的选择就是匿名内部类。Java8发布以后，lambda表达式将大量替代匿名内部类的使用，简化代码的同时，更突出了原来匿名内部类中最重要的那部分包含真正逻辑的代码。<br>下面看看一些常用写法</p>
<hr>
<h3 id="替代匿名内部类"><a href="#替代匿名内部类" class="headerlink" title="替代匿名内部类"></a>替代匿名内部类</h3><p>毫无疑问，lambda表达式用得最多的场合就是替代匿名内部类，而实现Runnable接口是匿名内部类的经典例子。lambda表达式的功能相当强大，用()-&gt;就可以代替整个匿名内部类！<br>这是我们上面刚说的匿名内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void oldRunable() &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;The old runable now is using!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们看看怎么用表达式写出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void runable() &#123;</span><br><span class="line">        new Thread(() -&gt; System.out.println(&quot;It&apos;s a lambda function!&quot;)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">The old runable now is using!</span><br><span class="line">It&apos;s a lambda function!</span><br></pre></td></tr></table></figure></p>
<h3 id="使用lambda表达式对集合进行迭代"><a href="#使用lambda表达式对集合进行迭代" class="headerlink" title="使用lambda表达式对集合进行迭代"></a>使用lambda表达式对集合进行迭代</h3><p>Java的集合类是日常开发中经常用到的，甚至说没有哪个java代码中没有使用到集合类……而对集合类最常见的操作就是进行迭代遍历了。<br>虽然Java里没用过foreach，但是我在c#里提过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void iterTest() &#123;</span><br><span class="line">        List&lt;String&gt; languages = Arrays.asList(&quot;java&quot;,&quot;scala&quot;,&quot;python&quot;);</span><br><span class="line">        //before java8</span><br><span class="line">        for(String each:languages) &#123;</span><br><span class="line">            System.out.println(each);</span><br><span class="line">        &#125;</span><br><span class="line">        //after java8</span><br><span class="line">        languages.forEach(x -&gt; System.out.println(x));</span><br><span class="line">        languages.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="用lambda表达式实现map"><a href="#用lambda表达式实现map" class="headerlink" title="用lambda表达式实现map"></a>用lambda表达式实现map</h3><p>至于什么是map可以百度以下。<br>一提到函数式编程，一提到lambda表达式，怎么能不提map……没错，java8肯定也是支持的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void mapTest() &#123;</span><br><span class="line">        List&lt;Double&gt; cost = Arrays.asList(10.0, 20.0,30.0);</span><br><span class="line">        cost.stream().map(x -&gt; x + x*0.05).forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">10.5</span><br><span class="line">21.0</span><br><span class="line">31.5</span><br></pre></td></tr></table></figure></p>
<p>map函数可以说是函数式编程里最重要的一个方法了。map的作用是将一个对象变换为另外一个。在我们的例子中，就是通过map方法将cost增加了0.05倍的大小然后输出。</p>
<h3 id="用lambda表达式实现map与reduce"><a href="#用lambda表达式实现map与reduce" class="headerlink" title="用lambda表达式实现map与reduce"></a>用lambda表达式实现map与reduce</h3><p>既然提到了map，又怎能不提到reduce。reduce与map一样，也是函数式编程里最重要的几个方法之一……map的作用是将一个对象变为另外一个，而reduce实现的则是将所有值合并为一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void mapReduceTest() &#123;</span><br><span class="line">        List&lt;Double&gt; cost = Arrays.asList(10.0, 20.0,30.0);</span><br><span class="line">        double allCost = cost.stream().map(x -&gt; x+x*0.05).reduce((sum,x) -&gt; sum + x).get();</span><br><span class="line">        System.out.println(allCost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">63.0</span><br></pre></td></tr></table></figure></p>
<h3 id="filter操作"><a href="#filter操作" class="headerlink" title="filter操作"></a>filter操作</h3><p>filter也是我们经常使用的一个操作。在操作集合的时候，经常需要从原始的集合中过滤掉一部分元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void filterTest() &#123;</span><br><span class="line">        List&lt;Double&gt; cost = Arrays.asList(10.0, 20.0,30.0,40.0);</span><br><span class="line">        List&lt;Double&gt; filteredCost = cost.stream().filter(x -&gt; x &gt; 25.0).collect(Collectors.toList());</span><br><span class="line">        filteredCost.forEach(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">30.0</span><br><span class="line">40.0</span><br></pre></td></tr></table></figure></p>
<h3 id="与函数式接口Predicate配合"><a href="#与函数式接口Predicate配合" class="headerlink" title="与函数式接口Predicate配合"></a>与函数式接口Predicate配合</h3><p><strong>这个看不太懂，留着慢慢看。</strong><br>除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。Predicate接口非常适用于做过滤。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static void filterTest(List&lt;String&gt; languages, Predicate&lt;String&gt; condition) &#123;</span><br><span class="line">        languages.stream().filter(x -&gt; condition.test(x)).forEach(x -&gt; System.out.println(x + &quot; &quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; languages = Arrays.asList(&quot;Java&quot;,&quot;Python&quot;,&quot;scala&quot;,&quot;Shell&quot;,&quot;R&quot;);</span><br><span class="line">        System.out.println(&quot;Language starts with J: &quot;);</span><br><span class="line">        filterTest(languages,x -&gt; x.startsWith(&quot;J&quot;));</span><br><span class="line">        System.out.println(&quot;\nLanguage ends with a: &quot;);</span><br><span class="line">        filterTest(languages,x -&gt; x.endsWith(&quot;a&quot;));</span><br><span class="line">        System.out.println(&quot;\nAll languages: &quot;);</span><br><span class="line">        filterTest(languages,x -&gt; true);</span><br><span class="line">        System.out.println(&quot;\nNo languages: &quot;);</span><br><span class="line">        filterTest(languages,x -&gt; false);</span><br><span class="line">        System.out.println(&quot;\nLanguage length bigger three: &quot;);</span><br><span class="line">        filterTest(languages,x -&gt; x.length() &gt; 4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line">Language starts with J: </span><br><span class="line">Java </span><br><span class="line"></span><br><span class="line">Language ends with a: </span><br><span class="line">Java </span><br><span class="line">scala </span><br><span class="line"></span><br><span class="line">All languages: </span><br><span class="line">Java </span><br><span class="line">Python </span><br><span class="line">scala </span><br><span class="line">Shell </span><br><span class="line">R </span><br><span class="line"></span><br><span class="line">No languages: </span><br><span class="line"></span><br><span class="line">Language length bigger three: </span><br><span class="line">Python </span><br><span class="line">scala </span><br><span class="line">Shell</span><br></pre></td></tr></table></figure></p>
<p>可以看到，Stream API的过滤方法也接受一个Predicate，这意味着可以将我们定制的 filter() 方法替换成写在里面的内联代码，这也是lambda表达式的魔力。</p>
<h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p><strong>本部分转自：</strong><a href="https://blog.csdn.net/bitcarmanlee/article/details/70195403" target="_blank" rel="noopener">java8 手把手教你学会写lambda表达式</a></p>
<h2 id="C-的匿名方法和lambda表达式初步"><a href="#C-的匿名方法和lambda表达式初步" class="headerlink" title="C#的匿名方法和lambda表达式初步"></a>C#的匿名方法和lambda表达式初步</h2><p>顺便提一下C#，因为我大致只用俩语言。<br>微软告诉我们：我们在C#2.0之前就有委托了，在2.0之后又引入了匿名方法，C#3.0之后，又引入了Lambda表达式，他们三者之间的顺序是：委托-&gt;匿名表达式-&gt;Lambda表达式，微软的一步步升级，带给我们编程上的优美，简洁，可读性强…..</p>
<h3 id="委托和匿名表达式以及lambda表达式"><a href="#委托和匿名表达式以及lambda表达式" class="headerlink" title="委托和匿名表达式以及lambda表达式"></a>委托和匿名表达式以及lambda表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">delegate int calculator(int x, int y); //委托类型</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            calculator cal = new calculator(Adding);</span><br><span class="line">            int He = cal(1, 1);</span><br><span class="line">            Console.Write(He);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 加法</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">        public static int Adding(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delegate int calculator(int x, int y); //委托</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            calculator cal = delegate(int num1,int num2)</span><br><span class="line">            &#123;</span><br><span class="line">                return num1 + num2;</span><br><span class="line">            &#125;;</span><br><span class="line">            int he = cal(1, 1);</span><br><span class="line">            Console.Write(he);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>关于委托，我之前写过一个c#委托小技巧的文章，<a href="https://bluerbk.top/2018/05/24/CSharp-SmallTip-TwoFormConnect/" target="_blank" rel="noopener">点击此处</a>跳转。<br>关于lambda表达式，上述栗子可以写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delegate int calculator(int x, int y); //委托类型</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            calculator cal = (x, y) =&gt; x + y;//Lambda表达式，大家发现没有，代码一个比一个简洁</span><br><span class="line">            int he = cal(1, 1);</span><br><span class="line">            Console.Write(he);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>若要创建 Lambda 表达式，需要在 Lambda 运算符 =&gt; 左侧指定输入参数（如果有），然后在另一侧输入表达式或语句块。 例如，lambda 表达式 x =&gt; x <em> x 指定名为 x 的参数并返回 x 的平方值。<br>“Lambda表达式”是一个特殊的匿名函数，是一种高效的类似于函数式编程的表达式，Lambda简化了开发中需要编写的代码量。它可以包含表达式和语句，并且可用于创建委托或表达式目录树类型，支持带有可绑定到委托或表达式树的输入参数的内联表达式。所有Lambda表达式都使用Lambda运算符=&gt;，该运算符读作”goes to”。Lambda运算符的左边是输入参数(如果有)，右边是表达式或语句块。Lambda表达式x =&gt; x </em> x读作”x goes to x times x”。<br>下面是几个简单的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">delegate bool MyBol(int x, int y);</span><br><span class="line">        delegate bool MyBol_2(int x, string y);</span><br><span class="line">        delegate int calculator(int x, int y); //委托类型</span><br><span class="line">        delegate void VS();</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            MyBol Bol = (x, y) =&gt; x == y;</span><br><span class="line">            MyBol_2 Bol_2 = (x, s) =&gt; s.Length &gt; x;</span><br><span class="line">            calculator C = (X, Y) =&gt; X * Y;</span><br><span class="line">            VS S = () =&gt; Console.Write(&quot;我是无参数Labada表达式&quot;);</span><br><span class="line">            //</span><br><span class="line">            int[] numbers = &#123; 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 &#125;;</span><br><span class="line">            int oddNumbers = numbers.Count(n =&gt; n % 2 == 1);</span><br><span class="line">            //</span><br><span class="line">            List&lt;People&gt; people = LoadData();//初始化</span><br><span class="line">            IEnumerable&lt;People&gt; results = people.Where(delegate(People p) &#123; return p.age &gt; 20; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static List&lt;People&gt; LoadData()</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;People&gt; people = new List&lt;People&gt;();   //创建泛型对象  </span><br><span class="line">            People p1 = new People(21, &quot;guojing&quot;);       //创建一个对象  </span><br><span class="line">            People p2 = new People(21, &quot;wujunmin&quot;);     //创建一个对象  </span><br><span class="line">            People p3 = new People(20, &quot;muqing&quot;);       //创建一个对象  </span><br><span class="line">            People p4 = new People(23, &quot;lupan&quot;);        //创建一个对象  </span><br><span class="line">            people.Add(p1);                     //添加一个对象  </span><br><span class="line">            people.Add(p2);                     //添加一个对象  </span><br><span class="line">            people.Add(p3);                     //添加一个对象  </span><br><span class="line">            people.Add(p4);</span><br><span class="line">            return people;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class People</span><br><span class="line">    &#123;</span><br><span class="line">        public int age &#123; get; set; &#125;                //设置属性  </span><br><span class="line">        public string name &#123; get; set; &#125;            //设置属性  </span><br><span class="line">        public People(int age, string name)      //设置属性(构造函数构造)  </span><br><span class="line">        &#123;</span><br><span class="line">            this.age = age;                 //初始化属性值age  </span><br><span class="line">            this.name = name;               //初始化属性值name  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Func-lt-T-gt-委托"><a href="#Func-lt-T-gt-委托" class="headerlink" title="Func&lt;T&gt;委托"></a>Func&lt;T&gt;委托</h3><p>T 是参数类型，这是一个泛型类型的委托，用起来很方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Func&lt;int, string&gt; gwl = p =&gt; p + 10 + &quot;--返回类型为string&quot;;            </span><br><span class="line">            Console.WriteLine(gwl(10) + &quot;&quot;);   //打印‘20--返回类型为string’，z对应参数b，p对应参数a</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，这里的p为int 类型参数， 然而lambda主体返回的是string类型的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Func&lt;int, int, bool&gt; gwl = (p, j) =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    if (p + j == 10)</span><br><span class="line">                    &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;;</span><br><span class="line">            Console.WriteLine(gwl(5,5) + &quot;&quot;);   //打印‘True’，z对应参数b，p对应参数a</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>从这个栗子，我们能看到，p为int类型，j为int类型，返回值为bool类型。</p>
<h3 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h3><p><strong>本部分转自：</strong><a href="https://www.cnblogs.com/chenwolong/p/5669440.html" target="_blank" rel="noopener">C# Lambda表达式</a></p>
<hr>
<p>妈耶写完打了五个喷嚏，瞬间头晕。</p>
<h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2></div><div class="tags"><a href="/RBK.github.io/tags/C/">C#</a><a href="/RBK.github.io/tags/Java/">Java</a><a href="/RBK.github.io/tags/匿名内部类/">匿名内部类</a><a href="/RBK.github.io/tags/lambda/">lambda</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/RBK.github.io/2018/07/06/html-list-using/" class="pre">Html从入门到升华-列表及定位样式</a><a href="/RBK.github.io/2018/07/02/Hexo-Beauty-One/" class="next">优化hexo速度及简单配置</a></div><div id="comments"><div id="SOHUCS" sid="2018/07/04/java-lambda/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名内部类"><span class="toc-text">匿名内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名内部类的使用"><span class="toc-text">匿名内部类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名内部类的注意事项"><span class="toc-text">匿名内部类的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名内部类的初始化"><span class="toc-text">匿名内部类的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#既然说到了这里，顺便说一说代码块"><span class="toc-text">既然说到了这里，顺便说一说代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明"><span class="toc-text">声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda表达式"><span class="toc-text">lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#先划重点，写到这里我才意识到lambda是Java8的新特性，我抱着我的Java6不说话"><span class="toc-text">先划重点，写到这里我才意识到lambda是Java8的新特性，我抱着我的Java6不说话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#替代匿名内部类"><span class="toc-text">替代匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用lambda表达式对集合进行迭代"><span class="toc-text">使用lambda表达式对集合进行迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用lambda表达式实现map"><span class="toc-text">用lambda表达式实现map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用lambda表达式实现map与reduce"><span class="toc-text">用lambda表达式实现map与reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter操作"><span class="toc-text">filter操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与函数式接口Predicate配合"><span class="toc-text">与函数式接口Predicate配合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明-1"><span class="toc-text">声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-的匿名方法和lambda表达式初步"><span class="toc-text">C#的匿名方法和lambda表达式初步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#委托和匿名表达式以及lambda表达式"><span class="toc-text">委托和匿名表达式以及lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Func-lt-T-gt-委托"><span class="toc-text">Func&lt;T&gt;委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明-2"><span class="toc-text">声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OK-THANKS-FOR-READING-BYE-BYE"><span class="toc-text">OK,THANKS FOR READING.BYE BYE~</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/RBK.github.io/2018/07/21/install-ftp-for-linux/">Linux服务器安装FTP服务</a></li><li class="post-list-item"><a class="post-list-link" href="/RBK.github.io/2018/07/21/html-audio/">HTML5中的多媒体以及Canvas绘图</a></li><li class="post-list-item"><a class="post-list-link" href="/RBK.github.io/2018/07/19/install-java-for-linux/">Linux环境下安装Java8环境</a></li><li class="post-list-item"><a class="post-list-link" href="/RBK.github.io/2018/07/06/html-list-using/">Html从入门到升华-列表及定位样式</a></li><li class="post-list-item"><a class="post-list-link" href="/RBK.github.io/2018/07/04/java-lambda/">匿名内部类和lambda表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/RBK.github.io/2018/07/02/Hexo-Beauty-One/">优化hexo速度及简单配置</a></li><li class="post-list-item"><a class="post-list-link" href="/RBK.github.io/2018/06/29/html-css-div/">Html从入门到升华-CSS入门就蒸发</a></li><li class="post-list-item"><a class="post-list-link" href="/RBK.github.io/2018/06/27/html-basicInfo/">Html从入门到升华（One）</a></li><li class="post-list-item"><a class="post-list-link" href="/RBK.github.io/2018/05/24/CSharp-SmallTip-TwoFormConnect/">C#GUI使用小教程：事件和委托</a></li><li class="post-list-item"><a class="post-list-link" href="/RBK.github.io/2018/05/24/CSharp-Seventh-NetConnection/">C#从入门到放弃：Socket</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/RBK.github.io/categories/C/">C#</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/RBK.github.io/categories/Hexo/">Hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/RBK.github.io/categories/Html/">Html</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/RBK.github.io/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/RBK.github.io/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/RBK.github.io/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/RBK.github.io/categories/内部类/">内部类</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/RBK.github.io/categories/无线安全/">无线安全</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/RBK.github.io/tags/Socket/" style="font-size: 15px;">Socket</a> <a href="/RBK.github.io/tags/编程/" style="font-size: 15px;">编程</a> <a href="/RBK.github.io/tags/dotnet/" style="font-size: 15px;">dotnet</a> <a href="/RBK.github.io/tags/Microsoft/" style="font-size: 15px;">Microsoft</a> <a href="/RBK.github.io/tags/流/" style="font-size: 15px;">流</a> <a href="/RBK.github.io/tags/网络编程/" style="font-size: 15px;">网络编程</a> <a href="/RBK.github.io/tags/SQL数据库/" style="font-size: 15px;">SQL数据库</a> <a href="/RBK.github.io/tags/事件委托/" style="font-size: 15px;">事件委托</a> <a href="/RBK.github.io/tags/项目开发/" style="font-size: 15px;">项目开发</a> <a href="/RBK.github.io/tags/游戏开发/" style="font-size: 15px;">游戏开发</a> <a href="/RBK.github.io/tags/kali/" style="font-size: 15px;">kali</a> <a href="/RBK.github.io/tags/aircrack-ng/" style="font-size: 15px;">aircrack-ng</a> <a href="/RBK.github.io/tags/无线安全/" style="font-size: 15px;">无线安全</a> <a href="/RBK.github.io/tags/Python/" style="font-size: 15px;">Python</a> <a href="/RBK.github.io/tags/网络爬虫/" style="font-size: 15px;">网络爬虫</a> <a href="/RBK.github.io/tags/Java/" style="font-size: 15px;">Java</a> <a href="/RBK.github.io/tags/C/" style="font-size: 15px;">C#</a> <a href="/RBK.github.io/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/RBK.github.io/tags/前端/" style="font-size: 15px;">前端</a> <a href="/RBK.github.io/tags/Web/" style="font-size: 15px;">Web</a> <a href="/RBK.github.io/tags/博客/" style="font-size: 15px;">博客</a> <a href="/RBK.github.io/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/RBK.github.io/tags/Html/" style="font-size: 15px;">Html</a> <a href="/RBK.github.io/tags/Canvas/" style="font-size: 15px;">Canvas</a> <a href="/RBK.github.io/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/RBK.github.io/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/RBK.github.io/tags/Web服务器/" style="font-size: 15px;">Web服务器</a> <a href="/RBK.github.io/tags/FTP/" style="font-size: 15px;">FTP</a> <a href="/RBK.github.io/tags/Apache2/" style="font-size: 15px;">Apache2</a> <a href="/RBK.github.io/tags/服务器/" style="font-size: 15px;">服务器</a> <a href="/RBK.github.io/tags/匿名内部类/" style="font-size: 15px;">匿名内部类</a> <a href="/RBK.github.io/tags/lambda/" style="font-size: 15px;">lambda</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/RBK.github.io/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RBK.github.io/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RBK.github.io/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RBK.github.io/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/RBK.github.io/archives/2018/03/">三月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/RBK.github.io/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/RBK.github.io/atom.xml">订阅</a> |  <a href="/RBK.github.io/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/RBK.github.io/." rel="nofollow">Borui Kang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?01c362d616231bcf600eb6ff8fcca7f0";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/RBK.github.io/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/RBK.github.io/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cytH48S30'; 
  var conf = 'd0209038c6a14cf99471d758c8950ad6'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  window.onload=function(){loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}');};
})();</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>