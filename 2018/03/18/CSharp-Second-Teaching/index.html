<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="keywords" content="C#,闲谈,Java,C语言,Python,Hexo"><title>C#基础伪教程（二） | 蓝色的博客</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C#基础伪教程（二）</h1><a id="logo" href="/.">蓝色的博客</a><p class="description">RBK</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">C#基础伪教程（二）</h1><div class="post-meta"><a href="/2018/03/18/CSharp-Second-Teaching/#comments" class="comment-count"></a><p><span class="date">Mar 18, 2018</span><span><a href="/categories/C/" class="category">C#</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>今天啥都没干，干脆写一点C#吧，就当作是第二个教程了，不多说，进入正题。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是用class关键字定义声明，具体框架如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class name</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>public属于访问修饰符，表示访问权限，也可以为protected、internal或者private。<br>C#的类同样支持继承，被继承的类称为基类，继承基类的类称作派生类。派生类可以使用基类的数据、行为的基础上创建自己的数据和行为。<br>类的主题成员有</p>
<blockquote>
<p>字段<br>属性<br>方法<br>构造函数<br>析构函数</p>
</blockquote>
<hr>
<p>对象的创建使用new关键字<br>    Class class=new Class();</p>
<h3 id="静态类和静态成员"><a href="#静态类和静态成员" class="headerlink" title="静态类和静态成员"></a>静态类和静态成员</h3><p>静态类是不能被实例化的，不能通过new创建对象，只能通过类去直接访问内部成员。一般类中也可以包含静态成员，同样，不能被对象访问，只能由类去访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static class car</span><br><span class="line">&#123;	</span><br><span class="line">	public static string WriteName()&#123;</span><br><span class="line">		return &quot;这是静态成员&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">car.WriteName();</span><br></pre></td></tr></table></figure></p>
<p>静态类有以下几个特点：</p>
<ul>
<li>静态类的所有成员都是静态成员</li>
<li>静态类不能被实例化</li>
<li>静态类是封装的，不能被继承</li>
<li>静态类不能包含实例构造函数，但是可以定义静态构造函数<br>静态成员有以下几个特点：</li>
<li>含有静态成员的类必须有静态构造函数来初始化</li>
<li>静态字段通常用来记录实例对象的个数或存储该类所有对象的共享值</li>
<li>静态方法可以被重载但不能被重写</li>
<li>局部变量不能被声明为静态变量，如方法中不能声明静态变量</li>
</ul>
<h3 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h3><p><strong>字段</strong>默认为私有，可以被标记为public、private、protected、internal或protected internal，还可以声明为<strong>只读变量</strong>，用readonly关键字声明。<br>只读字段只能在初始化或者在构造函数中赋值，静态只读字段类似于常量，但是不能在编译的时候访问，而是在运行的时候访问。<br>字段通常具有以下属性：</p>
<ul>
<li>字段可以被类的多个方法访问，否则可以在方法内部定义变量，而非定义类的字段</li>
<li>字段的生命周期比类中的单个方法的生命期长</li>
<li>字段可以在声明时赋值，若构造函数包含了字段的初始值，则字段声明值将被覆盖。</li>
<li>字段出四肢不能引用其他实例字段，但是可以是其他类的静态字段<br>如定义公共的静态只读字段num<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static readonly int num;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>若字段被标记为私有则只能通过<strong>属性</strong>来进行访问。<br>属性结合了字段的方法和属性，既可以被当作特殊的方法使用，也可以作为普通字段进行使用。<br>除了访问修饰符，属性还可以具有以下标记</p>
<blockquote>
<p>static        静态属性<br>virtual       虚属性<br>sealed        它对派生类不再是虚拟的<br>abstract      在派生类中实现</p>
</blockquote>
<p>属性具有get访问器或set访问器或同时拥有，两者可以具有不同的访问修饰符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可访问类型  类型  名称</span><br><span class="line">&#123;</span><br><span class="line">	get &#123;&#125;</span><br><span class="line">	set &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>get和set均可省略。若只有get则为只读属性，若只有set则为只写属性。<br>get和set相当于Java中私有封装的getter和setter。<br>具体用法如下：</p>
<blockquote>
<p>get访问器与方法类似，它必须返回属性类型的值作为属性的值，当引用属性的时候，若没有为属性赋值，则调用get访问器获取属性的值<br>get访问器必须以return或throw结尾，并且控制权不能离开访问器<br>get访问器除了直接返回字段值，还可以通过计算返回字段值<br>set访问器类似于返回类型为void的方法，它使用属性类型的value隐式参数，当对属性赋值时，用提供心智的参数调用set访问器<br>在set访问器中，对据变量声明使用隐式参数名称value是错误的。</p>
</blockquote>
<p>使用属性的时候就像是使用方法一样，简单示例代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//第一个</span><br><span class="line">public class count</span><br><span class="line">&#123;	</span><br><span class="line">	public int num;</span><br><span class="line">	public int addnum</span><br><span class="line">	&#123;</span><br><span class="line">		get &#123; return num + 10; &#125;</span><br><span class="line">		set &#123;num = value - 100; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">	static void Main(string[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		count id=new count();</span><br><span class="line">		id.num=200;</span><br><span class="line">		Console.WriteLine(id.addnum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出为</span><br><span class="line">300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二个</span><br><span class="line">public class age</span><br><span class="line">&#123;</span><br><span class="line">	public int agenum;</span><br><span class="line">	public int num</span><br><span class="line">	&#123;</span><br><span class="line">		get &#123; return ageuum; &#125;</span><br><span class="line">		set </span><br><span class="line">		&#123;</span><br><span class="line">			if ((value &gt; 0)&amp;&amp;(value &lt; 200))</span><br><span class="line">			&#123;</span><br><span class="line">				value = agenum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">	static void Main(string[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		age ageo=new age();</span><br><span class="line">		ageo.num=300;</span><br><span class="line">		Console.WriteLine(ageo.agenum);</span><br><span class="line">		ageo.agenum=70;</span><br><span class="line">		Console.WriteLine(ageo.num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果为</span><br><span class="line">0</span><br><span class="line">70</span><br></pre></td></tr></table></figure></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法在类中声明，具体格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问级别 是否静态 返回值类型 方法名 （参数类型 参数1，参数类型 参数2...）</span><br><span class="line">｛...｝</span><br></pre></td></tr></table></figure></p>
<p><strong>关于参数</strong><br>分为按值传递和按引用传递。<br>前者即为传入该变量的副本，对其形式参数进行使用，不影响原变量的值。<br>后者即为引用，如C语言中的&amp;，直接对变量本身进行操作，不使用副本。在参数前加修饰符ref或out即可。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是类调用中首先执行的函数，构造函数是方法的一种，与方法唯一不同的时构造函数在创建累的对象时执行的类方法，构造函数要与类名同名，不需要写返回值类型。构造函数可以被标记为public、protected、private、internal或者protected internal。<br>若没有写构造函数，在C#编译器中将自动添加一个默认构造函数，来实例化对象，并将所有成员变量设置为各自类型的默认值。<br><strong>静态类</strong>也有构造函数，作用于非静态类构造函数一样，但静态类中构造函数为静态构造函数。<br>构造函数可分为静态构造函数、实例化构造函数和私有化构造函数等。<br>静态构造函数特点如下：</p>
<blockquote>
<p>静态构造函数访问修饰符和参数<br>静态构造函数在首次访问类的时候自动调用<br>静态构造函数由编译器控制调用，开发人员无法直接调用静态构造函数<br>私有化构造函数是一种特殊的实例构造函数。它通常用在只包含静态成员的类中，如果类中具有一个或多个私有构造函数而没有公共构造函数，则不允许其他类创建该类的实例。<br>多态允许具有多个含不同参数的构造函数，根据参数的不同选用对应的构造函数。<br><strong>在一个构造函数中可以通过this关键字调用其他的构造函数。</strong></p>
</blockquote>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数是用来释放类资源的，它与一般方法有很大区别，主要有以下几点：</p>
<ul>
<li>一个类只能有一个析构函数</li>
<li>析构函数不能被继承</li>
<li>析构函数由编译器调节，开发人员无法控制何时调用，由垃圾回收起决定</li>
<li>析构函数没有访问修饰符和参数</li>
<li>析构函数不能定义返回值类型，也没有返回值</li>
<li>程序退出时自动执行析构函数</li>
</ul>
<p>命名的时候在名字前面加’~’以和构造函数区分开<br>通过调用Collect强制进行资源释放，但是可能会导致程序性错误。通过来自IDisposable接口的Dispose（）可以显式地释放一些资源，为对象执行必要的清理。虽然会提高性能但垃圾回收期还是会调用析构函数对对象进行彻底清理。</p>
<h2 id="类的高级应用"><a href="#类的高级应用" class="headerlink" title="类的高级应用"></a>类的高级应用</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>对类本身，内部成员属性及方法确定是否可被访问等，是否该被隐藏。<br>密封类，不可被继承，通常用来限制扩展性。<br>public sealed class D{…}<br>除此之外与其他类区别不大，可以实例，可以私有，可以共有等。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>C#中，所有类都是直接或间接地继承Object类。类可以被连环继承。继承如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class News&#123;...&#125;</span><br><span class="line">class SportsNews:News&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><p>又被称为虚函数，是一种可以被派生类实现、重载或冲写的方法，虚函数同选择语句一样有执行条件，根据不同情况实现。一般方法在编译时就静态地编译到执行文件中，其相对地址在程序运行期间是不变的。但是虚函数在编译期间不能被静态编译，它相对地址是不变的。<br>虚方法根据运行时期对象实例来动态判断要调用的函数，其中声明时定义的类交声明类，执行时实例化的类叫实例类。虚方法有以下特点，如下所示：</p>
<ul>
<li>虚方法通过virtual关键字实现</li>
<li>虚方法通过override关键字在派生类中实现</li>
<li>虚方法前不允许有static、abstract或override修饰符</li>
<li>虚方法不能是私有的，因此不能使用private修饰符</li>
</ul>
<p>虚函数执行过程如下所示</p>
<ol>
<li>当调用一个对象的函数时，系统会直接去检查这个函数声明所在的类，即声明类，查看函数是否为虚函数</li>
<li>若不是虚函数，那么直接执行该函数。但如果是虚函数，那么程序不会立刻执行该函数，而是检查对象的实例类，即继承函数声明的类</li>
<li>在这个实例类，程序将检查这个实例类的定义中是否包含实现该虚函数或者重写虚函数的方法</li>
<li>如果有，执行实例类中实现的虚函数的方法。如果没有，系统就会不停地往上找实例类的父类，并对父类重复刚才在实例类里的检查，直到找到第一个重载该虚函数的父类为止，然后执行该父类里冲在后的方法</li>
</ol>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种仅用于继承的类。定义一个抽象类的目的主要是为派生类提供可共享的基类成员的公共生命。抽象类对象的抽象成员只有声明部分，没有实现部分。抽象类中的成员实现完全由继承抽象类的派生了来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class A&#123;</span><br><span class="line">	public abstract int B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象类的继承必须实现对抽象类中所有未实现的成员，包括属性和方法。抽象类中抽象成员的实现和虚函数的实现一样，在方法名前用override关键字。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>类的方法有三种多态形式</p>
<blockquote>
<p>定义同名但参数列表不同的方法，被称为方法的重载<br>定义同名且参数列表也相同的方法，并且父类中的方法用abstract/virtual进行修饰，成为方法的覆盖。子类中的同名方法也用override进行修饰，如虚方法和抽象类的覆盖<br>定义相同且参数列表也相同的方法，其父类中的方法没有用abstract/virtual进行修饰，称为方向的隐藏。</p>
</blockquote>
<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><ul>
<li>方法名必须相同。</li>
<li>返回值可以相同也可以不同，但参数列表不能相同，因为编译器首先根据方法名选择方法，再根据参数列表在众多重载函数中找到合适的。</li>
<li>匹配函数时，编译器将不区分类型引用和类型本身，也不区分const和非const变量。</li>
</ul>
<h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>有两种形式，覆盖（只能重写被abstract和virtual关键字修饰的方法，在中写的时候需要关键字override）和隐藏（直接使用new关键字重写基类中的一般方法）。<br><strong>重写时针对方法名相同，擦书列表也相同的方法的多态</strong>，通常时在子类中重写基类的方法。<br>重写有以下几个特点</p>
<ul>
<li>静态方法、密封方法和非虚方法不能被覆盖。</li>
<li>非虚方法可以被隐藏，但静态方法和密封方法不能被隐藏。</li>
<li>重写方法和已重写了的基方法具有相同的返回类型。</li>
<li>重写声明和已重写了的基方法具有相同的声明可访问性。重写声明不能更改所对应的虚方法的可访问性。<br>如果已重写的基方法时protected internal，并且生命它的程序集不是包含重写方法的程序集，则重写方法声明的可访问性必须是protected。</li>
</ul>
<hr>
<p>关于后面的几个概念的举例，我懒得写了，需要的时候上网查一下就好了（估计一般也用不太上），就这样</p>
<h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2></div><div class="tags"><a href="/tags/编程/">编程</a><a href="/tags/C/">C#</a><a href="/tags/dotnet/">dotnet</a><a href="/tags/Microsoft/">Microsoft</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/03/22/Java-SocketProgramming/" class="pre">基于Socket的Java网络通信讲解与实例</a><a href="/2018/03/17/C-First-Teaching/" class="next">C#基础伪教程（一）</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#类"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态类和静态成员"><span class="toc-text">静态类和静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字段和属性"><span class="toc-text">字段和属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#析构函数"><span class="toc-text">析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的高级应用"><span class="toc-text">类的高级应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚方法"><span class="toc-text">虚方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法的重载"><span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法的重写"><span class="toc-text">方法的重写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OK-THANKS-FOR-READING-BYE-BYE"><span class="toc-text">OK,THANKS FOR READING.BYE BYE~</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/22/Java-SocketProgramming/">基于Socket的Java网络通信讲解与实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/18/CSharp-Second-Teaching/">C#基础伪教程（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/C-First-Teaching/">C#基础伪教程（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/hexo_use/">使用HEXO+GITHUB搭建自己的博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/14/article-title/">article-title</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/14/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C#</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a> <a href="/tags/网络编程/" style="font-size: 15px;">网络编程</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/C/" style="font-size: 15px;">C#</a> <a href="/tags/dotnet/" style="font-size: 15px;">dotnet</a> <a href="/tags/Microsoft/" style="font-size: 15px;">Microsoft</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Borui Kang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>