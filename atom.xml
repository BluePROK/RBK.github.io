<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蓝色的博客</title>
  
  <subtitle>RBK</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bluerbk.top/"/>
  <updated>2018-05-25T06:15:07.705Z</updated>
  <id>https://bluerbk.top/</id>
  
  <author>
    <name>Borui Kang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C#GUI使用小教程：事件和委托</title>
    <link href="https://bluerbk.top/2018/05/24/CSharp-SmallTip-TwoFormConnect/"/>
    <id>https://bluerbk.top/2018/05/24/CSharp-SmallTip-TwoFormConnect/</id>
    <published>2018-05-24T09:08:54.000Z</published>
    <updated>2018-05-25T06:15:07.705Z</updated>
    
    <content type="html"><![CDATA[<p>之前在写GUI的时候发现这么一个问题，我不可能把所有东西都写在一个界面里吧，那么，我怎么通过在这个界面改变另一个界面的东西呢？比如我点击按钮，另一个界面的图片就会改变。</p><p>这个问题困扰了两个礼拜，在此期间我百度了各种，最终找到了方法，使用事件和委托，但是不知道为什么百度几乎所有文章都把这个东西讲的很难，然后我找啊找，找到了一个小视频，只有十分钟，但是能解决这个鬼问题。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>新东西还是得先扯概念，虽然我不喜欢，而且我是从别的地方复制来的。</p><h3 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h3><p>delegate是C#中的一种类型，它实际上是一个能够持有对某个方法的引用的类。与其它的类不同，delegate类能够拥有一个签名（signature），并且它”只能持有与它的签名相匹配的方法的引用”。它所实现的功能与C/C++中的函数指针十分相似。它允许你传递一个类A的方法m给另一个类B的对象，使得类B的对象能够调用这个方法m。但与函数指针相比，delegate有许多函数委托和事件在 .Net Framework中的应用非常广泛指针不具备的优点。首先，函数指针只能指向静态函数，而delegate既可以引用静态函数，又可以引用非静态成员函数。在引用非静态成员函数时，delegate不但保存了对此函数入口指针的引用，而且还保存了调用此函数的类实例的引用。其次，与函数指针相比，delegate是面向对象、类型安全、可靠的受控（managed）对象。也就是说，runtime能够保证delegate指向一个有效的方法，你无须担心delegate会指向无效地址或者越界地址。</p><p>实现一个delegate是很简单的，通过以下3个步骤即可实现一个delegate：</p><ul><li>声明一个delegate对象，它应当与你想要传递的方法具有相同的参数和返回值类型。</li><li>创建delegate对象，并”将你想要传递的函数作为参数传入”。</li><li>在要实现异步调用的地方，通过上一步创建的对象来调用方法。</li></ul><p>结合delegate的实现，我们可以将自定义事件的实现归结为以下几步：</p><ul><li>定义delegate对象类型，它有两个参数，第一个参数是事件发送者对象，第二个参数是事件参数类对象。</li><li>定义事件参数类，此类应当从System.EventArgs类派生。如果事件不带参数，这一步可以省略。</li><li>定义”事件处理方法，它应当与delegate对象具有相同的参数和返回值类型”。</li><li>用event关键字定义事件对象，它同时也是一个delegate对象。</li><li>用+=操作符添加事件到事件队列中（-=操作符能够将事件从队列中删除）。</li><li>在需要触发事件的地方用调用delegate的方式写事件触发方法。一般来说，此方法应为protected访问限制，既不能以public方式调用，但可以被子类继承。名字是OnEventName。</li><li>在适当的地方调用事件触发方法触发事件。</li></ul><p>概念总算复制完了，其实我一个字都没看。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>这才是需要关心的地方。<br>先说明一下背景，点击Form2的按钮，修改Form1的Label的文本内容，就这个简单的功能。<br>首先在Form2.cs的类中，方法外，定义一个委托，然后创建一个事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public delegate void Change();</span><br><span class="line">public event Change MyChangeEvent;</span><br></pre></td></tr></table></figure></p><p>然后在Form2的触发方法（比如按钮的Click事件）中，触发事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void ChangeButton_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            //触发时间，在哪里注册了就会在哪里执行。</span><br><span class="line">//这个注释什么意思我也忘了，留着吧，万一啥时候想起了</span><br><span class="line">            MyChangeEvent();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>现在事件就定义完成了，回到Form1中，在触发方法（比如按钮的Click事件）中，注册事件，即绑定一个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void NewButton_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            Form2 f2 = new Form2();</span><br><span class="line">            //注册事件即绑定一个方法</span><br><span class="line">            f2.MyChangeEvent += f2_MyChangeEvent;</span><br><span class="line">            f2.Show();</span><br><span class="line">        &#125;</span><br><span class="line">void f2_MyChangeEvent()</span><br><span class="line">        &#123;</span><br><span class="line">            //只要事件被触发，就执行这里的代码</span><br><span class="line">            label.Text = &quot;成功了&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>使用+=绑定方法，至此这个简单的技巧就说完了。<br>这一段代码意思是点击按钮之后打开一个新窗口，同时注册这个这个方法，将其绑定给Form2的事件，点击Form2的按钮后就执行了代码了。</p><h2 id="这个方法不止Winform可以用，WPF跨窗体也可以用的。"><a href="#这个方法不止Winform可以用，WPF跨窗体也可以用的。" class="headerlink" title="这个方法不止Winform可以用，WPF跨窗体也可以用的。"></a>这个方法不止Winform可以用，WPF跨窗体也可以用的。</h2><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在写GUI的时候发现这么一个问题，我不可能把所有东西都写在一个界面里吧，那么，我怎么通过在这个界面改变另一个界面的东西呢？比如我点击按钮，另一个界面的图片就会改变。&lt;/p&gt;
&lt;p&gt;这个问题困扰了两个礼拜，在此期间我百度了各种，最终找到了方法，使用事件和委托，但是不知道为
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
      <category term="事件委托" scheme="https://bluerbk.top/tags/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>C#从入门到放弃：Socket</title>
    <link href="https://bluerbk.top/2018/05/24/CSharp-Seventh-NetConnection/"/>
    <id>https://bluerbk.top/2018/05/24/CSharp-Seventh-NetConnection/</id>
    <published>2018-05-24T08:23:42.000Z</published>
    <updated>2018-05-25T06:19:04.636Z</updated>
    
    <content type="html"><![CDATA[<p>高产似那啥。似个毛啊，这个文章是我上个月就要发的，然而拖了一个月，一直都有其他事，现在才空出来写这个。<br>其实这个不用重点介绍概念什么的了，想起来之前写过java的Socket的文章，我的微信公众号也有个Java的Socket，可以把这几个文章结合起来看。</p><p>网络编程有UDP啊，TCP啊，喜闻乐见的Socket啊什么的，打算把这些都搞一下，以前一直用java的Socket，也用了Socket在Java和C#发送消息。<br>写着鬼玩意都睡着了还给。</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>socket非常类似于电话插座。以一个电话网为例：电话的通话双方相当于相互通信的2个程序，电话号码就是ip地址。任何用户在通话之前，首先要占有一部电话机，相当于申请一个socket；同时要知道对方的号码，相当于对方有一个固定的socket。然后向对方拨号呼叫，相当于发出连接请求。对方假如在场并空闲，拿起电话话筒，双方就可以正式通话，相当于连接成功。双方通话的过程，是一方向电话机发出信号和对方从电话机接收信号的过程，相当于向socket发送数据和从socket接收数据。通话结束后，一方挂起电话机相当于关闭socket，撤销连接。<br>套接字分类</p><ul><li>流式套接字（SOCK_STREAM）：提供了一种可靠的、面向连接的双向数据传输服务。实现了数据无差错，无重复的发送，内设流量控制，被传输的数据被看做无记录边界的字节流。在TCP/IP协议簇中，使用TCP实现字节流的传输，当用户要发送大批量数据，或对数据传输的可靠性有较高要求时使用流式套接字。</li><li>数据报套接字（SOCK_DGRAM）：提供了一种无连接、不可靠的双向数据传输服务。数据以独立的包形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端数据按发送顺序接收。在TCP/IP协议簇中，使用UDP实现数据报套接字。</li><li>原始套接字（SOCK_RAW）：该套接字允许对较低层协议（如IP或ICMP）进行直接访问。一般用于对TCP/IP核心协议的网络编程。<h4 id="上面都是啥我忘了，上次写的时候不知道从哪抄的了，不管了，直入主题"><a href="#上面都是啥我忘了，上次写的时候不知道从哪抄的了，不管了，直入主题" class="headerlink" title="上面都是啥我忘了，上次写的时候不知道从哪抄的了，不管了，直入主题"></a>上面都是啥我忘了，上次写的时候不知道从哪抄的了，不管了，直入主题</h4></li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接老规矩，需要构造一个“连接字符串”，这里需要一个IP地址和一些Socket的参数好像，如下，需要使用IPAddress构造一个IP地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IPAddress ip = IPAddress.Parse(&quot;127.0.0.1&quot;);</span><br><span class="line">Socket socket = new Socket(AddressFamily.InterNetwork,SocketType.Stream, ProtocolType.Tcp);</span><br></pre></td></tr></table></figure></p><p>之后呢使用Socket.Connect()进行连接，如下，其中4000为通信的端口，0~1023是系统端口，1024~49151是注册端口，有些会绑定一些松散的服务，许多系统都从1024开始动态处理端口，如果我们通信的话把端口选择在1024之后不冲突就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.Connection(new IPEndPoint(ip,4000));</span><br></pre></td></tr></table></figure></p><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>发送信息的时候采用Socket.Send()方法，SendTo()方法应该也可以，我没试过，在这里，参数是需要发送的数据的字节数组，即byte[]类型，这个方法是有返回值的，返回值为已经发送到Socket的字节数。<br>所以发送的时候需要将数据都转换为字节数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将字符串str转为UTF8格式的字节数组</span><br><span class="line">Encoding.UTF8.GetBytes(str);</span><br><span class="line">//将整型num转为字节数组</span><br><span class="line">BitConverter.GetBytes(num);</span><br></pre></td></tr></table></figure></p><p>例如一个完整的发送字符串可以为下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string str=&quot;name&quot;;</span><br><span class="line">byte[] data=new byte[str.Length];</span><br><span class="line">var ef=socket.Send(data);</span><br><span class="line">if (ef&lt;=0)&#123;</span><br><span class="line">Console.WriteLine(&quot;Failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">Console.WriteLine(&quot;Successfully&quot;);</span><br></pre></td></tr></table></figure></p><p>相比如Java的流操作，C#的操作还是方便了很多的，全部都是对字节数组进行操作。</p><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p>接收的时候使用Socket.Receive()方法，参数为需要保存数据的字节数组，即byte[]类型，返回值为收到的Receive的字节数，如果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte[] recdata=new byte[1024];</span><br><span class="line">var reff=socket.Receive(recdata);</span><br><span class="line">if (reff&lt;=0)&#123;</span><br><span class="line">Console.WriteLine(&quot;Failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">Console.WriteLine(&quot;Successfully&quot;);</span><br></pre></td></tr></table></figure></p><p>这样信息就接收成功了，但是要注意，这里接收到的仍然是字节数组byte[]，需要再次转换才能成为我们需要的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将UTF8的byte字节数组转换为字符串</span><br><span class="line">Encoding.UTF8.GetString(byte);</span><br><span class="line">//将字节数组转换为整型</span><br><span class="line">BitConverter.ToInt32(byte);</span><br></pre></td></tr></table></figure></p><p>这样才能得到我们真正需要的。</p><h2 id="有点坑"><a href="#有点坑" class="headerlink" title="有点坑"></a>有点坑</h2><p>大致的操作就是这些，其实也没什么难的。只要就是一些细节。<br>比如在连续Send的时候，接收端可能会出现接收错误的情况，至于为什么我归结于缓冲区的问题，Java我也碰到过，不过java的流操作可以使用flush()清空缓冲区，C#我似乎没有找到，只能采取最差的方法，对每一个Send接收端也返回一个Send，作为反馈，多线程的非阻塞情况下会不会出现这个问题我还需要再试试。</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高产似那啥。似个毛啊，这个文章是我上个月就要发的，然而拖了一个月，一直都有其他事，现在才空出来写这个。&lt;br&gt;其实这个不用重点介绍概念什么的了，想起来之前写过java的Socket的文章，我的微信公众号也有个Java的Socket，可以把这几个文章结合起来看。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
      <category term="网络编程" scheme="https://bluerbk.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C#从入门到放弃 - 魔塔</title>
    <link href="https://bluerbk.top/2018/05/21/Game-MoTa/"/>
    <id>https://bluerbk.top/2018/05/21/Game-MoTa/</id>
    <published>2018-05-21T13:56:32.000Z</published>
    <updated>2018-05-21T15:42:05.770Z</updated>
    
    <content type="html"><![CDATA[<p>关于项目的开发具体也不多说吧，主要说一下具体思路和碰到的问题，简单的就这么放上来了，难的项目再放具体实例。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要是在B站上看到了C++版本的魔塔视频，勾起了这个游戏的回忆，但是又不想去学习C++，就在网上搜了一下C#版本的，果然不少，我找了一些代码看了卡，借鉴了一下，再糅合一些元素，写出了我的魔塔。<br>我就是不放图，自己脑补吧。</p><h3 id="关于魔塔"><a href="#关于魔塔" class="headerlink" title="关于魔塔"></a>关于魔塔</h3><p>《魔塔》是一种策略类的固定数值RPG游戏。游戏需要动很多脑筋，任何一个轻率的选择都可能导致游戏的失败。魔塔游戏虽不大，但是制作精美，道具很多，而且难度不低，对智商是一次艰巨的考验。</p><h2 id="思路设计"><a href="#思路设计" class="headerlink" title="思路设计"></a>思路设计</h2><p>从简介里可以看出啦，这个游戏的逻辑还是很简单的，而且界面设计是类似像素风的，主界面也是一格一格，这就相对更好设计了。主界面采用PictureBox控件，这个空间可以设置BackGroundImage和Image两个属性，后者可以覆盖前者，可以让地面和墙作为背景，怪物和物品等放在前景。<br>地图我的是13x13的，背景和怪物分别为13x13的二维数组，算上楼层，构成三维数组。数组中可以最简单的直接采用string类型，直接保存图片的地址，但这样很不好判断什么图形是什么物体，我采用了类，分为怪物物品类和背景类，分别具有不同的属性，比如怪物物品类具有攻击力，防御力等数值，至于我为什么把这两个不相关的东西放在一起，因为我还不太懂继承的一些东西，分成两个类不太好写数组类型，所以就只能这样了，共同属性也有，比如ID，名称，图片路径等，后面可以通过ID判定这个物体是什么东西，简化了判断的过程。<br>角色的移动、打怪、捡物品及开门等操作，即对PictureBox.Image进行操作，比如角色移动，先将这个PictureBox.Image=null，再对角色下一个位置的PictureBox.Image=cp.Image，即可完成角色的移动。<br>关于角色的移动，先判定是否有路，也就是不撞墙，可以通过判定PictureBox的背景Image，如果为Ground就可以走，然后再进行Image的判定，进行相关动作。<br>采用模块化编程思想，将楼层信息，主体信息，角色信息等分为不同的类进行编写，可以采用静态类读取内容，也可以实例化一个类，通过参数的传入进行各种操作。<br>答题逻辑就是这些，下面说一下注意事项和碰到的问题。</p><h2 id="bulabula"><a href="#bulabula" class="headerlink" title="bulabula"></a>bulabula</h2><p>首先，可以重写Form_Load方法，这个方法和Init方法不一样，后者是在初始化的时候进行的操作，比如变量赋值等，但是如果是对界面进行某个操作可能出现报错等问题，因为初始化阶段界面可能还没有加载好，如果想要设置界面的图形之类的，可以考虑将其加在前者重写中，当然初始化也可以，只不过可能会随缘报错。<br>其次，可以在Form_Load重写方法中设置窗口打开的大小，比如我们在编写的过程中需要显示胜利的界面狂，在这里我还是采用的PictureBox，没有地方放，我不得已把屏幕拉宽了，即便设置PictureBox的Visible，运行了还是宽边，这时候就可以重写加载函数，重新编辑窗口大小即可。<br>使用Thread.Sleep函数的时候，PictureBox.Image的动态设置不会生效，至于为什么，我没有查到具体的内容，不过我想可能是和缓冲区什么的有关吧，因为在休眠之后才会执行休眠之前的内容，可能和流的传输一样，需要刷新等操作将数据挤出流进行立刻传输。在此，只需要刷新一下PictureBox.Refresh即可，然后进行休眠操作，这时候就可以动态显示PictureBox的图像了。<br>我想想还有什么，ammmmmm好像就这些吧，具体还有的话想到了再补充吧。就这样，散了散了。<br>下一步准备写玩玩java的模拟web操作，登陆啊，点击啊什么的，然后有空了好好看看C# 的网络编程，我那个文章写了个开头一直没动，就这样。</p><hr><h2 id="OK-Bye"><a href="#OK-Bye" class="headerlink" title="OK,Bye"></a>OK,Bye</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于项目的开发具体也不多说吧，主要说一下具体思路和碰到的问题，简单的就这么放上来了，难的项目再放具体实例。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;主要是在B站上看到
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
      <category term="项目开发" scheme="https://bluerbk.top/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏开发" scheme="https://bluerbk.top/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Python从入门到放弃：利用爬虫抓取文字和图片</title>
    <link href="https://bluerbk.top/2018/04/26/Python-WebBug-First/"/>
    <id>https://bluerbk.top/2018/04/26/Python-WebBug-First/</id>
    <published>2018-04-26T11:05:51.000Z</published>
    <updated>2018-04-26T15:12:30.640Z</updated>
    
    <content type="html"><![CDATA[<p>在别提今天了，下午睡了至少三四个小时，看这个文章的建立时间，这不我才睡醒。写完这个得去写作业了，然后呢，有空了或者五一之后把网络编程看一看，就要去攻项目了。<br>具体深入的我不说，我也不知道，概念我也不知道，我就会用，就这么耿直。先说说爬虫主要import的东西，requests、BeautifulSoup和urllib(3.x里urlib和urllib2合为urllib了)。</p><h2 id="库的介绍"><a href="#库的介绍" class="headerlink" title="库的介绍"></a>库的介绍</h2><h3 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h3><p>Urllib是python内置的HTTP请求库，3.x版本中urllib2已经被整合到urllib.request里了<br>包括以下模块<br>urllib.request 请求模块<br>urllib.error 异常处理模块<br>urllib.parse url解析模块<br>urllib.robotparser robots.txt解析模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">response = urllib.request.urlopen(&apos;http://www.baidu.com&apos;)</span><br><span class="line">print(response.read().decode(&apos;utf-8&apos;))</span><br><span class="line">//上面是一种，下面是包含header头部信息的方法，防止某些网页反爬虫</span><br><span class="line">headers=&#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0&apos;&#125;</span><br><span class="line">req=urllib.request.Request(url,headers=headers)</span><br><span class="line">page=urllib.request.urlopen(req)</span><br><span class="line">soup=bs(content,&apos;html.parser&apos;)</span><br></pre></td></tr></table></figure></p><p>post就不写了，用了再说</p><h3 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h3><p>requests是python实现的简单易用的HTTP库，使用起来比urllib简洁很多。request也称urllib3模块。</p><h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><p>BeautifulSoup是Python的一个库，最主要的功能就是从网页爬取我们需要的数据。BeautifulSoup将html解析为对象进行处理，全部页面转变为字典或者数组，相对于正则表达式的方式，可以大大简化处理过程。</p><p>我以前在公众号写过一个爬虫的文章。（其实乍一看，微信的排版是真的可以，这个博客还是有点太简约了）<br><a href="https://mp.weixin.qq.com/s/ZooAeS7NgZESvcqf0xveIA" target="_blank" rel="noopener">点击此处跳转</a><br>这是关于新浪新闻内容的爬取，下面说一下关于图片等其他数据的爬取。因为我今天太困了，就不弄下载视屏什么的了。</p><h2 id="利用python爬虫抓取图片"><a href="#利用python爬虫抓取图片" class="headerlink" title="利用python爬虫抓取图片"></a>利用python爬虫抓取图片</h2><p>抓图片重点就是，找到图片所在的链接，就是我每次用极简图床出来的那个连接一样，然后使用request.get(url).content获取图片的二进制信息，然后直接写入本地文件，修改后缀即可。<br>上面新闻的爬取是静态网页，这里我爬王者荣耀官网，下载所有英雄的皮肤图片，他这个就是一个动态网页，什么是动态呢？动态就是说信息不在网页源代码里，而是在加载网页的时候才进行下载的。那么<strong>怎么判断是动态还是静态呢？</strong>有一个简单粗暴的技巧，右键查看网页源代码，ctrl-F搜索关键字，如果搜不出来那就是动态的了。<br>当然动态的其实也不难分析，按F12或者右键审查元素，点击网络栏，然后刷新就会出现收到的包，挨个看找需要的就好了。<br>直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">with open(r&apos;herolist.json&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">jsonFile=json.load(f)</span><br><span class="line">for i in range(0,79):</span><br><span class="line">ename=jsonFile[i][&apos;ename&apos;]</span><br><span class="line">cname=jsonFile[i][&apos;cname&apos;]</span><br><span class="line">skin_name=jsonFile[i][&apos;skin_name&apos;].split(&apos;|&apos;)</span><br><span class="line">skin_name_num=len(skin_name)</span><br><span class="line">for j in range(1,skin_name_num+1):</span><br><span class="line">url=&quot;http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/&quot;+str(ename)+&quot;/&quot;+str(ename)+&quot;-bigskin-&quot;+str(j)+&quot;.jpg&quot;</span><br><span class="line">html=requests.get(url).content</span><br><span class="line">with open(&quot;F:\\Programming\\Sublime\\Python\\Web_Bug\\Honor\\&quot;+cname+&quot;_&quot;+skin_name[j-1]+&quot;.jpg&quot;,&apos;wb&apos;) as picf:</span><br><span class="line">picf.write(html)</span><br><span class="line">print(&quot;获取英雄 &#123;0&#125; 的皮肤--&#123;1&#125; 成功&quot;.format(cname,skin_name[j-1]))</span><br></pre></td></tr></table></figure></p><p>解释一下以上代码，首先根据上面说的，发现他的数据是一个json格式的文件，然后呢要审查是吧，这就比较坑，360显示不出来，谷歌浏览器乱码，让我专门下了个火狐才能看到正确的，就很坑，如下图。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-26/57246599.jpg" alt="image"><br><strong>json文件操作</strong><br>用json.load导入，json其实也算是一个列表，用类似数组的方式访问，对于其中每个属性，用中括号访问即可，用split分割皮肤名，并计数，然后第一个for循环是循环每个英雄，第二个for循环是对每个皮肤进行循环，然后依次构造链接，获取图片信息，写入本地文件，下图是成果。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-26/68564150.jpg" alt="image"><br>以下代码是获取静态网页的示例，这里注释的部分是使用urllib库，没注释的用的requests库获取的网页信息，可以都参考一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup as bs</span><br><span class="line">import urllib.request</span><br><span class="line">import requests</span><br><span class="line">for p in range(3,6):</span><br><span class="line">url=&quot;https://www.dbmeinv.com/dbgroup/show.htm?cid=7&amp;pager_offset=&quot;+str(p)</span><br><span class="line">#headers=&#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0&apos;&#125;</span><br><span class="line">#req=urllib.request.Request(url,headers=headers)</span><br><span class="line">#page=urllib.request.urlopen(req)</span><br><span class="line">#content=page.read().decode(&apos;utf-8&apos;)</span><br><span class="line">res=requests.get(url)</span><br><span class="line">res.encoding=&apos;utf-8&apos;</span><br><span class="line">#soup=bs(content,&apos;html.parser&apos;)</span><br><span class="line">soup=bs(res.text,&apos;html.parser&apos;)</span><br><span class="line">src=soup.find_all(&apos;img&apos;)</span><br><span class="line">for i in src:</span><br><span class="line">pic_src=requests.get(i[&apos;src&apos;]).content</span><br><span class="line">name=i.get(&apos;title&apos;)</span><br><span class="line">#i.get(&apos;title&apos;)或者i[&apos;title&apos;]都可以</span><br><span class="line">with open(&apos;F:\\Programming\\Sublime\\Python\\Web_Bug\\ttui\\&apos;+name+&apos;.jpg&apos;,&apos;wb&apos;) as f:</span><br><span class="line">f.write(pic_src)</span><br><span class="line">print(name+&quot;\t写入完成&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在别提今天了，下午睡了至少三四个小时，看这个文章的建立时间，这不我才睡醒。写完这个得去写作业了，然后呢，有空了或者五一之后把网络编程看一看，就要去攻项目了。&lt;br&gt;具体深入的我不说，我也不知道，概念我也不知道，我就会用，就这么耿直。先说说爬虫主要import的东西，requ
      
    
    </summary>
    
      <category term="Python" scheme="https://bluerbk.top/categories/Python/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://bluerbk.top/tags/Python/"/>
    
      <category term="网络爬虫" scheme="https://bluerbk.top/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>C#基础伪教程（六）SQL数据库访问及线程操作</title>
    <link href="https://bluerbk.top/2018/04/24/CSharp-Sixth-SQLCon/"/>
    <id>https://bluerbk.top/2018/04/24/CSharp-Sixth-SQLCon/</id>
    <published>2018-04-24T06:36:33.000Z</published>
    <updated>2018-04-24T11:21:01.443Z</updated>
    
    <content type="html"><![CDATA[<p>关于这个线程今天看了看，还是没有找到停止的方法，文档写的Abort()方法，但是这个说明是一般情况下可以停止，就是说他可能调用之后没有停止，在完成某些逻辑之后才停止，而且它是通过抛出异常来执行的，有说调用方法之后用while一直检测线程状态，可是好像并没有什么用，再看看吧。<br>这次主要是线程的一点小操作和大头的SQL数据库访问，之前用JDBC已经实现了用JAVA访问数据库，现在用ADO.NET实现。</p><h2 id="ADO-NET"><a href="#ADO-NET" class="headerlink" title="ADO.NET"></a>ADO.NET</h2><p>是一组用语和数据源交换的面向对象类库，位于System.Data.dll中，与System.Xml.dll中的XML集成，在.NET Framework中提供最直接的数据访问方法。<br>.NET Framework对数据进行操作，访问读写等，将获得的结果存储于DataSet中。<br>.NET Framework提供以下数据提供程序</p><ul><li>用于SQL Server的数据提供程序（System.Data.SqlClient）</li><li>用于OLE DB的数据提供程序（System.Data.OleDb）</li><li>用于ODBC的数据提供程序（System.Data.Odbc）</li><li>用于Oracle的数据提供程序（System.Data.Oracle）</li></ul><h2 id="问题来了，我写了好些，还睡了一觉，起来发现，我写错了，书上用的是Microsoft-SQL-Server对吧，这玩意不是MySql！！！！不是！！我说我咋试了半天没成功，真辣鸡，我暂时不用Sql-Server，所以我就不写了，以后用不用我也不知道，到时候再说"><a href="#问题来了，我写了好些，还睡了一觉，起来发现，我写错了，书上用的是Microsoft-SQL-Server对吧，这玩意不是MySql！！！！不是！！我说我咋试了半天没成功，真辣鸡，我暂时不用Sql-Server，所以我就不写了，以后用不用我也不知道，到时候再说" class="headerlink" title="问题来了，我写了好些，还睡了一觉，起来发现，我写错了，书上用的是Microsoft SQL Server对吧，这玩意不是MySql！！！！不是！！我说我咋试了半天没成功，真辣鸡，我暂时不用Sql Server，所以我就不写了，以后用不用我也不知道，到时候再说"></a>问题来了，我写了好些，还睡了一觉，起来发现，我写错了，书上用的是Microsoft SQL Server对吧，这玩意不是MySql！！！！不是！！我说我咋试了半天没成功，真辣鸡，我暂时不用Sql Server，所以我就不写了，以后用不用我也不知道，到时候再说</h2><p>下面说说C#链接！！！</p><h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><p>(我的环境如下，工具点击下载）</p><ul><li>VS 2013</li><li>Windows 7 x64</li><li><a href="https://dev.mysql.com/downloads/windows/installer/5.5.html" target="_blank" rel="noopener">mysql-community-5.5.60.1</a></li><li><a href="https://dev.mysql.com/downloads/file/?id=475576" target="_blank" rel="noopener">mysql-connector-net-6.9.11.msi</a></li></ul><p>VS2013对应的版本应该是C#5.0和.NET4.5<br>这里使用的MySQL Connector Net的dll版本为4.5，可能是因为我的连接器版本太高了，只有4.5的，我的文件在C:\Program Files(x86)\MySQL里面。慎用高版本，8.0.11果然用不了，它支持.NET4.5.2，我是4.5.坑，用6.9.11版本，不知道是不是我安装的问题。</p><h2 id="工具的安装及配置"><a href="#工具的安装及配置" class="headerlink" title="工具的安装及配置"></a>工具的安装及配置</h2><h3 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h3><p>关于MySql的安装我去年装过，在本地写了一点，以下内容，应该能用。<br>（均可在mysql.com官网下载）运行mysql-5.5.57-winx64.msi安装MySQL控制台。在C:\Program Files\MySQL\MySQL Server 5.5\bin中运行MySQLInstanceConfig.exe配置MySQL。MySQL命令行安装完成。在官网找MySQL Workbench下载MySQL的图形化界面mysql-workbench-gpl-5.2.47-win32.msi。在webyog官网（webyog.com/cn）中下载最受追捧的图形化工具SQLyog711EntTrial.exe。可直接百度sqlyog。官网进不去。</p><h3 id="MySql-Connector-Net"><a href="#MySql-Connector-Net" class="headerlink" title="MySql-Connector-Net"></a>MySql-Connector-Net</h3><p>这个的安装直接运行mysql-connector-net-6.9.11.msi即可。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>先启动MySql服务，然后在VS的C#项目里添加引用C:\Program Files (x86)\MySQL\MySQL Connector Net 6.9.11\Assemblies\v4.5\MySql.Data.dll，.cs文件前添加引用using MySql.Data.Connection，即可使用。</p><h2 id="C-链接MySql"><a href="#C-链接MySql" class="headerlink" title="C#链接MySql"></a>C#链接MySql</h2><p>首先需要一个包含数据库相关信息的一个字符串，如下所示，从变量名应该能看出什么是什么，就不解释了，server是服务器的IP地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string connectionString = &quot;server=localhost;User Id=root;password=root;Database=text_java&quot;;</span><br></pre></td></tr></table></figure></p><p>以下代码分别是</p><ul><li>建立数据库连接</li><li>打开数据库</li><li>建立数据库查询语句</li><li>执行语句</li><li>释放资源</li><li>关闭数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySqlConnection conn = new MySqlConnection(connectionString);</span><br><span class="line">conn.Open();</span><br><span class="line">MySqlCommand myc = new MySqlCommand(&quot;insert into baseinfo values (&apos;Kang&apos;,&apos;111111&apos;,10);&quot;, conn);</span><br><span class="line">myc.ExecuteNonQuery()</span><br><span class="line">conn.Dispose();</span><br><span class="line">conn.Close();</span><br></pre></td></tr></table></figure></li></ul><p>ExecuteNonQuery()这个方法返回一个int好像，如果里面有内容，即返回值&gt;0，则执行成功。<br>以下是向数据库插入一条信息的完整代码。增删改除都可以用这样，只需要修改一下Command中的命令即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string connectionString = &quot;server=localhost;User Id=root;password=root;Database=text_java&quot;;</span><br><span class="line">        public void sql()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;正在连接数据库&quot;);</span><br><span class="line">            MySqlConnection conn = new MySqlConnection(connectionString);</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                conn.Open();</span><br><span class="line">                Console.WriteLine(&quot;连接成功&quot;);</span><br><span class="line">                MySqlCommand myc = new MySqlCommand(&quot;insert into baseinfo values (&apos;Kang&apos;,&apos;111111&apos;,10);&quot;, conn);</span><br><span class="line">                Console.WriteLine(myc.CommandText);</span><br><span class="line">                if (myc.ExecuteNonQuery() &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;数据插入成功！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                conn.Dispose();</span><br><span class="line">                conn.Close();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception) &#123; Console.Write(&quot;超时&quot;); &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h2 id="从MySql读取数据"><a href="#从MySql读取数据" class="headerlink" title="从MySql读取数据"></a>从MySql读取数据</h2><p>使用DataSet，这个还可以直接把里面的数据输出到GUI的DataGridView表格里，就是我的音乐列表那个东西。<br><a href="https://msdn.microsoft.com/zh-cn/library/system.data.dataset" target="_blank" rel="noopener">关于DatSet</a><br>一个DataSet里头可以有多个表，可以用过Add添加DataTableCollection，也可以通过Remove移除表。<br>（题外话，如果想把数据放到表格里，这样dataGridView1.DataSource = ds.Tables[“table”];，没试过不清楚）<br>然后用以下这个方法依次获取每个表的每一行的每一列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void PrintRows(DataSet dataSet)</span><br><span class="line">&#123;</span><br><span class="line">    // For each table in the DataSet, print the row values.</span><br><span class="line">    foreach(DataTable table in dataSet.Tables)</span><br><span class="line">    &#123;</span><br><span class="line">        foreach(DataRow row in table.Rows)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (DataColumn column in table.Columns)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(row[column]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个完整的打印Select * from baseinfo;的结果的代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string connectionString = &quot;server=localhost;User Id=root;password=root;Database=text_java&quot;;</span><br><span class="line">        private void PrintRows(DataSet dataSet)</span><br><span class="line">        &#123;</span><br><span class="line">            // For each table in the DataSet, print the row values.</span><br><span class="line">            foreach (DataTable table in dataSet.Tables)</span><br><span class="line">            &#123;</span><br><span class="line">                foreach (DataRow row in table.Rows)</span><br><span class="line">                &#123;</span><br><span class="line">                    foreach (DataColumn column in table.Columns)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(row[column]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void sql()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;正在连接数据库&quot;);</span><br><span class="line">            DataSet ds = new DataSet();</span><br><span class="line">            MySqlConnection conn = new MySqlConnection(connectionString);</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                conn.Open();</span><br><span class="line">                Console.WriteLine(&quot;连接成功&quot;);</span><br><span class="line">                MySqlCommand myc = new MySqlCommand(&quot;select * from baseinfo&quot;, conn);</span><br><span class="line">                Console.WriteLine(myc.CommandText);</span><br><span class="line">                MySqlDataAdapter da = new MySqlDataAdapter(&quot;select * from baseinfo&quot;, conn);</span><br><span class="line">                da.Fill(ds, &quot;table&quot;);</span><br><span class="line">                Console.WriteLine(&quot;数据获取成功&quot;);</span><br><span class="line">                PrintRows(ds);</span><br><span class="line">                conn.Dispose();</span><br><span class="line">                conn.Close();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception) &#123; Console.Write(&quot;超时&quot;); &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h2 id="最后插一点线程操作吧"><a href="#最后插一点线程操作吧" class="headerlink" title="最后插一点线程操作吧"></a>最后插一点线程操作吧</h2><p>如下构造一个新线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t=new Thread([一个方法]);</span><br><span class="line">//方法为对象.方法，或者new 类.方法</span><br></pre></td></tr></table></figure></p><p>目前我还是没有找到让线程停止的好办法！！！！！！！！！</p><ul><li>线程启动的方法为Start（）</li><li>挂起方法为Suspend()</li><li>挂起后恢复的方法为Resume()</li><li>中止方法Abort()(我还没成功过）</li><li>线程休眠方法Sleep（），也就是暂停</li><li>等待线程中止Join（），就是当我需要这个线程结束的时候再执行下一个线程，可以对这个线程调用这个方法，可以带一个时间参数，如果时间到了这个线程没有执行，那么下一个线程依旧可以执行<br>以下是一个分别输出.和=的两个线程的代码，其中=延迟两秒输出。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Threading;</span><br><span class="line">namespace C_</span><br><span class="line">&#123;</span><br><span class="line">    class my&#123;</span><br><span class="line">        public void x()&#123;</span><br><span class="line">            for (int i=0;i&lt;300;i++)&#123;</span><br><span class="line">                Console.Write(&quot;.&quot;);</span><br><span class="line">                Thread.Sleep(30);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void y()&#123;</span><br><span class="line">            for (int j=0;j&lt;300;j++)&#123;</span><br><span class="line">                Console.Write(&quot;=&quot;);</span><br><span class="line">                Thread.Sleep(30);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()&#123;</span><br><span class="line">            my m=new my();</span><br><span class="line">            Thread t1=new Thread(m.x);</span><br><span class="line">            Thread t2=new Thread(m.y);</span><br><span class="line">            t1.Start();</span><br><span class="line">            Thread.Sleep(2000);</span><br><span class="line">            t2.Start();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>执行效果如下图，同时可以浅显地解释多线程的原理，实际上就是多个线程交替使用资源，交替执行，因为交替的速度和执行一条命令的速度之快，以至于我们认为这是同时进行的。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-24/66925185.jpg" alt="image"><br>顺便附上我写的那个文件扫描的小工具，忽略那个线程不能终止的小问题，其他我觉得很ok啊。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-24/97002966.jpg" alt="image"></p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于这个线程今天看了看，还是没有找到停止的方法，文档写的Abort()方法，但是这个说明是一般情况下可以停止，就是说他可能调用之后没有停止，在完成某些逻辑之后才停止，而且它是通过抛出异常来执行的，有说调用方法之后用while一直检测线程状态，可是好像并没有什么用，再看看吧。
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
      <category term="SQL数据库" scheme="https://bluerbk.top/tags/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C#基础伪教程（五）C#的流操作</title>
    <link href="https://bluerbk.top/2018/04/20/CSharp-Fifth-Stream/"/>
    <id>https://bluerbk.top/2018/04/20/CSharp-Fifth-Stream/</id>
    <published>2018-04-20T06:03:09.000Z</published>
    <updated>2018-04-22T06:03:56.961Z</updated>
    
    <content type="html"><![CDATA[<p>上次写还是差不多两周前了，最近也不知道在干什么。先吐槽这个该死的迅雷的下载机制，一下载东西我的电脑就卡，我还不想限速，只能看ppt了。最近还想着再把Java看一看，C#再深入一点然后直接去攻前端，用Java做后端。<br>这次说这个流，流这个东西很常见，Java里经常用到，比如文件操作，Socket通信之类的，功能的强大与否其实取决于你的流选择的是否正确。</p><h2 id="System-IO命名空间"><a href="#System-IO命名空间" class="headerlink" title="System.IO命名空间"></a>System.IO命名空间</h2><p>System.IO命名空间提供了所有与文件、目录和流相关操作的类，直接使用这些方法即可。如下是常用的类</p><h3 id="内存流（MemoryStream）"><a href="#内存流（MemoryStream）" class="headerlink" title="内存流（MemoryStream）"></a>内存流（MemoryStream）</h3><p>是一种非缓冲流，可以直接在内存中访问数据。以下是常用的属性和方法<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-20/66812945.jpg" alt="image"><br>简单示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">byte[] String=uniEncoding.GetBytes(&quot;sss&quot;);</span><br><span class="line">//使用这个类中的这个方法将指定字符串转换为byte字节数组</span><br><span class="line">using (MemoryStream memStream=new MemoryStream(100))</span><br><span class="line">&#123;</span><br><span class="line">memStream.Write(String,0,String.Length);</span><br><span class="line">或者</span><br><span class="line">count=0;</span><br><span class="line">while (cunt&lt;String.Length)&#123;</span><br><span class="line">memStream.WriteByte(String[count++]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//通过属性调用获取关于流的相关信息</span><br><span class="line">memStream.Length.ToString()//输出流的长度</span><br><span class="line">//从流中读取数据并输出</span><br><span class="line">//定位流的开始位置</span><br><span class="line">memStream.Seek(0,SeekOrigin.Begin);</span><br><span class="line">byteArray=new byte[memStream.Length];</span><br><span class="line">//从0开始读取20个字节给ByteArray</span><br><span class="line">count=memStream.Read(byteArray,0,20);</span><br><span class="line">//另一种方法继续读取</span><br><span class="line">while(count &lt; memStream.Length)&#123;</span><br><span class="line">byte[count++]=Convert.ToByte(memStream.ReadByte());</span><br><span class="line">&#125;</span><br><span class="line">//转为char数组，然后再转为中文</span><br><span class="line">charArray=new char[uniEncoding.GetCharCount(byteArray,0,count)];</span><br><span class="line">uniEncoding.GetDecoder().GetChars(byteaRRAY,0,COUNT,CHARaRRAY,0);</span><br><span class="line">Console.Write(charArray);</span><br></pre></td></tr></table></figure></p><h3 id="文件流（FileStream）"><a href="#文件流（FileStream）" class="headerlink" title="文件流（FileStream）"></a>文件流（FileStream）</h3><p>使用文件流可以对文件进行的打开，关闭，查看相关信息等操作。可以指定是同步还是异步操作，相关属性方法如下<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-20/92193670.jpg" alt="image"><br>FileStram最常用的构造函数如下<br>FileStream(String filepath,FileMode)<br>FileMode是一个枚举类型，具有以下几个值</p><ul><li>Create    创建一个新的文件，如果存在则覆盖</li><li>CreateNew    创建一个新的文件，如果存在则会异常，提示文件已存在</li><li>Open        打开一个存在的文件</li><li>OpenOrCreate    打开一个文件，若不存在则创建一个新文件</li><li>Truncate    打开现有文件，一旦打开，将被截断为零字节大小</li><li>Append    如果文件存在，则进行追加写操作</li></ul><p>以下是简单示例<br>好像需要catch异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string filepath=&quot;text.txt&quot;;</span><br><span class="line">string str=&quot;Sss&quot;;</span><br><span class="line">FileStream fs=ne FileStream(filepath,FileMode.Create);</span><br><span class="line">byteArray=System.Text.Default.GetBytes(str);</span><br><span class="line">fs.Write(byteArray,0,byteArray.Length);</span><br><span class="line">fs.close();</span><br><span class="line">Console(&quot;ok&quot;);</span><br><span class="line">//下面是读取内容</span><br><span class="line">fs=new FileStream(filepath,FileMode.Open);</span><br><span class="line">int count=fs.Length;</span><br><span class="line">byteArray=new byte[count];</span><br><span class="line">fs.Seek(o,SeekOrigin.Begin);</span><br><span class="line">fs.Read(byteArray,0,count);</span><br><span class="line">//数据转换</span><br><span class="line">Decoder d=Encoding.Default.GetDecoder();</span><br><span class="line">charArray=new Char[count];</span><br><span class="line">d.GetChars(byteArray,0,byteArray.Length,charArray,0);</span><br><span class="line">Console.Write(&quot;内容为&quot;+charArray);</span><br></pre></td></tr></table></figure><h2 id="获取文件系统信息"><a href="#获取文件系统信息" class="headerlink" title="获取文件系统信息"></a>获取文件系统信息</h2><h3 id="获取文件信息（FileInfo）"><a href="#获取文件信息（FileInfo）" class="headerlink" title="获取文件信息（FileInfo）"></a>获取文件信息（FileInfo）</h3><p>这个类提供有关文件操作的相关操作，比如删除，移动，打开文件等，需要实例化才可以使用。使用这个类可以编写类似文件管理器之类的程序（这就作为这章的作业吧）。以下为常用的属性方法<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-20/21210786.jpg" alt="image"><br>简单示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String filepath=@&quot;C:\Program\iexplore.exe&quot;;</span><br><span class="line">FileInfo fi=new FileInfo(filepath);</span><br><span class="line">//文件大小，文件名，文件扩展名，文件完整目录，最后一个更新时间，时间操作都差不多，两个时间加起来</span><br><span class="line">fi.Length(字节)</span><br><span class="line">fi.Name;</span><br><span class="line">fi.Extension</span><br><span class="line">fi.FullName;</span><br><span class="line">fi.LastWriteTime.ToLongDateString()+fi.LastWriteTime.ToLongTimeString();</span><br><span class="line">//写文件</span><br><span class="line">using(StreamWriter sw=fi.CreateText())&#123;</span><br><span class="line">sw.WriteLine(&quot;sss&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="目录信息（DirectoryInfo）"><a href="#目录信息（DirectoryInfo）" class="headerlink" title="目录信息（DirectoryInfo）"></a>目录信息（DirectoryInfo）</h3><p>获取某个目录的信息需要用到这个类，提供了四个属性获取目录的名称、父目录和根目录等，如下</p><ul><li>Exists    判断指定路径是否存在，返回一个boolean</li><li>Name        获取目录的名称</li><li>Parent    获取指定子目录的父目录名称</li><li>Root        获取目录的根部分<br>简单示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DirectoryInfo d=new DirectoryInfo(filepath);</span><br><span class="line">//修改目录属性</span><br><span class="line">fi.Attributes=FileAttributes.ReadOnly;</span><br><span class="line">//父路径、目录创建时间、最后一次访问时间</span><br><span class="line">di.Parent;</span><br><span class="line">di.CreationTime.ToString();</span><br><span class="line">di.LastAccessTime.ToString();</span><br></pre></td></tr></table></figure></li></ul><h3 id="驱动器信息（DriveInfo）"><a href="#驱动器信息（DriveInfo）" class="headerlink" title="驱动器信息（DriveInfo）"></a>驱动器信息（DriveInfo）</h3><p>可以对计算机的驱动器进行操作，仅包含一个静态方法，GetDrives()，可以检索所有逻辑驱动器的名称，返回一个包含驱动器列表的数组。<br>提供一下相关属性</p><ul><li>AvaliableFreeSpace    指示驱动器上的可用空闲空间量</li><li>DriveFormat            指示文件系统的名称，如NTFS或者FAT32</li><li>IsReady                获取一个指示驱动器是否已准备好</li><li>Name                    获取驱动器的名称</li><li>RootDirectory            获取驱动器根目录</li><li>TotalFreeSpace        获取驱动器上的可用空闲空间总量</li><li>TotalSize                获取驱动器上存储空间的总大小</li><li>VolumeLabel        获取或设置驱动器的卷标</li><li>DriveType            驱动器类型<blockquote><p>Unknown           无法确定驱动器类型<br>Removable         可移动媒体驱动器，软盘驱动器等<br>Fixed             固定媒体驱动器，硬盘等<br>Network           网络驱动器，包括共享驱动器<br>CDROM           CDROM驱动器<br>RAM               RAM磁盘</p></blockquote></li></ul><p>简单示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DriveInfo drvInfo=new DriveInfo(&quot;C:\&quot;);</span><br><span class="line">//输出名称，卷标文件系统类型，总共空间大小</span><br><span class="line">drvInfo.Name;</span><br><span class="line">drvInfo.DriveFormat;</span><br><span class="line">drvInfo.TotalSize;</span><br></pre></td></tr></table></figure></p><h2 id="操作目录（DirectoryInfo）"><a href="#操作目录（DirectoryInfo）" class="headerlink" title="操作目录（DirectoryInfo）"></a>操作目录（DirectoryInfo）</h2><p>提供对目录信息进行获取的方法，是实例类。如果对目录操作的话需要用Directory类，这是静态类，不需要实例化即可使用。<br>创建一个可以调用Directory类的CreateDirectory（）方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static DirectoryInfo CreateDirectory(string path);</span><br><span class="line">//示例，在C盘创建一个名为MyDir的目录，输出该目录的信息</span><br><span class="line">Directory di=Directory.CreateDirectory(&quot;C:\MyDir&quot;);</span><br><span class="line">Console.Write(&quot;&#123;0&#125;目录创建成功，创建时间&#123;1&#125;&quot;,&quot;C:\&quot;,Directory.GetCreationTime(&quot;C:\MyDir&quot;));</span><br></pre></td></tr></table></figure></p><h3 id="移动和重命名目录"><a href="#移动和重命名目录" class="headerlink" title="移动和重命名目录"></a>移动和重命名目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void Move(string sourceDieName,string destDirName);</span><br></pre></td></tr></table></figure><h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void Delete(string path);</span><br><span class="line">public static void Delete(string path,bool recursive);</span><br></pre></td></tr></table></figure><p>第一个参数为删除的目录，如果不为空会抛出异常，第二个参数为true时会删除目录所有的子目录和文件，否则会抛出异常。</p><h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><p>获取指定目录下的子目录和文件，调用Directory类中的GetFiles（）方法和GetDirectories（）方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static string[] GetFiles(string path);</span><br><span class="line">public static string[] GetFiles(string path,string searchPattern);</span><br><span class="line">public static string[] GetFiles(string path,string SearchPattern,SearchOption searchOption);</span><br></pre></td></tr></table></figure></p><p>第一个参数表示目录名，执行之后会返回目录中包含的所有文件，第二个参数表示指定目录中匹配的文本名，第三个指定搜索操作包含所有子目录还是仅当前目录。<br>简单示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取C盘中所有的exe文件</span><br><span class="line">string[] fileName=Directory.GetFiles(dir,&quot;*exe&quot;);</span><br></pre></td></tr></table></figure></p><p>GetDirectories（）方法构造函数和上面一样，参数也一样。</p><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p>File.Create()创建一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static FileStream Create(string path);</span><br><span class="line">public static FileStream Create(string path,int bufferSize);</span><br><span class="line">public static FileStream Create(string path,int bufferSize,SileOptions);</span><br><span class="line">public static FileStream Create(string path,int bufferSize,SileOptions,FileSecuroty);</span><br></pre></td></tr></table></figure></p><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.Copy(path1,path2);</span><br></pre></td></tr></table></figure><h2 id="读取和写入文件"><a href="#读取和写入文件" class="headerlink" title="读取和写入文件"></a>读取和写入文件</h2><h3 id="读取文件（StreamReader）"><a href="#读取文件（StreamReader）" class="headerlink" title="读取文件（StreamReader）"></a>读取文件（StreamReader）</h3><p>提供读取文件的功能，不仅可以读取文件，还可以处理任何流信息。<br>构造函数如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public StreamReader(string path);</span><br><span class="line">public StreamReader(string path,System.Text.Encpding encoding);</span><br></pre></td></tr></table></figure></p><p>魔人编码为UTF8，不是系统的ANSI编码，UTF8可以正确处理Unicode字符并提供一个一直的结果，可以通过第二个参数选择指定编码。<br>常用方法如下</p><ul><li>Read（）    读取输入流中的下一个字符，没有可用时返回-1</li><li>ReadLine（）    读取一行字符并作为字符串返回，如果达到文件末尾则为空引用</li><li>ReadToEnd（）    从文件当前位置读取到文件末尾，如果当前为止为开头，则读取整个文件</li><li>Close（）    关闭读取并释放资源</li><li>Peek（）    返回文件的下一个字符，但是不使用，如果没有可用的字符或者文件不支持查找返回-1</li></ul><p>简单示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//选择文件并逐行显示</span><br><span class="line">StreamReader reader=new StreamReader(path,System.Text.Encoding.Default);</span><br><span class="line">while (!reader.EndOfStream)&#123;</span><br><span class="line">this.textBpx1.Text+=reader.ReaderLine()+&quot;\r\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">reader.Close();</span><br></pre></td></tr></table></figure></p><h3 id="写入文件（StreamWriter）"><a href="#写入文件（StreamWriter）" class="headerlink" title="写入文件（StreamWriter）"></a>写入文件（StreamWriter）</h3><p>写入文件的前提是具有文件的写入权限。<br>写入文件的步骤为：先实例化一个StreamWriter对象，调用它的方法将字符流写入文件中，最后调用Close（）保存写入的字符并释放资源。<br>构造函数如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public StreamWriter(Stream stream);</span><br><span class="line">public StreamWriter(string path);</span><br><span class="line">public StreamWriter(string path,System.Text.Encoding encoding);</span><br><span class="line">public StreamWriter(string path,bool append,System.Text.Encoding encoding);</span><br></pre></td></tr></table></figure></p><p>如果文件不存在则会自动创建新文件，bool append决定是改写文件还是追加文件。<br>常用方法</p><ul><li>Write（）    字符串写入文件</li><li>WriteLine（）    项文件写入一行字符串，即写入换行符</li><li>Flush（）        清理当前缓冲区，将缓冲区的数据写入文件</li><li>Close（）    关闭写入刘并释放资源，即保存文件</li></ul><p>简单示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//以打开方式创建实例</span><br><span class="line">FileStream fs=new FileStream(filepath,System.IO.FileMode.Open);</span><br><span class="line">//以默认编码创建StreamWriter实例</span><br><span class="line">StreamWriter bw=new StreamWriter(fs,System.Text.Encoding.Default);</span><br><span class="line">bw.Write(this.textbox1.Text);</span><br><span class="line">bw.Write(&quot;\r\n&quot;);</span><br><span class="line">bw.Close();</span><br></pre></td></tr></table></figure></p><h2 id="二进制文件的读写"><a href="#二进制文件的读写" class="headerlink" title="二进制文件的读写"></a>二进制文件的读写</h2><p>BinaryWriter和BinaryReader类。<br>自己去学吧，我不玩。</p><p>写的一个小案例是磁盘文件扫描系统，GUI是Winform。<br>有一个小BUG，就是线程进行的时候用Abort()停不下来，不能结束线程，只能处于挂起状态，除非彻底关闭应用程序才可以，但是不影响使用应该，点击开始总是会新建一个线程，但是不知道会不会覆盖原来的线程，如果不会的话就不能开太多，不然内存就大了<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-22/99644448.jpg" alt="image"></p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上次写还是差不多两周前了，最近也不知道在干什么。先吐槽这个该死的迅雷的下载机制，一下载东西我的电脑就卡，我还不想限速，只能看ppt了。最近还想着再把Java看一看，C#再深入一点然后直接去攻前端，用Java做后端。&lt;br&gt;这次说这个流，流这个东西很常见，Java里经常用到，
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
      <category term="流" scheme="https://bluerbk.top/tags/%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>C#基础伪教程（四）内置类</title>
    <link href="https://bluerbk.top/2018/04/07/CSharp-Forth-Teaching/"/>
    <id>https://bluerbk.top/2018/04/07/CSharp-Forth-Teaching/</id>
    <published>2018-04-06T16:53:09.000Z</published>
    <updated>2018-04-07T06:43:53.572Z</updated>
    
    <content type="html"><![CDATA[<p>有十来天没有写了，继续上次的摊子写，这次是C#的内置类编程，也就是一些实用的封装好了的方法类，主要有五个，分别是String类、StringBuilder类、日期和时间处理类、Regex类和Thread类，这是实际开发中最常用的五个类，下面就各个类依次讲解。</p><h2 id="String类字符串"><a href="#String类字符串" class="headerlink" title="String类字符串"></a>String类字符串</h2><p>String类位于System命名空间里，使用sealed关键字修饰,所以不能被继承，但是String类里提供了大量字符串操作方法可供使用。</p><h3 id="创建一个字符串变量"><a href="#创建一个字符串变量" class="headerlink" title="创建一个字符串变量"></a>创建一个字符串变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str=&quot;hello,C#&quot;;</span><br></pre></td></tr></table></figure><p>String也就是一个字符串数组，同样可以用下标来访问对应元素。<br>除了以上方法创建字符串，还提供了八个构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public String(char* value);</span><br><span class="line">//将String类的新实例初始化为由指向Unicode字符数组的指定指针指示的值</span><br><span class="line">public String(char[] value);</span><br><span class="line">//将String类的新实例初始化为由Unicode字符数组指示的值</span><br><span class="line">public String(sbyte* value);</span><br><span class="line">//将String类的新实例初始化为由指向8位有符号整数数组的指针指示的值</span><br><span class="line">public String(char c,int count);</span><br><span class="line">//将String类的新实例初始化为由重复指定次数的指定Unicode字符指示的值</span><br><span class="line">public String(char* value,int startIndex,int length);</span><br><span class="line">//将String类的新实例初始化为由指定Unicode字符数组的指定指针、该数组内的起始字符位置和一个长度指示的值</span><br><span class="line">public String(char[] value,int startIndex,int length);</span><br><span class="line">//将String类的新实例初始化为由指定Unicode字符数组、该数组内的起始字符位置和一个长度指示的值</span><br><span class="line">public String(sbyte* value,int startIndex,int length);</span><br><span class="line">//将String类的新实例初始化为由指向8位有符号整数数组的指针指示、该数组内的起始字符位置和一个长度指示的值</span><br><span class="line">public String(sbyte* value,int startIndex,int length,Encoding enc);</span><br><span class="line">//将String类的新实例初始化为由指向8位有符号整数数组的指针指示、该数组内的起始字符位置、长度和Encoding对象指示的值</span><br></pre></td></tr></table></figure></p><p>简单示例如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char[] charStr=&#123;&apos;明&apos;,&apos;天&apos;,&apos;会‘，’更&apos;,&apos;好&apos;&#125;;</span><br><span class="line">string str=&quot;春夏秋冬&quot;;</span><br><span class="line">string str-=str;</span><br><span class="line">string str1=new string(charStr);</span><br><span class="line">string str2=new string(charStr,2,3);</span><br><span class="line">string str3=new string(&quot;*&quot;,10);</span><br><span class="line">//str0、str1、str2、str3的值分别为</span><br><span class="line">//春夏秋冬、明天更美好、更美好，**********</span><br></pre></td></tr></table></figure></p><h3 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public string ToUpper();</span><br><span class="line">public string ToLower();</span><br></pre></td></tr></table></figure><p>对string字符串直接调用方法即可，如str.ToUpper();</p><h3 id="除去空格和特定字符"><a href="#除去空格和特定字符" class="headerlink" title="除去空格和特定字符"></a>除去空格和特定字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Trim()</span><br><span class="line">//去除字符串前后空白</span><br><span class="line">TrimStart()</span><br><span class="line">//从字符串开始位置删除空白字符或指定字符</span><br><span class="line">TrimEnd()</span><br><span class="line">//从字符串结尾删除空白字符或指定字符</span><br></pre></td></tr></table></figure><p>括号里不带参数则除去空白字符，若带字符参数则删除指定字符。</p><h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Concat();</span><br><span class="line">//参数直接为需要链接的多个字符串</span><br><span class="line">join(a,b,c,d);</span><br><span class="line">//join()方法可以将指定字符串数组中的所有字符串链接在一起，a为链接的间隔符，间隔为空白，斜杠等，b为字符串数组，c为起始下标，d为链接字符的个数</span><br></pre></td></tr></table></figure><h3 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h3><p>String类的Replace()方法可以替换字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string Replace(char oldchar,char newchar);</span><br><span class="line">//将字符串中指定的字符替换为新的字符</span><br><span class="line">string Replace(string oldvalue,string newvalue);</span><br><span class="line">//将字符串中指定的字符串替换为新的字符串</span><br></pre></td></tr></table></figure></p><h3 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h3><p>可以直接使用“==”进行比较，看两个字符串是否相等，也可以使用Equals(),Contains(),Compare()和CompareTo()函数</p><h4 id="Equals"><a href="#Equals" class="headerlink" title="Equals()"></a>Equals()</h4><p>方法构造函数如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public override bool Equals(object obj);</span><br><span class="line">public bool Equals(string value);</span><br><span class="line">public static bool Equals(string a,string b);</span><br><span class="line">public bool Equals(string value,StringComparison comparisonType);</span><br><span class="line">public static bool Equals(string a,string b,StringComparison comparisonType);</span><br></pre></td></tr></table></figure></p><p>在比较的时候区分大小写，返回值为bool的时候，返回true表示相等，false表示不等。</p><h4 id="Contains"><a href="#Contains" class="headerlink" title="Contains()"></a>Contains()</h4><p>用于确认某个字符串中是否包含另一个字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public bool Contains(string value);</span><br></pre></td></tr></table></figure></p><p>返回bool型，若value在该字符串中则返回true，否则返回false。</p><h4 id="Compare-和CompareTo"><a href="#Compare-和CompareTo" class="headerlink" title="Compare()和CompareTo()"></a>Compare()和CompareTo()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1.CompareTo(str2);</span><br><span class="line">string.Compare(str1,str2);</span><br></pre></td></tr></table></figure><p>均为比较两个字符串</p><blockquote><p>str1&gt;str2      返回1<br>str1==str2     返回0<br>str1&lt;str2      返回-1<br>两者均实现了方法重载，在此列出比较实用的几个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compare(str1,index1,str2,index2,length,boolean);</span><br></pre></td></tr></table></figure></p></blockquote><p>index1和index2为响应整数偏移量，length表示比较的字符串字符的最大数量，boolean表示是否忽略大小写。</p><h3 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h3><p>相关方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IndexOf(str);</span><br><span class="line">//返回子字符串或字符串中第一次出现的索引位置.若没找到返回-1</span><br><span class="line">IndexOfAny(str);</span><br><span class="line">//返回子字符串或部分匹配第一次出现的索引位置，若没找到返回-1</span><br><span class="line">LastIndexOf(str);</span><br><span class="line">//返回指定子字符串的最后一个索引位置，如果没有找到返回-1</span><br><span class="line">LastIndexOfAny(str);</span><br><span class="line">//返回指定子字符串或部分匹配的最后一个位置，如果没有找到子字符串返回-1</span><br><span class="line">StartsWith(str);</span><br><span class="line">//判断字符串是否已制定子字符串开始，返回值为true或false</span><br><span class="line">EndsWith(str);</span><br><span class="line">//判断字符串是否以指定子字符串结束，返回值为true或false</span><br></pre></td></tr></table></figure></p><h3 id="分隔字符串"><a href="#分隔字符串" class="headerlink" title="分隔字符串"></a>分隔字符串</h3><p>C#中实现分隔字符串使用System类中的Split()方法，这和Java很类似，有以下构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string[] Split(params char[] separator);</span><br><span class="line">string[] Split(char[] separator,int count);</span><br><span class="line">string[] Split(char[] separator,StringSplitOptions options);</span><br><span class="line">string[] Split(string[] separator,StringSplitOptions options);</span><br><span class="line">string[] Split(char[] separator,int count,StringSplitOptions options)</span><br><span class="line">string[] Split(string[] separator,int count,StringSplitOptions options);</span><br></pre></td></tr></table></figure></p><p>separator表示需要分隔的字符或字符串数组，count表示返回的字符串最大数量，options表示分隔选项，是一个枚举类型，主要有以下两个值<br>System.StringSplitOptions.RemoveEmptyEntries  省略返回的空数组<br>System.StringSplitOptions.None  包含返回的空数组<br>例如，分隔如下字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char[] separator=&#123;&apos;,&apos;,&apos;|&apos;,&apos;/&apos;&#125;;</span><br><span class="line">string str=...;</span><br><span class="line">str.Split(separator);</span><br></pre></td></tr></table></figure></p><h3 id="截取子字符串"><a href="#截取子字符串" class="headerlink" title="截取子字符串"></a>截取子字符串</h3><p>使用String类中的Substring()方法，有以下两个重载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Substring(int index1);</span><br><span class="line">String Substring(int index1,int index2);</span><br></pre></td></tr></table></figure></p><p>很显然，分别为从指定位置开始截取和从指定位置截取指定字符数的字符串。</p><h3 id="移除字符串"><a href="#移除字符串" class="headerlink" title="移除字符串"></a>移除字符串</h3><p>使用String类中的Remove()方法，该方法有以下两个重载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public string Remove(int startindex);</span><br><span class="line">public string Remove(int startindex,int count);</span><br></pre></td></tr></table></figure></p><p>同样，分别为从指定位置开始删除和从指定位置删除特定字符数的字符串。</p><p>##StringBuilder类字符串<br>String类的字符串内容是不可变的，每次使用ystem.String类中的方法的时候都需要创建一个新的字符串对象，这就需要重新分配控件，因此在对字符串进行重复修改等操作的时候，与创建新的String对象相关的系统开销可能会十分昂贵。因此可以使用System.Text.StringBuilder类，在修改字符串的时候不必创建新的对象，可以提升性能。<br>StringBuilder提供以下六个构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder();</span><br><span class="line">//初始化一个空的StringBuilder实例</span><br><span class="line">public StringBuilder(int capacity);</span><br><span class="line">//使用指定容量初始化StringBuilder新实例</span><br><span class="line">public StringBuilder(string value);</span><br><span class="line">//使用指定字符串初始化StringBuilder类的新实例</span><br><span class="line">public StringBuilder(int capacity,int maxCapacity);</span><br><span class="line">//吃石化StringBuilder实例，该类起始于指定容量并可增长到最大容量</span><br><span class="line">public StringBuilder(string value,int capacity);</span><br><span class="line">//使用指定字符串和容量初始化StringBuilder类的新实例</span><br><span class="line">public StringBuilder(string value,int startIndex,int length,int capacity);</span><br><span class="line">//用指定的子字符串和容量初始化StringBuilder类的新实例。</span><br></pre></td></tr></table></figure></p><h3 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h3><p>可以再指定位置插入特定的字符数字或字符串等内容。使用StringBuilder类中的Insert()方法实现，该方法提供<strong>18</strong>个重载，<strong>几乎可以将任意类型的值插入到字符串的指定位置，</strong>以下列出常用的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Insert(int index,double value);</span><br><span class="line">Insert(int index,string value);</span><br><span class="line">Insert(int index,char value);</span><br><span class="line">Insert(int index,bool value);</span><br><span class="line">//将布尔型的表现形式插入到指定位置</span><br><span class="line">Insert(int index,int value);</span><br><span class="line">Insert(int index,string value,int count);</span><br><span class="line">//将指定字符串的一个或多个副本插入到指定位置</span><br></pre></td></tr></table></figure></p><h3 id="追加字符串"><a href="#追加字符串" class="headerlink" title="追加字符串"></a>追加字符串</h3><p>StringBuilder类提供了以下方法追加字符串</p><blockquote><p>Append()<br>AppendLine()        在追加的字符串后再加一个换行符<br>AppendFormat()      先格式化被追加字符串，再将其追加到字符串末尾</p></blockquote><h4 id="Append-方法"><a href="#Append-方法" class="headerlink" title="Append()方法"></a>Append()方法</h4><p>Append()方法提供了19个重载，几乎可以追加任何类型的值，以下列出常用的几个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Append(double value);</span><br><span class="line">Append(string value);</span><br><span class="line">Append(char value);</span><br><span class="line">Append(bool value);</span><br><span class="line">//将布尔型的表现形式追加到指定位置</span><br><span class="line">Append(int value);</span><br><span class="line">Append(string value,int index,int count);</span><br><span class="line">//在实例结尾处追加指定字符串的副本</span><br></pre></td></tr></table></figure></p><h4 id="AppendLine-方法"><a href="#AppendLine-方法" class="headerlink" title="AppendLine()方法"></a>AppendLine()方法</h4><p>在Append()方法基础上，每次追加一个换行符，有以下两个重载</p><blockquote><p>AppendLine()   默认追加换行符（行终止符）。<br>AppendLine(string value)  将后面跟有默认换行符的指定字符串副本追加到当前对象末尾</p></blockquote><h4 id="AppendFormat-方法"><a href="#AppendFormat-方法" class="headerlink" title="AppendFormat()方法"></a>AppendFormat()方法</h4><p>我不想写了，有用的话自己百度吧。</p><h3 id="移除字符串-1"><a href="#移除字符串-1" class="headerlink" title="移除字符串"></a>移除字符串</h3><p>同样适用Remove()方法<br>public StringBuilder Remove(int startIndex,int length);<br>从指定位置删除指定字符数的字符串。</p><h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><p>这个功能其实挺有用的，比如敏感词汇，密码什么的，适用Replace()，这个方法String和StringBuilder里都可以用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder Replace(char oldChar,char newChar);</span><br><span class="line">public StringBuilder Replace(string oldValue,string newValue);</span><br><span class="line">public StringBuilder Replace(char oldChar,char newChar,int startIndex,int count);</span><br><span class="line">public StringBuilder Replace(string oldValue,string newValue,int startIndex,int count);</span><br></pre></td></tr></table></figure></p><h3 id="StringBuilder的其他常用方法"><a href="#StringBuilder的其他常用方法" class="headerlink" title="StringBuilder的其他常用方法"></a>StringBuilder的其他常用方法</h3><p>Equals()，若相等，则返回true否则false。<br>EnsureCapacity()，保证StringBuilder有最小指定容量。<br>ToString()，将实例转为String类型。<br>ToString(int startIndex,int length),将制定子字符串转为String类型。</p><h2 id="时间和日期的处理"><a href="#时间和日期的处理" class="headerlink" title="时间和日期的处理"></a>时间和日期的处理</h2><p>.NET Framework提供了DateTime结构和TimeSpan结构。</p><h3 id="TimeSpan结构"><a href="#TimeSpan结构" class="headerlink" title="TimeSpan结构"></a>TimeSpan结构</h3><p>表示时间间隔或持续时间，按正负天数，小时数，分钟数，秒数以及秒的小数部分进行度量，最大单位为天。TimeSpan的值等于所表示的时间间隔的刻度值，<strong>一个刻度为100ns</strong>，TimeSpan对象的值范围是MinValue和MaxValue之间。<br>TimeSpan值表示时间形式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-]d.hh:mm:ss.ff</span><br></pre></td></tr></table></figure></p><p>[-]可选，表示负时间间隔。<br>可以自行设置时间，构造函数如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public TimeSpan(long ticks);</span><br><span class="line">public TimeSpan(int hours,int minutes,int seconds,int millisconds);</span><br><span class="line">public TimeSpan(int days,int hours,int minutes,int seconds);</span><br><span class="line">public TimeSpan(int days,int hours,int minutes,int seconds,int millisconds);</span><br></pre></td></tr></table></figure></p><p>TimeSpan包含八个静态字段，三个只读字段和五个常数字段</p><blockquote><p>MaxValue  最大TimeSpan值<br>MinValue  最小TimeSpan值<br>Zero      零TimeSpan值<br>TicksPerDay 一天的刻度值<br>TicksPerHour 一小时的刻度值<br>TicksPerMillisecond 一毫秒的刻度值<br>TicksPerMinute 一分钟的刻度值<br>TicksPerSecond 一秒钟的刻度值<br>例如，TimeSpan.TicksPerSecond；输出为10000000.<br>TimeSpan有以下11个属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Days  获取TimeSpan结构所表示的时间间隔的天数</span><br><span class="line">Hours 获取TimeSpan结构所表示的时间间隔的小时</span><br><span class="line">Milliseconds 获取TimeSpan结构所表示的时间间隔的毫秒数</span><br><span class="line">Minutes 获取TimeSpan结构所表示的时间间隔的分钟数</span><br><span class="line">Seconds 获取TimeSpan结构所表示的时间间隔的秒数</span><br><span class="line">Ticks 获取当前结构的刻度值</span><br><span class="line">TotalDays 获取以整天数和天的小数部分表示当前TimeSpan结构的值</span><br><span class="line">...以此类推</span><br></pre></td></tr></table></figure></p></blockquote><p>TimeSpan有以下几个静态方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Compare()</span><br><span class="line">//比较两个TimeSpan的值，返回职位1、0或-1</span><br><span class="line">Equals()</span><br><span class="line">//判断两个值是否相等，相等为true，否则为false</span><br><span class="line">FromDays()</span><br><span class="line">//根据指定天数创建一个TimeSpan()实例</span><br><span class="line">...以此类推</span><br><span class="line">fROMtICKS()</span><br><span class="line">//根据刻度值创建TimeSpan实例</span><br><span class="line">Parse()</span><br><span class="line">//将时间间隔字符串转换为TimeSpan</span><br><span class="line">ParseExact()</span><br><span class="line">//将时间间隔字符串转换为TimeSpan，该字符串格式必须与指定格式一样。</span><br><span class="line">TryParse()</span><br><span class="line">//将时间间隔字符串转换为TimeSpan，并返回是否成功。</span><br><span class="line">TryParseExact()</span><br><span class="line">//将时间间隔字符串转换为TimeSpan，该字符串格式必须与指定格式一样，并返回是否成功。</span><br></pre></td></tr></table></figure></p><p>TimePare有以下几个实例方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Add()</span><br><span class="line">//将指定TimeSpan添加到实例中</span><br><span class="line">CompareTo()</span><br><span class="line">//将该实例与指定TimeSpan进行比较，返回-1、0或1</span><br><span class="line">Duration()</span><br><span class="line">//返回新的TimeSpan值，为当前对象绝对值</span><br><span class="line">GetHashCode()</span><br><span class="line">//返回该实例的哈希代码</span><br><span class="line">GetType()</span><br><span class="line">//返回该实例的Type</span><br><span class="line">Subtract()</span><br><span class="line">//从实例中减去指定TimeSpace</span><br><span class="line">ToString()</span><br><span class="line">//将该实例转换为等效字符串</span><br></pre></td></tr></table></figure></p><h2 id="DateTime结构"><a href="#DateTime结构" class="headerlink" title="DateTime结构"></a>DateTime结构</h2><p>这个鬼东西好多啊，我不想写了，突然想到我可以放图，我太机智了。<br>感觉今天外网流量要爆炸了。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/64258603.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/65463394.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/57836720.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/99053848.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/82907543.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/93081528.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/71306301.jpg" alt="image"></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>这是个好东西，真的，好东西。好好写一写。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h4><p>用于检查一个字符串是否包含欧中字符串，如[-a-z]与”abc-“匹配，和”123”不匹配。匹配含义如下表所示。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/53602044.jpg" alt="image"><br>用于排除字符的常规用法</p><ul><li>[^0-9]匹配除数字以外的所有字符</li><li>[^a-z]匹配除小写字母以外的所有字符</li><li>[^A-Z]匹配除大写字母以外的所有字符</li><li>[^\\/\^]匹配除’\’、’/‘和’^’以外的所有字符</li><li>[^\”\’]匹配除双引号和单引号以外的所有字符<h4 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h4>比如一个单词重复出现多次，可以用{}确定次数。语法如下。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/44923244.jpg" alt="image"><br>示例如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\a&#123;3&#125;</span><br><span class="line">//匹配\a\a\a，不匹配\a\a\a\d或者\a</span><br><span class="line">\a&#123;1,3&#125;</span><br><span class="line">//匹配\a、\a\a\a、\a\a，不匹配\a\a\a\a</span><br><span class="line">5?</span><br><span class="line">//匹配5或0，不匹配非5和0</span><br><span class="line">\S+</span><br><span class="line">//匹配一次以上\S</span><br><span class="line">\W*</span><br><span class="line">//匹配0次以上\W，不匹配非N*\W</span><br></pre></td></tr></table></figure></li></ul><h4 id="字符定位"><a href="#字符定位" class="headerlink" title="字符定位"></a>字符定位</h4><p>定位字符所代表的是一个虚的字符，代表一个位置，可以直观认为定位字符所代表的的是某个字符与字符之间的间隙，语法如下所示。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/15680158.jpg" alt="image"></p><h4 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配"></a>转义匹配</h4><p>转义匹配的工作方式与C#的转义序列相同，如下表所示<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/59736449.jpg" alt="image"></p><h2 id="Regex类的使用"><a href="#Regex类的使用" class="headerlink" title="Regex类的使用"></a>Regex类的使用</h2><p>在System.Text.RegularExpression命名空间中提供了包含Regex在内的8个正则表达式类<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/3400987.jpg" alt="image"><br>主要说明Regex，常用的三个方法，IsMatch(),Replace(),Split()和Match()</p><h4 id="IsMatch"><a href="#IsMatch" class="headerlink" title="IsMatch()"></a>IsMatch()</h4><p>对字符串进行正则匹配验证，满足返回true，否则false。<br>例如，首先定义正则表达式字符串<br>在调用方法进行验证输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string regex=@&quot;([0-9]&#123;4&#125;)-([0-9]&#123;1,2&#125;)-([0-9]&#123;1,2&#125;)&quot;;</span><br><span class="line">Console.WriteLine(Regex.IsMatch(str,regex));</span><br></pre></td></tr></table></figure></p><h4 id="Replace"><a href="#Replace" class="headerlink" title="Replace()"></a>Replace()</h4><p>使用指定字符串替换原始字符串中满足正则表达式的部分。<br>例如，替换多个空白和空格，统一使用空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string input=&quot;北    京 欢 迎   你&quot;;</span><br><span class="line">string pattern=&quot;\\s+&quot;;</span><br><span class="line">string replacement=&quot; &quot;;</span><br><span class="line">Regex rgx=new Regex(pattern);</span><br><span class="line">string result=rgx.Replace(input,replacement);</span><br></pre></td></tr></table></figure></p><h4 id="Split"><a href="#Split" class="headerlink" title="Split()"></a>Split()</h4><p>用正则表达式拆分字符串，根据匹配的正则表达式把原始字符串匹配的字符拆分保存到数组中。<br>某个字符串用短横线分隔，输出每一项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Regex regex=new Regex(&quot;-&quot;);</span><br><span class="line">string[] substrings=regrex.Split(&quot;ouda-dsa-sda-asdsa-as&quot;);</span><br><span class="line">//输出substrings即可</span><br></pre></td></tr></table></figure></p><h4 id="Match"><a href="#Match" class="headerlink" title="Match()"></a>Match()</h4><p>获取字符串中第一个与正则表达式匹配的项，返回结果是一个Match()类型。<br>不写了不写了，赶紧传点图搞定得了，这个文章我抄的太厉害了，没有消化多少，不过也没办法，这种全是概念的东西就这样。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/36246568.jpg" alt="image"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>快收尾快收尾<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/57484447.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/13340599.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/55181118.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/92830885.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/49363060.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/89948119.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/39340201.jpg" alt="image"><br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-4-7/7564338.jpg" alt="image"></p><hr><p>就这样吧，这个文章真的一点用也没有，浪费了好多时间，下次写GUI设计，要好好学了，不能这样没水分的抄了。over。</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有十来天没有写了，继续上次的摊子写，这次是C#的内置类编程，也就是一些实用的封装好了的方法类，主要有五个，分别是String类、StringBuilder类、日期和时间处理类、Regex类和Thread类，这是实际开发中最常用的五个类，下面就各个类依次讲解。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>C#基础伪教程（三）</title>
    <link href="https://bluerbk.top/2018/03/25/CSharp-Third-Teaching/"/>
    <id>https://bluerbk.top/2018/03/25/CSharp-Third-Teaching/</id>
    <published>2018-03-25T11:48:38.000Z</published>
    <updated>2018-03-25T14:29:09.008Z</updated>
    
    <content type="html"><![CDATA[<p>现在说一说关于枚举，很久之前才C语言里面用过一点点，但是没有深入，C#学习之后想真正深入一下，就得好好学习。枚举是一个被命名的整型常数集合，如一周只能为周一到周日等，只有固定的几种取值的时候可以定义为枚举。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>所谓枚举是将变量值一一列举出来，变量取值仅限于列举出来的值的范围内。<br>C#的枚举属于值类型，而且所有枚举都派生字System.Enum类，而值类型都继承于System.ValueType类，派生于该类的不一定全是值类型，枚举是唯一的例外。</p><h4 id="枚举的好处"><a href="#枚举的好处" class="headerlink" title="枚举的好处"></a>枚举的好处</h4><blockquote><p>枚举使代码更易于维护，有助于确保给变量指定合法的、期望的值。<br>枚举使代码更加清晰，允许用描述性的名称表示整数值，而不用含义模糊的数来表示。</p></blockquote><h4 id="枚举的特点体现"><a href="#枚举的特点体现" class="headerlink" title="枚举的特点体现"></a>枚举的特点体现</h4><blockquote><p>枚举不能继承其他的类，也不能被其他的类继承。<br>枚举类型实现了IComparable接口，可以实现多个接口。<br>枚举类型只能拥有私有构造器。<br>枚举类型中成员的访问修饰符是public static final。<br>枚举类型中成员列表名称是区分大小写的。</p></blockquote><h3 id="声明枚举"><a href="#声明枚举" class="headerlink" title="声明枚举"></a>声明枚举</h3><p>使用关键字enum进行声明，还需要定义枚举的名称、访问修饰符和类型等。具体用法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] enum 枚举类型 [:类型]&#123;</span><br><span class="line">标识符[=整型常数],</span><br><span class="line">...</span><br><span class="line">标识符[=整型常数],</span><br><span class="line">标识符[=整型常数]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上述各部分含义如下</p><ul><li>枚举类型修饰符为public、private或internal，默认为public。</li><li>枚举名称必须符合C#标识符定义规则。</li><li>枚举类型可以使byte、short、sbyte、ushort、int、unit、long或ulong，默认为int。</li><li>整型常数必须符合枚举类型。<br>如下创建一个四季的枚举类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Season:int&#123;</span><br><span class="line">Spring=0,</span><br><span class="line">Summer=1,</span><br><span class="line">Autumn,</span><br><span class="line">Winter=2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>可以指定整型常数，如果都不指定，默认第一个元素为0，后一个元素的值总是第一个元素的值加1，如Autumn和Winter均为2。</p><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>以一个具体的代码来示例，枚举类型就用上面的Season<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Season se;</span><br><span class="line">se=Season.Spring;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="枚举类型的转换"><a href="#枚举类型的转换" class="headerlink" title="枚举类型的转换"></a>枚举类型的转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//成员对应的数字</span><br><span class="line">Console.WriteLine((Season)Spring);</span><br><span class="line">Console.WriteLine((int)Season.Winter);</span><br><span class="line">//输出0</span><br><span class="line">//输出2</span><br><span class="line">//数字对应的成员</span><br><span class="line">Console.WriteLine((Season)1);</span><br><span class="line">//输出Summer</span><br></pre></td></tr></table></figure><h3 id="枚举的相关方法"><a href="#枚举的相关方法" class="headerlink" title="枚举的相关方法"></a>枚举的相关方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enum.GetName(typeof(Season),1);</span><br><span class="line">(Season)Enum.Parse(typeof(Season),&quot;Spring&quot;,true);</span><br><span class="line">(Season)Enum.Parse(typeof(Season),3,true);</span><br><span class="line">//以下两个方法可用于遍历，如foreach语句里</span><br><span class="line">Enum.GetName(typeof(Season));</span><br><span class="line">Enum.GetValues(typeof(Season));</span><br></pre></td></tr></table></figure><p>Parse()方法有三个参数，第一个数枚举类型，第二个是要转换的字符串，第三个true是忽略大小写。该方法返回的是一个引用，需要强制类型转换。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>结构和类很相似，都可以表示包含数据成员和函数成员的数据结构，但是结构是一种值类型，不用堆分配。<br>结构派生System.ValueType类，适用于具有值语义的小的数据结构，比如平面世界的点，几何世界的一个边，一个矩形等，都是少量数据成员，不要求使用继承或引用表示，而且他们适合值语义（赋值的时候直接复制值，而不是复制引用）方便地实现。<br>结构和类的区别如下</p><ul><li>结构是值类型，而类是引用类型。</li><li>结构早栈中分配空间，类在堆中分配空间。</li><li>在结构中所有成员默认为public修饰符，类中默认为private。</li><li>结构支持构造函数，但无构造函数不能自定义，类可以。</li><li>结构不支持析构函数，类支持。</li><li>在结构中不对成员进行初始化操作，类可以。</li><li>结构派生自System.ValueType，类派生自System.Object。</li><li>结构不支持继承，也不能被继承，类可以。</li><li>结构可以不用new初始化，类必须要用类初始化。<br>结构和类在使用时有很多区别，因此实际编程时应遵循以下规则使用结构还是类</li><li>堆栈空间有限，对于大量的逻辑对象，创建类比创建结构好。</li><li>大多数情况下该类型只是一些数据时，结构是最好的选择，否则创建类。</li><li>在表现抽象或者多层次的数据时，类是最好的选择。</li><li>如果该类型不继承自任何类型时使用结构，否则使用类。</li><li>该类型的实例不会被频繁用于集合中时使用结构，否则使用类。<h3 id="声明结构"><a href="#声明结构" class="headerlink" title="声明结构"></a>声明结构</h3>C#中声明一个结构用关键字struct，语法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] struct 结构名称 [接口]&#123;</span><br><span class="line">结构体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>上述语法主要参数含义：</p><ol><li>修饰符主要为public、private、internal、protected或new，默认为public。</li><li>结构名称必须符合C#标识符定义规则。</li><li>接口是可选参数。结构可以实现接口，但是不能从另一个结构或者类继承，而且不能作为一个类的基类。</li><li>结构体包括数据成员和成员函数，它们不能使用protected或protected internal修饰符，也不能使用abstract或sealed修饰符。<br>简单示例代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Point&#123;</span><br><span class="line">public int X&#123;get;set;&#125;</span><br><span class="line">public int Y&#123;get;set;&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Student&#123;</span><br><span class="line">public int ID;</span><br><span class="line">public string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="结构的使用"><a href="#结构的使用" class="headerlink" title="结构的使用"></a>结构的使用</h3><p>结构成员分为两类：数据成员和成员函数以及类型。<br>数据成员包括常量和字段。函数成员包括属性、方法、事件、索引器、运算符以及构造函数。具体如下：</p><ul><li>常量：表示常量的值。</li><li>字段：结构中声明的变量。</li><li>属性：用于访问对象或结构特性的成员。</li><li>方法：包含一系列语句的代码块，通过这些代码能够实现预先定义的计算或操作。</li><li>事件：一种使对象或结构能够提供通知的成员。</li><li>索引器：又被称为含参属性，是一种含有参数的属性，提供以索引的方式访问对象。</li><li>运算符：通过表达式运算符可以对该结构体的实例进行运算。</li><li>构造函数：包括静态构造函数和实例构造函数。静态构造函数用static修饰，实例构造函数不必static。<br>简单代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct Time&#123;</span><br><span class="line">public bool off;</span><br><span class="line">private int hour,minute,second;</span><br><span class="line">public Time(int h,int m,int s)&#123;</span><br><span class="line">this.h=h;</span><br><span class="line">this.s=s;</span><br><span class="line">this.m=m;</span><br><span class="line">this.off=false;</span><br><span class="line">&#125;</span><br><span class="line">public int Hour&#123;</span><br><span class="line">get&#123;return this.hour;&#125;</span><br><span class="line">set&#123;</span><br><span class="line">if (value &gt;= 0&amp;&amp; value &lt;= 23)</span><br><span class="line">this.hour=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public int Minute&#123;</span><br><span class="line">get&#123;return this.minute;&#125;</span><br><span class="line">set&#123;</span><br><span class="line">if (value&gt;=0&amp;&amp;value&lt;=59)</span><br><span class="line">this.minute=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public int Second&#123;</span><br><span class="line">get&#123;return this.second;&#125;</span><br><span class="line">set&#123;</span><br><span class="line">if (value&gt;=0&amp;&amp;value&lt;=59)</span><br><span class="line">this.second=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void Show()&#123;</span><br><span class="line">string s=&quot;&quot;;</span><br><span class="line">if (off)&#123;</span><br><span class="line">s=this.hoir&gt;12?&quot;PM&quot;:&quot;AM&quot;;</span><br><span class="line">this.hour=this.hour&gt;12?this.hour-12:this.hour;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(&quot;当前时间是：&#123;0&#125;时&#123;1&#125;分&#123;2&#125;秒&#123;3&#125;&quot;,this.hour,this.minute,this.second,s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以下是简单应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)&#123;</span><br><span class="line">Time t1=new Time();</span><br><span class="line">t1.hour=19;</span><br><span class="line">t1.minute=32;</span><br><span class="line">t1.second=50;</span><br><span class="line">t1.Show();</span><br><span class="line"></span><br><span class="line">Time t2=new Time(10,15,58);</span><br><span class="line">t2.Show();</span><br><span class="line"></span><br><span class="line">Time t3=new Time(23,4,27);</span><br><span class="line">t3.off=true;</span><br><span class="line">t3.Show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>和类一样，接口也定义了一系列属性、方法和事件。不同的是接口不提供实现，由类去实现，从类中被定义为单独的实体。接口表示一种约定。<br>C#中的接口和雷一样都属于引用类型，用来描述属于类或结构的一组相关功能，即定义了一种协议或者规范和标准。使用借接口注意以下几点：</p><ol><li>接口中只能包含属性、方法、事件和索引器，但是都不能够实现。</li><li>接口名称通常是以”I”开头的，例如IList，IComparable。</li><li>实现一个接口的语法和继承类似，如class Person ： IPerson。</li><li>通常都称继承了一个类，实现了一个接口。</li><li>如果累已经继承了一个父类，以逗号”,”分隔父类和接口。<h3 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名称&#123;</span><br><span class="line">接口主体</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></li></ol><p>上述语法主要参数如下：</p><ol><li>接口的修饰符包括private，public，protected，internal和new，默认为public。</li><li>接口名称必须符合C#标识符的定义规则。</li><li>接口的主体是接口的详细定义，可以包括属性、方法以及事件等。<br>如下为一个简单示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ISubject&#123;</span><br><span class="line">//接口代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="定义接口成员"><a href="#定义接口成员" class="headerlink" title="定义接口成员"></a>定义接口成员</h3><p>接口成员可以是方法、属性、索引器或者事件，而不能包括常量、字段、运算符、构造函数、析构函数或类型等，也不能包含任何类的静态成员。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IProduct&#123;</span><br><span class="line">void AddProduct(Product P);</span><br><span class="line">void DeleteProduct(Product P);</span><br><span class="line">void ModifyProduct(Product P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int ProductID&#123;</span><br><span class="line">get&#125;;</span><br><span class="line">string MadeDate&#123;</span><br><span class="line">set&#125;;</span><br><span class="line">string ProductName&#123;</span><br><span class="line">get;</span><br><span class="line">set;&#125;</span><br></pre></td></tr></table></figure><h4 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int this[int index]&#123;//添加一个int类型索引器</span><br><span class="line">get;</span><br><span class="line">set;&#125;</span><br></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event EventHandler Expired;</span><br></pre></td></tr></table></figure><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p>简单示例如下：<br>创建一个表示商品基本信息的Product类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Product&#123;</span><br><span class="line">public int pid;</span><br><span class="line">public string MadeDate;</span><br><span class="line">public string ProductName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建ProducrDao类并实现IProduct接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class ProductDao:IProduct</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在Product类中声明一个Product类的实例P，并在ProductDao类的构造函数中对P进行初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Product p;</span><br><span class="line">public ProductDao(Product p)&#123;</span><br><span class="line">this.p=new pRODUCT();</span><br><span class="line">this.p=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字ProductDao类中实现接口中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void AddProduct(Product p)&#123;</span><br><span class="line">Console.WriteLie(&quot;添加&quot;);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">public Product QueryById(int ProductId)&#123;</span><br><span class="line">ConsoleWriteLine(&quot;实现商品编号为&#123;0&#125;的查询功能&quot;,ProductId);</span><br><span class="line">Product p=new Product();</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现接口中的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int ProductId&#123;</span><br><span class="line">get&#123;return p.pid;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public string MadeDate&#123;</span><br><span class="line">set&#123; p.MadeDate=value;&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>在ProductDao类中实现对IProduct接口中定义的索引器进行实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int this[int index]&#123;</span><br><span class="line">get&#123;</span><br><span class="line">if (indes&lt;0||index&gt;=100)</span><br><span class="line">return 0;</span><br><span class="line">else</span><br><span class="line">return index;</span><br><span class="line">&#125;</span><br><span class="line">set&#123;</span><br><span class="line">if (!(index&lt;0||index&gt;=100))</span><br><span class="line">index=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在ProductDao中对事件进行实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public event EventHandler Expired&#123;</span><br><span class="line">add&#123;Expired+=value;&#125;//注册事件</span><br><span class="line">remove &#123;Expired-=value;&#125;//移除事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来就是进行主函数的编写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)&#123;</span><br><span class="line">product p=new  p=roduct();</span><br><span class="line">p.pid=123456;</span><br><span class="line">p.madeDate&quot;2018-03-25&quot;;</span><br><span class="line">p.ProductName=&quot;手套&quot;;</span><br><span class="line">ProductDao=new PriductDao(p);</span><br><span class="line">Console.WriteLine(&quot;jjj&quot;);</span><br><span class="line"></span><br><span class="line">pd.ADDProduct(o);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="IComparable"><a href="#IComparable" class="headerlink" title="IComparable"></a>IComparable</h2><p>程序中常用到对数据进行排序，如结构数组或其他对象数组等。<br>.NET Framework内置了一个通用的比较方法，由值类型或类实现以创建类型的特定比较方法<br>IComparable接口声明如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IComparable&#123;</span><br><span class="line">int CompareTo(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仅提供一个方法，该方法作用是将当前实例与同一类型的另一个对象进行比和奥并返回一个帧数，该整数指示当前实例在排序顺序中的位置是位于另一个对象之前还是之后还是位置相当。</p><ul><li>小于零    当前实例小于obj参数</li><li>等于零    当前实例等于obj参数</li><li>大于零    当前实例大于obj参数<br>对一个课程类Course，包含了趁机和课程名称，进行成绩排序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Course : IComparable</span><br><span class="line">&#123;</span><br><span class="line">public string Name;</span><br><span class="line">public int Score;</span><br><span class="line">public Course(stringname,int score)</span><br><span class="line">&#123;</span><br><span class="line">Name=name;</span><br><span class="line">Score=score;</span><br><span class="line">&#125;</span><br><span class="line">public int CompareTo(object obj)</span><br><span class="line">&#123;</span><br><span class="line">if (obj is Course)//obj是否为Course类型</span><br><span class="line">&#123;</span><br><span class="line">Course otherCourse=obj as Course;</span><br><span class="line">return this.Score-otherCourse.Score;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">throw new ArgumentException(&quot;当前比较的对象不是Course类型&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在主函数中进行测试，创建一个集合，添加多个Course类对象，分别输出排序前后的结构，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">ArrayList list=new ArrayList();</span><br><span class="line">list.Add(new Course(&quot;ASP.NET&quot;,60));</span><br><span class="line">list.Add(new Course(&quot;SQL&quot;,85));</span><br><span class="line">list.Add(new Course(&quot;C#&quot;,73));</span><br><span class="line">list.Add(new Course(&quot;PHP&quot;,90));</span><br><span class="line">Console.WriteLine(&quot;按成绩排序前结果如下：&quot;);</span><br><span class="line">for (int i=0;i&lt;list.Count;i++)&#123;</span><br><span class="line">Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;,(list[i]as Course).Name,(list[i] as Course).Score);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(&quot;按成绩排序后结果如下&quot;);</span><br><span class="line">list.Sort();//调用Course类中CompareTo()方法进行排序</span><br><span class="line">for (int i=0;i&lt;list.Count;i++)&#123;</span><br><span class="line">Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;,(list[i]as Course).Name,(list[i] as Course).Score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在调用Sort()方法时会对每个实例调用CompareTo()方法进行比较排序。</p><h2 id="IComparer"><a href="#IComparer" class="headerlink" title="IComparer"></a>IComparer</h2><p>.NET Framework还提供一个IComparer接口进行排序。<br>以上两个接口区别主要有两点：</p><ol><li>IComparable在需要比较的对象的类中实现，可以比较该对象和另外一个对象。</li><li>IComparer在单独的一个类中实现，可以比较任意两个对象。</li></ol><p>IComparer接口声明如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IComparer</span><br><span class="line">&#123;</span><br><span class="line">int Compare(object x,object y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仅包含一个Compare()方法，比较两个对象并返回一个值，指示一个对象是小于、等于还是大于另一个对象。</p><ul><li>小于零    x参数小于y参数</li><li>等于零    x参数等于y参数</li><li>大于零    x参数大于y参数<br>以下为实现接口的简单示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ComparerName:IComparer</span><br><span class="line">&#123;</span><br><span class="line">public int Compare(object x,object y)</span><br><span class="line">&#123;</span><br><span class="line">if (x is Course &amp;&amp;y is Course)</span><br><span class="line">&#123;</span><br><span class="line">return Comparer.Default.Compare(((Course)x).Name,((Course)y).Name);</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">throw new ArgumentException(&quot;要比较的对象不是Course类型&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>接下来使用代码测试排序结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;排序后的结果&quot;）;</span><br><span class="line">IComparer SortByName=new ComparerName();</span><br><span class="line">//创建一个按名称排序的实例，以下会调用ComparerName类中的Compare()方法进行排序</span><br><span class="line">list.Sort(SortByName);</span><br><span class="line">for (int i=0;i&lt;list.Count;i++)</span><br><span class="line">&#123;</span><br><span class="line">ConsoleWriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;,(list[i] as Course).Name,(list[i] s Course).Score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>这次就写到这里，突然发现要真的一字不差的写出来，真的太多了，下次真得精简一下了，难怪这么累。</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在说一说关于枚举，很久之前才C语言里面用过一点点，但是没有深入，C#学习之后想真正深入一下，就得好好学习。枚举是一个被命名的整型常数集合，如一周只能为周一到周日等，只有固定的几种取值的时候可以定义为枚举。&lt;/p&gt;
&lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; cla
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>使用aircrack进行WiFi监听和密码破解以及在Markdown插入图片</title>
    <link href="https://bluerbk.top/2018/03/23/aircrack-and-ali-s-oss/"/>
    <id>https://bluerbk.top/2018/03/23/aircrack-and-ali-s-oss/</id>
    <published>2018-03-23T14:09:12.000Z</published>
    <updated>2018-04-06T08:46:09.976Z</updated>
    
    <content type="html"><![CDATA[<p>先说点题外话，写了几篇文章一直都是纯文字，并不是我觉得简约，而是我不会在MarkdownPad里插入图片。。。本地图片路径没问题，但就是显示不出来，无奈之下我只好进行万能的百度，找到了一个东西叫对象存储oss，鬼知道这是干啥的，反正它可以保存我的图片，这样可以生成一个链接然后我就可以在md里插入图片了。<br>我选择的是阿里云的对象存储服务，在控制台点击开通即可，因为博客等小网站用量不是很多，采取按量计费的措施即可，具体部分价目如下表</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/22200731.jpg" alt="ALi_OSS_Price"></h2><p>如图，有三种计费方式，标准，低频和归档。标准就是标准模式，低频是指访问量较低，当然便宜，但是有最低存储期限，单个文件必须存储一个月能删除，不然会多收费。归档是几乎不用来进行访问，更多情况用来进行文件的备份存储的。推荐使用低频计费方式。<br>oss开通之后，<a href="http://jiantuku.com/" target="_blank" rel="noopener">点击此处</a>进入极简图床，这里可以帮助你上传图片到你的oss里，只需要简单的配置即可。<br>因为是按量计费，还是得少弄图，不过也无所谓，也没多少人看我的博客（手动大滑稽）。</p><hr><p>好了，进入正题吧，使用aircrack进行无线网络的监听和WiFi密码的破译等功能。这属于无线安全范畴的知识，以前有人稍微的教过一点，在加上我自己百度的一些，写一篇文章稍微总结一下。</p><h2 id="这是正文"><a href="#这是正文" class="headerlink" title="这是正文"></a>这是正文</h2><p>使用的平台以及工具：</p><ul><li>linux（我用的是kali）</li><li>aircrack - ng工具</li><li>无线网卡 LK-110 USB无线网卡</li></ul><h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><p>先启动kali linux，然后插入网卡，输入命令查看网卡是否正确接入，至于这个和Windows主机装不装驱动有没有关系我就不太了解了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwconfig</span><br></pre></td></tr></table></figure></p><p><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/11203430.jpg" alt="image"><br>如图，wlan0便是我的网卡<br>网卡正确识别之后，使用如下命令改变网卡模式，使之监听模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airmon-ng start wlan0 </span><br><span class="line">airmon-ng stop wlan0mon</span><br></pre></td></tr></table></figure></p><p><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/66987465.jpg" alt="image"><br>如图所示，改变模式之后网卡的名字也随之而变，wlan0mon即为wlan0的监听模式的名字，之后的网卡名字都要使用这个监听模式的名字。<br>启动监听了之后，监听范围内所有的AP，并显示相关AP信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airodump-ng wlan0mon</span><br></pre></td></tr></table></figure></p><p><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/7166935.jpg" alt="image"><br>bssid为AP的MAC地址，essid为AP的名字，ch为信道，这是常用的参数信息，之后的操作都要用到MAC地址。<br>然后使用如下命令监听具体的AP的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">airodump-ng --ivs -w 包名 --bssid 目标MAC -c 信道 mon0（接口名称）</span><br><span class="line">//下面是我用的命令</span><br><span class="line">airodump-ng --ivs -w a --bssid F4:83:CD:C6:29:CE -c 1 wlan0mon</span><br></pre></td></tr></table></figure></p><p><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/3908329.jpg" alt="image"><br>命令里的–ivs表示抓取的文件格式为*.ivs格式，包名表示给抓取的包重命名，但是他会默认加上数字，比如你的命令是…-w a…，那么出来的文件不是a.ivs，而是a-01.ivs。<br>station表示这个AP连接了两个设备，一个是我的手机一个是我的电脑，第二个是我的手机，下面我需要获取握手包，里面有关于密码的一些信息，怎么获取呢？有这么一个命令，aireplay-ng攻击命令，有很多种攻击模式和不同的参数，功能很多，但此处只需要使用一个，使用冲突模式攻击指定MAC设备，使其强制断开连接，因为设备终端会重新自动连接AP，此时便可以抓到握手包，如果抓到握手包会在监听终端的右上角看到提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aireplay-ng -0 10 –a F4:83:CD:C6:29:CE -c 14:1F:78:30:73:C8 wlan0mon</span><br></pre></td></tr></table></figure></p><p><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/31625635.jpg" alt="image"><br>如果获取到了握手包，如图所指的地方就会出现这个字样提示你获取到指定MAC设备的握手包，接下来就可以进行密码破解了，采用的是暴力破解方法，众所周知，暴力破解关键就是强大的字典，在此我写一个十分简单的字典，其中包含了我的AP密码，以及其他几个干扰，字典格式可以为<em>.lst，</em>.txt等格式不知道可不可以，还没有试过，理论上可以。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-24/80061633.jpg" alt="image"><br>这是我的字典，作为实验，随便写一点就好了。<br>随后执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aircrack-ng  /root/a-01.ivs -w wordlist.lst</span><br></pre></td></tr></table></figure></p><p>参数解释一下，第一个参数是上一步获取握手包时候生成的*.ivs文件，-w参数就是你的字典文件，可以用相对路径也可以用绝对路径，执行之后就是等待，如果你是真的在暴力破解密码的话，可能你会等一段时间，等成功破解出来密码之后，会出现如下的图<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-24/44168240.jpg" alt="image"><br>到此为止，恭喜，成功破解了这个AP的密码，其实看起来还是很有用的是不是呢（再此手动滑稽），当然，前提是你需要有一个强大的字典。<br>无线其实挺好玩的，比如抓包可以进行相应分析啊，像是校园网这种网络，很多都是不加密的，甚至可以把目标的学号密码什么都找出来，是不是很好玩呢？有时间我会学一下关于抓包和分析的相关知识然后再写出来。</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先说点题外话，写了几篇文章一直都是纯文字，并不是我觉得简约，而是我不会在MarkdownPad里插入图片。。。本地图片路径没问题，但就是显示不出来，无奈之下我只好进行万能的百度，找到了一个东西叫对象存储oss，鬼知道这是干啥的，反正它可以保存我的图片，这样可以生成一个链接然
      
    
    </summary>
    
      <category term="无线安全" scheme="https://bluerbk.top/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="kali" scheme="https://bluerbk.top/tags/kali/"/>
    
      <category term="aircrack-ng" scheme="https://bluerbk.top/tags/aircrack-ng/"/>
    
      <category term="无线安全" scheme="https://bluerbk.top/tags/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于Socket的Java网络通信讲解与实例</title>
    <link href="https://bluerbk.top/2018/03/22/Java-SocketProgramming/"/>
    <id>https://bluerbk.top/2018/03/22/Java-SocketProgramming/</id>
    <published>2018-03-22T15:55:20.000Z</published>
    <updated>2018-03-22T17:06:58.173Z</updated>
    
    <content type="html"><![CDATA[<p>在之前学Jva的时候看到了这个Socket编程，觉得网络通信还是很有意思，比如说啊，可以通过Socket进行客户端和服务器端的通信，文字消息啊、文件传输啊之类的。<br>这次说一下关于Socket阻塞式和非阻塞式通信，进行文件传输和字符串的传输。同时，Socket的使用关键主要是对Java中的流的正确使用，主要是用DataInputStream、DataOutputStream、BufferedReader、PrintWriter等流，对文件的操作主要是FileInputStream和FileOutputStream。</p><h2 id="阻塞式通信"><a href="#阻塞式通信" class="headerlink" title="阻塞式通信"></a>阻塞式通信</h2><p>阻塞式通信是最简单的一种通信，通过缓冲区的相关方法（瞎扯）进行输出等操作，但是随之的问题便是，只能是一句一句的传输，比如我给服务器发送一个字符串，如果服务器端不进行回复的话，客户端只能处于等待状态，此时输入任何字符都没有用，但严格地说不是没有用，而是在缓冲区中，并没有显示出来，如果服务器端回复了会发现客户端的终端里有刚才输入的字符串。非阻塞式通信还是比较简单易懂，代码如下：<br>客户端代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">public class Socket_Client&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(&quot;\n\nClient Stsrted&quot;);</span><br><span class="line">Date date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">//构造socket连接，端口4700</span><br><span class="line">Socket socket=new Socket(&quot;127.0.0.1&quot;,4700);</span><br><span class="line">//系统标准输入设备</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">//构造socket的输出流，输出给客户端</span><br><span class="line">PrintWriter os=new PrintWriter(socket.getOutputStream());</span><br><span class="line">//构造socket的输入流，获取信息</span><br><span class="line">BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">try&#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">System.out.println(is.readLine()+&quot;\n&quot;);</span><br><span class="line">&#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">String readline;</span><br><span class="line">readline=br.readLine();</span><br><span class="line">while (!readline.equals(&quot;bye&quot;))&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">//将消息输出到socket</span><br><span class="line">os.println(readline+&quot;\t\t\t#&quot;+date.toString());</span><br><span class="line">//使服务器端立刻接收到消息</span><br><span class="line">os.flush();</span><br><span class="line">System.out.println(&quot;Server：&quot;+is.readLine());</span><br><span class="line">readline=br.readLine();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">os.close();</span><br><span class="line">is.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;catch(IOException e)&#123;System.out.println(&quot;Error&quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用Socket创建一个Socket对象用以进行连接，使用BufferedReader进行标准输入，如从控制台获取字符串或者从服务器端接受字符串信息。构造PrintWriter对象以输出字符串到服务器端。使用（PrintWriter）.println即可输出字符串到服务器端，在输出之后一定要记得调用（PrintWriter）.flush（）函数强制刷新缓冲区，相当于把字符串挤出去了，不然无法正确传输。程序结束之后要记得关闭相应的流，有些流垃圾回收器是不会进行处理的。<br>下面是服务器端的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">public class Socket_Server&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(&quot;\n\nServer Started&quot;);</span><br><span class="line">try&#123;</span><br><span class="line">ServerSocket server=null;</span><br><span class="line">try&#123;</span><br><span class="line">//创建一个serversocket监听4700端口</span><br><span class="line">server=new ServerSocket(4700);</span><br><span class="line">System.out.println(&quot;Waiting for connection......\n&quot;);</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Open Port falied &quot;+e);&#125;</span><br><span class="line">Socket socket=null;</span><br><span class="line">try&#123;</span><br><span class="line">//accept（）阻塞方法，如果有请求产生一个socket对象</span><br><span class="line">socket=server.accept();</span><br><span class="line">System.out.println(&quot;Socket get successfully&quot;+&quot;\t\t\t#&quot;+date.toString()+&quot;\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">String line;</span><br><span class="line">//由socket构造得到输入流，从socket获取输入信息</span><br><span class="line">BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">//由socket构造输出信息，从socket输出信息</span><br><span class="line">PrintWriter os=new PrintWriter(socket.getOutputStream());</span><br><span class="line">//标准输入设备获取输入</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">//获取客户端的消息</span><br><span class="line">os.println(&quot;Socket get successfully...Connection linked\t#&quot;+date.toString());</span><br><span class="line">os.flush();</span><br><span class="line">System.out.println(&quot;Client：&quot;+is.readLine()+&quot;\t\t\t#&quot;+date.toString());</span><br><span class="line">//获取服务端的信息</span><br><span class="line">line=br.readLine();</span><br><span class="line">while (!line.equals(&quot;bye&quot;))&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">//向客户端输出信息</span><br><span class="line">os.println(line+&quot;\t\t\t#&quot;+date.toString());</span><br><span class="line">//刷新输出流，使客户端立刻接收消息</span><br><span class="line">os.flush();</span><br><span class="line">System.out.println(&quot;Client：&quot;+is.readLine());</span><br><span class="line">line=br.readLine();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">//关闭socket输出流</span><br><span class="line">os.close();</span><br><span class="line">//关闭socket输出流</span><br><span class="line">is.close();</span><br><span class="line">//关闭socket和serversocket</span><br><span class="line">socket.close();</span><br><span class="line">server.close();</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了上面的客户端代码，服务器端应该也就更好理解了。服务器端的Socket是通过SocketServer建立一个对象server，负责监听指定端口是否有一个连接，如有链接，通过server.accept()阻塞式获取一个socket连接对象，进行通信传输。输入输出的相关函数用法同客户端，所以很好记的。同样，在程序结束之后记得关闭相应的流。</p><h2 id="非阻塞式通信"><a href="#非阻塞式通信" class="headerlink" title="非阻塞式通信"></a>非阻塞式通信</h2><p>有了上面说的阻塞式通信的例子，对非阻塞式通信从名字上应该有一点懂了吧，顾名思义就是不会碰到阻塞的情况，也就是不用等待服务器端的回复，我都可以一直想服务器端发送字符串，这就是非阻塞式通信。从思路上来看，我们需要使用到多线程，通过两个线程的运行，分别控制消息的接受和消息的发送，这样不用去等待对方回复。<br>但是非阻塞式带来的问题就是不好判定对方是否结束，一方中断连接的时候只可以中断一个线程，由于另一个线程在等待消息，可能是在一直等待输入也可能是在等待接收消息，即便是使用同步的方法也无法在两个这样的线程里传递信息，导致不能在一方就进行双向切断。<br>代码如下：<br>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Socket_Client&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(&quot;\n\nClient Stsrted&quot;);</span><br><span class="line">String ip=&quot;127.0.0.1&quot;;</span><br><span class="line">Date date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">//构造socket连接，端口4700</span><br><span class="line">Socket socket=new Socket(ip,4700);</span><br><span class="line">//系统标准输入设备</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">//构造socket的输出流，输出给客户端</span><br><span class="line">PrintWriter os=new PrintWriter(socket.getOutputStream());</span><br><span class="line">//构造socket的输入流，获取信息</span><br><span class="line">BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">try&#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">System.out.println(is.readLine()+&quot;\n&quot;);</span><br><span class="line">&#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">Client_SendThread send=new Client_SendThread(os);</span><br><span class="line">Client_PrintThread print=new Client_PrintThread(is,socket.getInetAddress().toString());</span><br><span class="line">Thread sendthread=new Thread(send);</span><br><span class="line">sendthread.start();</span><br><span class="line">Thread printthread=new Thread(print);</span><br><span class="line">printthread.start();</span><br><span class="line">printthread.join();</span><br><span class="line">sendthread.join();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">os.close();</span><br><span class="line">is.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Error&quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client_PrintThread implements Runnable&#123;</span><br><span class="line">private BufferedReader is;</span><br><span class="line">private String ip;</span><br><span class="line">public Client_PrintThread(BufferedReader is,String ip)&#123;</span><br><span class="line">super();</span><br><span class="line">this.is=is;</span><br><span class="line">this.ip=ip;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;print thread started&quot;);</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">String s=new String();</span><br><span class="line">String Server_Name=&quot;Server&quot;;</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">s=is.readLine();</span><br><span class="line">System.out.println(Server_Name+&quot;\t&quot;+s);</span><br><span class="line">if (s.split(&quot;:&quot;)[3].trim().equals(&quot;bye&quot;))&#123;</span><br><span class="line">ifrun=false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Sorry The link has been cut(Please input &quot;bye&quot; to end the link)\tprint thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Client_SendThread implements Runnable&#123;</span><br><span class="line">private PrintWriter os;</span><br><span class="line">public Client_SendThread(PrintWriter os)&#123;</span><br><span class="line">super();</span><br><span class="line">this.os=os;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;send thread started&quot;);</span><br><span class="line">String s=new String();</span><br><span class="line">Date date;</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">s=br.readLine();</span><br><span class="line">os.println(&quot;[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.flush();</span><br><span class="line">if (s.equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Sorry The link has been cut\tsend thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有两个线程Client_SendThread和Client_PrintThread，分别控制消息的发送和接受。也没有太多的难点，主要就是开两个线程即可。<br>服务器端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Socket_Server&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(&quot;\n\nServer Started&quot;);</span><br><span class="line">try&#123;</span><br><span class="line">ServerSocket server=null;</span><br><span class="line">try&#123;</span><br><span class="line">//创建一个serversocket监听4700端口</span><br><span class="line">server=new ServerSocket(4700);</span><br><span class="line">System.out.println(&quot;Waiting for connection......\n&quot;);</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Open Port falied &quot;+e);&#125;</span><br><span class="line">Socket socket=null;</span><br><span class="line">try&#123;</span><br><span class="line">//accept（）阻塞方法，如果有请求产生一个socket对象</span><br><span class="line">socket=server.accept();</span><br><span class="line">System.out.println(&quot;Socket get successfully&quot;+&quot;\t\t\t#&quot;+date.toString()+&quot;\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">String line;</span><br><span class="line">//由socket构造得到输入流，从socket获取输入信息</span><br><span class="line">BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">//由socket构造输出信息，从socket输出信息</span><br><span class="line">PrintWriter os=new PrintWriter(socket.getOutputStream());</span><br><span class="line">//标准输入设备获取输入</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">//获取客户端的消息</span><br><span class="line">os.println(&quot;Socket get successfully...Connection linked\t#&quot;+date.toString());</span><br><span class="line">os.flush();</span><br><span class="line">Server_SendThread send=new Server_SendThread(os);</span><br><span class="line">Server_PrintThread print=new Server_PrintThread(is,socket.getInetAddress().toString());</span><br><span class="line">Thread sendthread=new Thread(send);</span><br><span class="line">sendthread.start();</span><br><span class="line">Thread printthread=new Thread(print);</span><br><span class="line">printthread.start();</span><br><span class="line">printthread.join();</span><br><span class="line">sendthread.join();</span><br><span class="line">System.out.println(&quot;The MAINTHRED closed\t\tMAIN&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">//关闭socket输出流</span><br><span class="line">os.close();</span><br><span class="line">//关闭socket输出流</span><br><span class="line">is.close();</span><br><span class="line">//关闭socket和serversocket</span><br><span class="line">socket.close();</span><br><span class="line">server.close();</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Server_PrintThread implements Runnable&#123;</span><br><span class="line">private BufferedReader is;</span><br><span class="line">private String ip;</span><br><span class="line">Date date=new Date();</span><br><span class="line">public Server_PrintThread(BufferedReader is,String ip)&#123;</span><br><span class="line">super();</span><br><span class="line">this.is=is;</span><br><span class="line">this.ip=ip;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;print thread started&quot;);</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">String s=new String();</span><br><span class="line">String Client_Name=&quot;Client&quot;;</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">s=is.readLine();</span><br><span class="line">System.out.println(Client_Name+&quot;\t&quot;+s);</span><br><span class="line">if (s.split(&quot;:&quot;)[3].trim().equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Sorry The link has been cut(Please input &quot;bye&quot; to end the link)\tprint thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Server_SendThread implements Runnable&#123;</span><br><span class="line">MyObj obj=new MyObj();</span><br><span class="line">private PrintWriter os;</span><br><span class="line">public Server_SendThread(PrintWriter os)&#123;</span><br><span class="line">super();</span><br><span class="line">this.os=os;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;send thread started&quot;);</span><br><span class="line">String s=new String();</span><br><span class="line">Date date;</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">s=br.readLine();</span><br><span class="line">os.println(&quot;[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.flush();</span><br><span class="line">if (s.equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Sorry The link has been cut\tsend thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="同样也没有太多好说的。。。"><a href="#同样也没有太多好说的。。。" class="headerlink" title="同样也没有太多好说的。。。"></a>同样也没有太多好说的。。。</h2><p>下面是两个关于Socket有关的小栗子</p><h2 id="关于传输和接收的格式和方式"><a href="#关于传输和接收的格式和方式" class="headerlink" title="关于传输和接收的格式和方式"></a>关于传输和接收的格式和方式</h2><p>文件，不能像字符串那样直接发送，所幸的是Java中有一个强大的东西叫流，可以把文件转化成字节流，然后通过DataOutputStream将字节流发送出去，服务器端可以通过DataInputStream接受字节流，然后对字节流进行相应的处理，比如转换成字符串、写入某一个文件等等。<br><a href="https://blog.csdn.net/liuhenghui5201/article/details/8351574" target="_blank" rel="noopener">点击此处查看以下内容原文</a><br>以下是DataOutputStream的有关方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">构造函数：</span><br><span class="line"></span><br><span class="line">DataOutputStream(OutputStream out);//创建一个将数据写入指定输出流out的数据输出流。</span><br><span class="line"></span><br><span class="line">字段摘要：</span><br><span class="line"></span><br><span class="line">int written;//到目前为止写入数据流的字节数。</span><br><span class="line"></span><br><span class="line">主要方法：</span><br><span class="line"></span><br><span class="line">void write(byte[] b,int off,int len);//将byte数组off角标开始的len个字节写到OutputStream 输出流对象中。</span><br><span class="line"></span><br><span class="line">void write(int b);//将指定字节的最低8位写入基础输出流。</span><br><span class="line"></span><br><span class="line">void writeBoolean(boolean b);//将一个boolean值以1-byte形式写入基本输出流。</span><br><span class="line"></span><br><span class="line">void writeByte(int v);//将一个byte值以1-byte值形式写入到基本输出流中。</span><br><span class="line"></span><br><span class="line">void writeBytes(String s);//将字符串按字节顺序写入到基本输出流中。</span><br><span class="line"></span><br><span class="line">void writeChar(int v);//将一个char值以2-byte形式写入到基本输出流中。先写入高字节。</span><br><span class="line"></span><br><span class="line">void writeInt(int v);//将一个int值以4-byte值形式写入到输出流中先写高字节。</span><br><span class="line"></span><br><span class="line">void writeUTF(String str);//以机器无关的的方式用UTF-8修改版将一个字符串写到基本输出流。该方法先用writeShort写入两个字节表示后面的字节数。</span><br><span class="line"></span><br><span class="line">int size();//返回written的当前值。</span><br></pre></td></tr></table></figure></p><p>以下是有关DataInputStream的一些方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">构造方法：DataInputStream(InputStream in);</span><br><span class="line"></span><br><span class="line">主要方法：</span><br><span class="line"></span><br><span class="line">int read(byte[] b);//从输入流中读取一定的字节，存放到缓冲数组b中。返回缓冲区中的总字节数。</span><br><span class="line"></span><br><span class="line">int read(byte[] buf,int off,int len);//从输入流中一次读入len个字节存放在字节数组中的偏移off个字节及后面位置。</span><br><span class="line"></span><br><span class="line">String readUTF();//读入一个已使用UTF-8修改版格式编码的字符串</span><br><span class="line"></span><br><span class="line">String readLine();</span><br><span class="line"></span><br><span class="line">boolean readBoolean;</span><br><span class="line"></span><br><span class="line">int readInt();</span><br><span class="line"></span><br><span class="line">byte readByte();</span><br><span class="line"></span><br><span class="line">char readChar();</span><br></pre></td></tr></table></figure></p><p>转换成二进制格式也可以进行传输，使用InputStream和OutputStream进行发送和接受。</p><h2 id="简单的客户端和服务器端进行文件传输的例子"><a href="#简单的客户端和服务器端进行文件传输的例子" class="headerlink" title="简单的客户端和服务器端进行文件传输的例子"></a>简单的客户端和服务器端进行文件传输的例子</h2><p>由于是一个很简单的文件传输，但是使用的方法还是相当实用的，甚至比上面的阻塞式通信还实用（本人觉得），具体代码如下<br>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">class SendMsg&#123;</span><br><span class="line">public SendMsg(String[] args)throws Exception&#123;</span><br><span class="line">int Length;</span><br><span class="line">File file=new File(args[0]);</span><br><span class="line">FileInputStream fis=new FileInputStream(file);</span><br><span class="line">System.out.println(&quot;Get File Name Successfully\t&quot;);</span><br><span class="line">System.out.println(file.getName());</span><br><span class="line">DataInputStream in=new DataInputStream(fis);</span><br><span class="line">Length=fis.available();</span><br><span class="line">byte[] Byte=new byte[Length];</span><br><span class="line"></span><br><span class="line">in.read(Byte);</span><br><span class="line">Socket_FileSend(Byte,Length,file.getName());</span><br><span class="line">System.out.println(Length+&quot;\t&quot;+file.getName());</span><br><span class="line">fis.close();</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br><span class="line">public void Socket_FileSend(byte[] Byte,int Length,String name)&#123;</span><br><span class="line">System.out.println(&quot;Socket is ready to start&quot;);</span><br><span class="line">try&#123;</span><br><span class="line">Socket socket=new Socket(&quot;127.0.0.1&quot;,4700);</span><br><span class="line">DataOutputStream dos=new DataOutputStream(socket.getOutputStream());</span><br><span class="line">dos.writeUTF(name);</span><br><span class="line">dos.flush();</span><br><span class="line">dos.writeInt(Length);</span><br><span class="line">dos.flush();</span><br><span class="line">dos.write(Byte);</span><br><span class="line">dos.flush();</span><br><span class="line"></span><br><span class="line">socket.close();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">System.exit(1);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;File send successfully&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Socket_Client&#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">if (args.length&lt;1)&#123;</span><br><span class="line">System.out.println(&quot;Cannot find the file.Please input filename&quot;);</span><br><span class="line">System.exit(1);</span><br><span class="line">&#125;</span><br><span class="line">SendMsg send=new SendMsg(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用的时候记得传入一个正确的文件路径，否则会报错。</p><p>服务器端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">class GetMsg&#123;</span><br><span class="line">public GetMsg()throws Exception&#123;</span><br><span class="line">String name=new String();</span><br><span class="line">int Length;</span><br><span class="line">System.out.println(&quot;Waiting for Connection...&quot;);</span><br><span class="line">ServerSocket server=new ServerSocket(4700);</span><br><span class="line">Socket socket=server.accept();</span><br><span class="line">System.out.println(&quot;Connection get Successfully&quot;);</span><br><span class="line"></span><br><span class="line">DataInputStream dis=new DataInputStream(socket.getInputStream());</span><br><span class="line">name=dis.readUTF();</span><br><span class="line">Length=dis.readInt();</span><br><span class="line">System.out.println(name+&quot;\t&quot;+Length);</span><br><span class="line"></span><br><span class="line">byte[] Byte=new byte[Length];</span><br><span class="line">System.out.println(&quot;Get File successfully&quot;+Byte.length);</span><br><span class="line">File file=new File(name);</span><br><span class="line">FileOutputStream fos=new FileOutputStream(file);</span><br><span class="line">dis.read(Byte);</span><br><span class="line">fos.write(Byte);</span><br><span class="line">fos.flush();</span><br><span class="line">fos.close();</span><br><span class="line">System.out.println(&quot;write successfullt&quot;);</span><br><span class="line"></span><br><span class="line">server.close();</span><br><span class="line">socket.close();</span><br><span class="line"></span><br><span class="line">dis.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Socket_Server&#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">GetMsg send=new GetMsg();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一定要有这一步dis.read(Byte);不然Byte里面什么都没有，即便Byte.length也会出来正确的字节数，因为数组初始化了这么多的字节，即便里面没有内容。</p><h2 id="基于Socket的CSC模式通信"><a href="#基于Socket的CSC模式通信" class="headerlink" title="基于Socket的CSC模式通信"></a>基于Socket的CSC模式通信</h2><p>重头戏来了，这才是Socket应该做的事，我们进行通信当然是在客户端之间进行了，毕竟不可能点对点进行，我们需要使用服务器进行中转处理我们希望传输的内容以达到我们的要求。<br>基本思路如下，传输还是采用双线程的非阻塞式，客户端代码变动不大，服务器代码需要修改，在这里我假设是两台客户端进行通信，多个客户端相互通信或者群组通信原理差不多，可以类推。所有对象都需要两个，分别代表两个不同的客户端，如果是多客户端采用多线程建立多个对象即可。<br>重点的部分在这里，需要将接受的客户端1的信息发送给客户端2，接受的客户端2的信息发送给客户端1，这样就实现了信息的交换，建议实际写代码的时候可以画一个草图方便缕清思路，因为流真的有点多，稍微一乱的话就会搞不清了。<br>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Socket_Client&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(&quot;\n\nClient Started&quot;);</span><br><span class="line">String ip=&quot;204.44.91.156&quot;;</span><br><span class="line">Date date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">//构造socket连接，端口4700</span><br><span class="line">Socket socket=new Socket(ip,4700);</span><br><span class="line">//系统标准输入设备</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">//构造socket的输出流，输出给客户端</span><br><span class="line">PrintWriter os=new PrintWriter(socket.getOutputStream());</span><br><span class="line">//构造socket的输入流，获取信息</span><br><span class="line">BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">try&#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">System.out.println(is.readLine()+&quot;\n&quot;);</span><br><span class="line">&#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">Client_SendThread send=new Client_SendThread(os);</span><br><span class="line">Client_PrintThread print=new Client_PrintThread(is,socket.getInetAddress().toString());</span><br><span class="line">Thread sendthread=new Thread(send);</span><br><span class="line">sendthread.start();</span><br><span class="line">Thread printthread=new Thread(print);</span><br><span class="line">printthread.start();</span><br><span class="line">printthread.join();</span><br><span class="line">sendthread.join();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">os.close();</span><br><span class="line">is.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Error&quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client_PrintThread implements Runnable&#123;</span><br><span class="line">private BufferedReader is;</span><br><span class="line">private String ip;</span><br><span class="line">public Client_PrintThread(BufferedReader is,String ip)&#123;</span><br><span class="line">super();</span><br><span class="line">this.is=is;</span><br><span class="line">this.ip=ip;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;print thread started&quot;);</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">String s=new String();</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">s=is.readLine();</span><br><span class="line">System.out.println(s);</span><br><span class="line">if (s.split(&quot;:&quot;).length&gt;3)&#123;</span><br><span class="line">if (s.split(&quot;:&quot;)[3].trim().equals(&quot;bye&quot;))&#123;</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Sorry The link has been cut(Please input &apos;bye&apos; to end the link)\tprint thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Client_SendThread implements Runnable&#123;</span><br><span class="line">private PrintWriter os;</span><br><span class="line">public Client_SendThread(PrintWriter os)&#123;</span><br><span class="line">super();</span><br><span class="line">this.os=os;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;send thread started&quot;);</span><br><span class="line">String s=new String();</span><br><span class="line">Date date;</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">s=br.readLine();</span><br><span class="line">os.println(s);</span><br><span class="line">os.flush();</span><br><span class="line">if (s.equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Sorry The link has been cut\tsend thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务器端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">//CSC模式经由服务器使得两个客户端之间进行非阻塞式通信</span><br><span class="line">public class Socket_Server&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(&quot;\n\nServer Started&quot;);</span><br><span class="line">try&#123;</span><br><span class="line">ServerSocket server=null;</span><br><span class="line">try&#123;</span><br><span class="line">//创建一个serversocket监听4700端口</span><br><span class="line">server=new ServerSocket(4700);</span><br><span class="line">System.out.println(&quot;Waiting for connection......\n&quot;);</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Open Port falied &quot;+e);&#125;</span><br><span class="line">Socket socket_1=null,socket_2=null;</span><br><span class="line">//第一个客户端链接</span><br><span class="line">try&#123;</span><br><span class="line">//accept（）阻塞方法，如果有请求产生一个socket对象</span><br><span class="line">socket_1=server.accept();</span><br><span class="line">System.out.println(&quot;First Socket got successfully&quot;+&quot;\t\t\t#&quot;+date.toString()+&quot;\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">String line_1;</span><br><span class="line">//由socket构造得到输入流，从socket获取输入信息</span><br><span class="line">BufferedReader is_1=new BufferedReader(new InputStreamReader(socket_1.getInputStream()));</span><br><span class="line">//由socket构造输出信息，从socket输出信息</span><br><span class="line">PrintWriter os_1=new PrintWriter(socket_1.getOutputStream());</span><br><span class="line">//向第一个客户端发出信号</span><br><span class="line">os_1.println(&quot;You have got the Socket linked.Please waiting for another.\t#&quot;+date.toString());</span><br><span class="line">os_1.flush();</span><br><span class="line">//第二个客户端链接</span><br><span class="line">try&#123;</span><br><span class="line">//accept（）阻塞方法，如果有请求产生一个socket对象</span><br><span class="line">socket_2=server.accept();</span><br><span class="line">System.out.println(&quot;Second Socket got successfully&quot;+&quot;\t\t\t#&quot;+date.toString()+&quot;\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">String line_2;</span><br><span class="line">//由socket构造得到输入流，从socket获取输入信息</span><br><span class="line">BufferedReader is_2=new BufferedReader(new InputStreamReader(socket_2.getInputStream()));</span><br><span class="line">//由socket构造输出信息，从socket输出信息</span><br><span class="line">PrintWriter os_2=new PrintWriter(socket_2.getOutputStream());</span><br><span class="line">//向第二个客户端发出信号</span><br><span class="line">os_2.println(&quot;You have got the Socket linked.Please waiting for another.\t#&quot;+date.toString());</span><br><span class="line">os_2.flush();</span><br><span class="line">//链接成功，发出信号</span><br><span class="line">os_1.println(&quot;Both Socket Linked Successfully&quot;);</span><br><span class="line">os_1.flush();</span><br><span class="line">os_2.println(&quot;Both Socket Linked Successfully&quot;);</span><br><span class="line">os_2.flush();</span><br><span class="line">System.out.println(&quot;Both linked successfully&quot;);</span><br><span class="line">//开始通信</span><br><span class="line">Two_to_One two_to_one=new Two_to_One(is_2,socket_2,os_1);</span><br><span class="line">One_to_Two one_to_two=new One_to_Two(is_1,socket_1,os_2);</span><br><span class="line">Thread two_to_one_thread=new Thread(two_to_one);</span><br><span class="line">two_to_one_thread.start();</span><br><span class="line">Thread one_to_two_thread=new Thread(one_to_two);</span><br><span class="line">one_to_two_thread.start();</span><br><span class="line">one_to_two_thread.join();</span><br><span class="line">two_to_one_thread.join();</span><br><span class="line">System.out.println(&quot;The MAINTHRED closed\t\tMAIN&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">//关闭socket输出流</span><br><span class="line">os_1.close();</span><br><span class="line">os_2.close();</span><br><span class="line">//关闭socket输出流</span><br><span class="line">is_1.close();</span><br><span class="line">is_2.close();</span><br><span class="line">//关闭socket和serversocket</span><br><span class="line">socket_1.close();</span><br><span class="line">socket_2.close();</span><br><span class="line">server.close();</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class One_to_Two implements Runnable&#123;</span><br><span class="line">private BufferedReader is;</span><br><span class="line">private PrintWriter os;</span><br><span class="line">private String ip=new String();</span><br><span class="line">Date date=new Date();</span><br><span class="line">public One_to_Two(BufferedReader is_1,Socket socket_1,PrintWriter os_2)&#123;</span><br><span class="line">super();</span><br><span class="line">this.os=os_2;</span><br><span class="line">this.is=is_1;</span><br><span class="line">this.ip=socket_1.getInetAddress().getHostAddress();</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;print thread started&quot;);</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">String s=new String();</span><br><span class="line">String Client_Name_1=ip;</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">s=is.readLine();</span><br><span class="line">System.out.println(Client_Name_1+&quot;\t[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.println(Client_Name_1+&quot;\t[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.flush();</span><br><span class="line">if (s.equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//os.println(&quot;Sorry The link has been cut(Please input &apos;bye&apos; to end the link)\tprint thread closed&quot;);</span><br><span class="line">//os.flush();</span><br><span class="line">System.out.println(ip+&quot;has cut his sendthread\nanother has been cut the printthread&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Two_to_One implements Runnable&#123;</span><br><span class="line">private PrintWriter os;</span><br><span class="line">private BufferedReader is;</span><br><span class="line">Date date=new Date();</span><br><span class="line">String ip=new String();</span><br><span class="line">public Two_to_One(BufferedReader is_2,Socket socket_2,PrintWriter os_1)&#123;</span><br><span class="line">super();</span><br><span class="line">this.is=is_2;</span><br><span class="line">this.ip=socket_2.getInetAddress().getHostAddress();</span><br><span class="line">this.os=os_1;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;send thread started&quot;);</span><br><span class="line">String s=new String();</span><br><span class="line">String Client_Name_2=ip;</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">s=is.readLine();</span><br><span class="line">System.out.println(Client_Name_2+&quot;\t[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.println(Client_Name_2+&quot;\t[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.flush();</span><br><span class="line">if (s.equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Sorry The link has been cut\tsend thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其实难点也没有太多，处理好两个服务器之间输入输出流的关系就可以了，之后就像普通的Socket通信一样即可。"><a href="#其实难点也没有太多，处理好两个服务器之间输入输出流的关系就可以了，之后就像普通的Socket通信一样即可。" class="headerlink" title="其实难点也没有太多，处理好两个服务器之间输入输出流的关系就可以了，之后就像普通的Socket通信一样即可。"></a>其实难点也没有太多，处理好两个服务器之间输入输出流的关系就可以了，之后就像普通的Socket通信一样即可。</h2><p>今天就到这吧，可能因为今天代码有点多，已经两万个字符了。我现在在进行C#和Java的通信学习，也是通过Socket，Java负责编写服务器端，目前已经可以正常连接了，下面需要的就是进行相应的数据传输任务即可。等有成效了还会写一个文章的。<br>PS.这些代码都是经过测试的，不仅是在我本地测试过，还用同学的电脑进行真实CSC模式的连接，完美成功实现了。</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前学Jva的时候看到了这个Socket编程，觉得网络通信还是很有意思，比如说啊，可以通过Socket进行客户端和服务器端的通信，文字消息啊、文件传输啊之类的。&lt;br&gt;这次说一下关于Socket阻塞式和非阻塞式通信，进行文件传输和字符串的传输。同时，Socket的使用关键
      
    
    </summary>
    
      <category term="Java" scheme="https://bluerbk.top/categories/Java/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="网络编程" scheme="https://bluerbk.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://bluerbk.top/tags/Java/"/>
    
      <category term="Socket" scheme="https://bluerbk.top/tags/Socket/"/>
    
      <category term="多线程" scheme="https://bluerbk.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C#基础伪教程（二）</title>
    <link href="https://bluerbk.top/2018/03/18/CSharp-Second-Teaching/"/>
    <id>https://bluerbk.top/2018/03/18/CSharp-Second-Teaching/</id>
    <published>2018-03-18T08:53:09.000Z</published>
    <updated>2018-03-18T15:20:05.893Z</updated>
    
    <content type="html"><![CDATA[<p>今天啥都没干，干脆写一点C#吧，就当作是第二个教程了，不多说，进入正题。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是用class关键字定义声明，具体框架如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class name</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>public属于访问修饰符，表示访问权限，也可以为protected、internal或者private。<br>C#的类同样支持继承，被继承的类称为基类，继承基类的类称作派生类。派生类可以使用基类的数据、行为的基础上创建自己的数据和行为。<br>类的主题成员有</p><blockquote><p>字段<br>属性<br>方法<br>构造函数<br>析构函数</p></blockquote><hr><p>对象的创建使用new关键字<br>    Class class=new Class();</p><h3 id="静态类和静态成员"><a href="#静态类和静态成员" class="headerlink" title="静态类和静态成员"></a>静态类和静态成员</h3><p>静态类是不能被实例化的，不能通过new创建对象，只能通过类去直接访问内部成员。一般类中也可以包含静态成员，同样，不能被对象访问，只能由类去访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static class car</span><br><span class="line">&#123;</span><br><span class="line">public static string WriteName()&#123;</span><br><span class="line">return &quot;这是静态成员&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">car.WriteName();</span><br></pre></td></tr></table></figure></p><p>静态类有以下几个特点：</p><ul><li>静态类的所有成员都是静态成员</li><li>静态类不能被实例化</li><li>静态类是封装的，不能被继承</li><li>静态类不能包含实例构造函数，但是可以定义静态构造函数<br>静态成员有以下几个特点：</li><li>含有静态成员的类必须有静态构造函数来初始化</li><li>静态字段通常用来记录实例对象的个数或存储该类所有对象的共享值</li><li>静态方法可以被重载但不能被重写</li><li>局部变量不能被声明为静态变量，如方法中不能声明静态变量</li></ul><h3 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h3><p><strong>字段</strong>默认为私有，可以被标记为public、private、protected、internal或protected internal，还可以声明为<strong>只读变量</strong>，用readonly关键字声明。<br>只读字段只能在初始化或者在构造函数中赋值，静态只读字段类似于常量，但是不能在编译的时候访问，而是在运行的时候访问。<br>字段通常具有以下属性：</p><ul><li>字段可以被类的多个方法访问，否则可以在方法内部定义变量，而非定义类的字段</li><li>字段的生命周期比类中的单个方法的生命期长</li><li>字段可以在声明时赋值，若构造函数包含了字段的初始值，则字段声明值将被覆盖。</li><li>字段出四肢不能引用其他实例字段，但是可以是其他类的静态字段<br>如定义公共的静态只读字段num<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static readonly int num;</span><br></pre></td></tr></table></figure></li></ul><hr><p>若字段被标记为私有则只能通过<strong>属性</strong>来进行访问。<br>属性结合了字段的方法和属性，既可以被当作特殊的方法使用，也可以作为普通字段进行使用。<br>除了访问修饰符，属性还可以具有以下标记</p><blockquote><p>static        静态属性<br>virtual       虚属性<br>sealed        它对派生类不再是虚拟的<br>abstract      在派生类中实现</p></blockquote><p>属性具有get访问器或set访问器或同时拥有，两者可以具有不同的访问修饰符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可访问类型  类型  名称</span><br><span class="line">&#123;</span><br><span class="line">get &#123;&#125;</span><br><span class="line">set &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>get和set均可省略。若只有get则为只读属性，若只有set则为只写属性。<br>get和set相当于Java中私有封装的getter和setter。<br>具体用法如下：</p><blockquote><p>get访问器与方法类似，它必须返回属性类型的值作为属性的值，当引用属性的时候，若没有为属性赋值，则调用get访问器获取属性的值<br>get访问器必须以return或throw结尾，并且控制权不能离开访问器<br>get访问器除了直接返回字段值，还可以通过计算返回字段值<br>set访问器类似于返回类型为void的方法，它使用属性类型的value隐式参数，当对属性赋值时，用提供心智的参数调用set访问器<br>在set访问器中，对据变量声明使用隐式参数名称value是错误的。</p></blockquote><p>使用属性的时候就像是使用方法一样，简单示例代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//第一个</span><br><span class="line">public class count</span><br><span class="line">&#123;</span><br><span class="line">public int num;</span><br><span class="line">public int addnum</span><br><span class="line">&#123;</span><br><span class="line">get &#123; return num + 10; &#125;</span><br><span class="line">set &#123;num = value - 100; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">count id=new count();</span><br><span class="line">id.num=200;</span><br><span class="line">Console.WriteLine(id.addnum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出为</span><br><span class="line">300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二个</span><br><span class="line">public class age</span><br><span class="line">&#123;</span><br><span class="line">public int agenum;</span><br><span class="line">public int num</span><br><span class="line">&#123;</span><br><span class="line">get &#123; return ageuum; &#125;</span><br><span class="line">set </span><br><span class="line">&#123;</span><br><span class="line">if ((value &gt; 0)&amp;&amp;(value &lt; 200))</span><br><span class="line">&#123;</span><br><span class="line">value = agenum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">age ageo=new age();</span><br><span class="line">ageo.num=300;</span><br><span class="line">Console.WriteLine(ageo.agenum);</span><br><span class="line">ageo.agenum=70;</span><br><span class="line">Console.WriteLine(ageo.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果为</span><br><span class="line">0</span><br><span class="line">70</span><br></pre></td></tr></table></figure></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法在类中声明，具体格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问级别 是否静态 返回值类型 方法名 （参数类型 参数1，参数类型 参数2...）</span><br><span class="line">｛...｝</span><br></pre></td></tr></table></figure></p><p><strong>关于参数</strong><br>分为按值传递和按引用传递。<br>前者即为传入该变量的副本，对其形式参数进行使用，不影响原变量的值。<br>后者即为引用，如C语言中的&amp;，直接对变量本身进行操作，不使用副本。在参数前加修饰符ref或out即可。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是类调用中首先执行的函数，构造函数是方法的一种，与方法唯一不同的时构造函数在创建累的对象时执行的类方法，构造函数要与类名同名，不需要写返回值类型。构造函数可以被标记为public、protected、private、internal或者protected internal。<br>若没有写构造函数，在C#编译器中将自动添加一个默认构造函数，来实例化对象，并将所有成员变量设置为各自类型的默认值。<br><strong>静态类</strong>也有构造函数，作用于非静态类构造函数一样，但静态类中构造函数为静态构造函数。<br>构造函数可分为静态构造函数、实例化构造函数和私有化构造函数等。<br>静态构造函数特点如下：</p><blockquote><p>静态构造函数访问修饰符和参数<br>静态构造函数在首次访问类的时候自动调用<br>静态构造函数由编译器控制调用，开发人员无法直接调用静态构造函数<br>私有化构造函数是一种特殊的实例构造函数。它通常用在只包含静态成员的类中，如果类中具有一个或多个私有构造函数而没有公共构造函数，则不允许其他类创建该类的实例。<br>多态允许具有多个含不同参数的构造函数，根据参数的不同选用对应的构造函数。<br><strong>在一个构造函数中可以通过this关键字调用其他的构造函数。</strong></p></blockquote><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数是用来释放类资源的，它与一般方法有很大区别，主要有以下几点：</p><ul><li>一个类只能有一个析构函数</li><li>析构函数不能被继承</li><li>析构函数由编译器调节，开发人员无法控制何时调用，由垃圾回收起决定</li><li>析构函数没有访问修饰符和参数</li><li>析构函数不能定义返回值类型，也没有返回值</li><li>程序退出时自动执行析构函数</li></ul><p>命名的时候在名字前面加’~’以和构造函数区分开<br>通过调用Collect强制进行资源释放，但是可能会导致程序性错误。通过来自IDisposable接口的Dispose（）可以显式地释放一些资源，为对象执行必要的清理。虽然会提高性能但垃圾回收期还是会调用析构函数对对象进行彻底清理。</p><h2 id="类的高级应用"><a href="#类的高级应用" class="headerlink" title="类的高级应用"></a>类的高级应用</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>对类本身，内部成员属性及方法确定是否可被访问等，是否该被隐藏。<br>密封类，不可被继承，通常用来限制扩展性。<br>public sealed class D{…}<br>除此之外与其他类区别不大，可以实例，可以私有，可以共有等。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>C#中，所有类都是直接或间接地继承Object类。类可以被连环继承。继承如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class News&#123;...&#125;</span><br><span class="line">class SportsNews:News&#123;...&#125;</span><br></pre></td></tr></table></figure></p><h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><p>又被称为虚函数，是一种可以被派生类实现、重载或冲写的方法，虚函数同选择语句一样有执行条件，根据不同情况实现。一般方法在编译时就静态地编译到执行文件中，其相对地址在程序运行期间是不变的。但是虚函数在编译期间不能被静态编译，它相对地址是不变的。<br>虚方法根据运行时期对象实例来动态判断要调用的函数，其中声明时定义的类交声明类，执行时实例化的类叫实例类。虚方法有以下特点，如下所示：</p><ul><li>虚方法通过virtual关键字实现</li><li>虚方法通过override关键字在派生类中实现</li><li>虚方法前不允许有static、abstract或override修饰符</li><li>虚方法不能是私有的，因此不能使用private修饰符</li></ul><p>虚函数执行过程如下所示</p><ol><li>当调用一个对象的函数时，系统会直接去检查这个函数声明所在的类，即声明类，查看函数是否为虚函数</li><li>若不是虚函数，那么直接执行该函数。但如果是虚函数，那么程序不会立刻执行该函数，而是检查对象的实例类，即继承函数声明的类</li><li>在这个实例类，程序将检查这个实例类的定义中是否包含实现该虚函数或者重写虚函数的方法</li><li>如果有，执行实例类中实现的虚函数的方法。如果没有，系统就会不停地往上找实例类的父类，并对父类重复刚才在实例类里的检查，直到找到第一个重载该虚函数的父类为止，然后执行该父类里冲在后的方法</li></ol><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种仅用于继承的类。定义一个抽象类的目的主要是为派生类提供可共享的基类成员的公共生命。抽象类对象的抽象成员只有声明部分，没有实现部分。抽象类中的成员实现完全由继承抽象类的派生了来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class A&#123;</span><br><span class="line">public abstract int B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象类的继承必须实现对抽象类中所有未实现的成员，包括属性和方法。抽象类中抽象成员的实现和虚函数的实现一样，在方法名前用override关键字。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>类的方法有三种多态形式</p><blockquote><p>定义同名但参数列表不同的方法，被称为方法的重载<br>定义同名且参数列表也相同的方法，并且父类中的方法用abstract/virtual进行修饰，成为方法的覆盖。子类中的同名方法也用override进行修饰，如虚方法和抽象类的覆盖<br>定义相同且参数列表也相同的方法，其父类中的方法没有用abstract/virtual进行修饰，称为方向的隐藏。</p></blockquote><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><ul><li>方法名必须相同。</li><li>返回值可以相同也可以不同，但参数列表不能相同，因为编译器首先根据方法名选择方法，再根据参数列表在众多重载函数中找到合适的。</li><li>匹配函数时，编译器将不区分类型引用和类型本身，也不区分const和非const变量。</li></ul><h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>有两种形式，覆盖（只能重写被abstract和virtual关键字修饰的方法，在中写的时候需要关键字override）和隐藏（直接使用new关键字重写基类中的一般方法）。<br><strong>重写时针对方法名相同，擦书列表也相同的方法的多态</strong>，通常时在子类中重写基类的方法。<br>重写有以下几个特点</p><ul><li>静态方法、密封方法和非虚方法不能被覆盖。</li><li>非虚方法可以被隐藏，但静态方法和密封方法不能被隐藏。</li><li>重写方法和已重写了的基方法具有相同的返回类型。</li><li>重写声明和已重写了的基方法具有相同的声明可访问性。重写声明不能更改所对应的虚方法的可访问性。<br>如果已重写的基方法时protected internal，并且生命它的程序集不是包含重写方法的程序集，则重写方法声明的可访问性必须是protected。</li></ul><hr><p>关于后面的几个概念的举例，我懒得写了，需要的时候上网查一下就好了（估计一般也用不太上），就这样</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天啥都没干，干脆写一点C#吧，就当作是第二个教程了，不多说，进入正题。&lt;/p&gt;
&lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;p&gt;类是用class关键字定义声明，具体框架如下&lt;br&gt;&lt;fig
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>C#基础伪教程（一）</title>
    <link href="https://bluerbk.top/2018/03/17/C-First-Teaching/"/>
    <id>https://bluerbk.top/2018/03/17/C-First-Teaching/</id>
    <published>2018-03-17T15:56:30.000Z</published>
    <updated>2018-03-17T16:13:04.653Z</updated>
    
    <content type="html"><![CDATA[<p>由于之前学过Java的相关知识，但是由于Java在桌面程序表现的无力，决定选择新的语言，在QT和C#中还是选择了C#，不瞎扯了，我也不会扯，简单粗暴一点，C#语法和Java也很类似。<br>老规矩，我写的教程一向都是伪教程，指不定哪天我都看不懂的那种。</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>我采用的是VSCode工具，虽然我也有VS2013，但是它的体积真的很庞大，写点小代码不太划算，还相当占内存。于是我采用VSCode。<br>首先得添加C#插件，<a href="https://www.microsoft.com/net/download/windows" target="_blank" rel="noopener">点击此处下载.NET Core SDK</a><br>随后安装，成功后重启VSCode<br>打开cmd控制台，任意进入一个路径，执行命令</p><pre><code>dotnet new console dotnet run</code></pre><p>第一个是在当前目录下创建C#控制台程序，第二个命令是运行程序，默认为输出”HelloWorld！“。随后在VSCode中打开对应目录下的.cs文件，进行编写，编译执行即可</p><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>下面一段C#的代码</p><pre><code>using System;namespace C_{    class Program    {        static void Main(string[] args)        {                Console.Write(&quot;Hello,&quot;);            Console.WriteLine(&quot;World&quot;);        }    }}</code></pre><p>由上可见，C#代码包含命名空间，类名和函数名。与其他语言的区别有这些，主函数名为Main，而不是main，类Console在System命名空间中，调用Console类中的Write()和WriteLine()方法向控制台进行输出。<br>Ps.第一个末尾不带换行，第二个自带换行。<br>一个简单的C#程序就编写成功了。</p><h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>如下代码示例装箱<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int val=100;</span><br><span class="line">object obj=val;</span><br><span class="line">Console.WriteLine(&quot;对象的值为=&#123;0&#125;&quot;,obj);</span><br></pre></td></tr></table></figure></p><p>object为任意类型，使用一个非泛型容器，保证其通用性。<br>拆箱示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int val=100;</span><br><span class="line">object obj=val;</span><br><span class="line">int num=(int)obj;</span><br><span class="line">Console.WrtieLine(&quot;num=&#123;0&#125;&quot;,num);</span><br></pre></td></tr></table></figure></p><p>可以转换成原本属于的类型，也可以强制转换到任意可以相容的容易，所以必须显式强制类型转换。</p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>像for(;;)、while()、do … while ();、if、switch等几乎通用，便不多赘述。在此写一个C#新见的一种循环，和用过的迭代器很像。<br>foreach (变量生命 in 数组名或集合类），代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] num=new int [5]&#123;1,2,3,4,5&#125;;</span><br><span class="line">foreach (int i in num)</span><br><span class="line">&#123;</span><br><span class="line">Console.Write(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出为：12345</p><hr><p>跳转语句，例如goto，continue等，也和其他语言区别不大。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>按照Java的方式，如获得一个int数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] num=new int[3]&#123;1,2,3&#125;;</span><br><span class="line">int[] num=&#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure></p><p>可以通过这样进行数组的初始化赋值。<br>二维数组，如下例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[,] num=new int[3,3]&#123;...&#125;;</span><br><span class="line">int[,] num=&#123;</span><br><span class="line">&#123;3,3,3&#125;,</span><br><span class="line">&#123;2,2,2&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>多维数组同二维数组，如[,]变为[,,]即可。</p><h4 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h4><p>即不规则数组<br>如如下定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] inter=new int[3][];</span><br><span class="line">inter[0]=new int[4]&#123;1,2,3,4&#125;;</span><br><span class="line">inter[1]=new int[3]&#123;1,2,3&#125;;</span><br><span class="line">inter[2]=new int[5]&#123;1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure></p><p>即inter数组内容为下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure></p><p>上面说的数组都是静态数组，在<strong>System.Array</strong>类中针对静态数组提供了一些操作的属性及方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Length//数组长度，为32位整数</span><br><span class="line">LongLength//数组长度，为64位整数</span><br><span class="line">Rank//数组的秩，即维度</span><br><span class="line">IsReadOnly//数组是否可读</span><br><span class="line">IsFixedSize//数组大小是否固定</span><br><span class="line">IsSynchronized//是否同步访问数组</span><br><span class="line">SyncRoot//获取同步访问数组的对象</span><br><span class="line"></span><br><span class="line">GetValue()//获取指定元素的值</span><br><span class="line">SetValue()//设置指定元素的值</span><br><span class="line">Clear（）//清除数组的所有元素</span><br><span class="line">IndexOf()//获取匹配的第一个元素的索引</span><br><span class="line">LaseIndexOf()//获取匹配的最后一个元素的索引</span><br><span class="line">Sort()//对一维数组排序</span><br><span class="line">Reverse()//反转一维数组的元素</span><br><span class="line">GetLength()//获取指定唯独数组的元素数量，32位整数</span><br><span class="line">GetLongLength//获取指定维度的数组的元素数量，64位整数</span><br><span class="line">FindIndex()//搜索指定元素，并获取第一个匹配元素的索引</span><br><span class="line">FindLastIndex()//搜索指定元素，并获取最后一个匹配元素的索引</span><br><span class="line">Copy()//复制一个数组的部分元素到另一个数组</span><br><span class="line">CopyTo()//将一维数组中的所有元素复制到另一个一维数组中</span><br><span class="line">Clone()//复制数组</span><br><span class="line">ConstrainedCopy()//指定开始位置，并复制一系列元素到另一个数组</span><br><span class="line">BinarySearch()//二进制搜索算法在一维的排序数组中搜索指定元素</span><br><span class="line">GetLowerBound()//获取数组中指定维度的下限</span><br><span class="line">GetUpperBound()//获取数组中指定维度的上限</span><br></pre></td></tr></table></figure></p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>动态数组能够在程序的执行中改变数组的长度，可以增加、释放元素所占的空间，又被称为可变数组。这里主要说由System.ArrayList实现得动态数组。<br>需要导入命名空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br></pre></td></tr></table></figure></p><p>创建动态数组对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list=new ArrayList();</span><br></pre></td></tr></table></figure></p><p>ArrayList类的属性及方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Capacity//数组容量</span><br><span class="line">Count //数组元素的数量</span><br><span class="line">IsFixedSize//数组大小是否固定</span><br><span class="line">IsReadOnly//数组是否为只读</span><br><span class="line">IsSynchronized//是否同步访问数组</span><br><span class="line">SyncRoot//获取同步访问数组的对象</span><br><span class="line"></span><br><span class="line">Adapter()//为指定的IList创建ArrayList包装</span><br><span class="line">Add()//将对象添加到ArrayList的尾部</span><br><span class="line">AddRange()//将ICollection的元素添加到ArrayList的尾部</span><br><span class="line">BinarySearch()//使用对分检索算法在已排序的ArrayList或它的一部分查找特定元素</span><br><span class="line">Clear()//移除所有元素</span><br><span class="line">Clone()//创建ArrayList的浅表副本</span><br><span class="line">Contains//确定某元素是否在ArrayList中</span><br><span class="line">CopyTo()//将ArrayList或它的一部分复制到一维数组中</span><br><span class="line">Equals()//确定两个Object实例是否相等</span><br><span class="line">FixedSize()//返回具有固定大小的列表包装，其中的元素允许修改，但不允许添加或移除</span><br><span class="line">GetEnumerator()//返回循环访问ArrayList的枚举数</span><br><span class="line">GetHashCode()//用于特定类型的哈希函数，GetHshCode适合在哈希算法和数据结构（哈希表等）中使用</span><br><span class="line">GetRange()//返回ArrayList，它表示源ArrayList中元素的子集</span><br><span class="line">GetType()//获取当前实例的Type</span><br><span class="line">IndexOf()//返回ArrayList或它的一部分中某个值的第一个匹配项的从零开始的索引</span><br><span class="line">Insert()//将元素插入ArrayList指定的索引处</span><br><span class="line">InsertRange()//将集合中的某个元素插入ArrayList的指定索引处</span><br><span class="line">LastIndexOf()//返回ArrayList或它的一部分中某个值的最后一个匹配项的从零开始的索引</span><br><span class="line">ReadOnly()//返回只读的列表包装</span><br><span class="line">ReferenceEquals()//确定指定的Object实例是否是相同的实例</span><br><span class="line">Remove()//从ArrayList移除特定对象的第一个匹配项</span><br><span class="line">RemoveAt()//移除ArrayList的指定索引处的元素</span><br><span class="line">RemoveRange()//从ArrayList中移除一定范围的元素</span><br><span class="line">Repeat()//返回ArrayList，它元素是指定值的副本</span><br><span class="line">Reverse()//将ArrayList或它的一部分元素顺序反转</span><br><span class="line">SetRange()//将集合中的元素复制到ArrayList中的一定范围的元素上</span><br><span class="line">Sort()//堆ArrayList或它的一部分的元素进行排序</span><br><span class="line">Synchronized()//返回同步的（线程安全）列表包装</span><br><span class="line">ToArray()//将ArrayList的元素复制到新的数组中</span><br><span class="line">ToString()//返回当前Object的String</span><br><span class="line">TrimTpSize()//将容量设置为ArrayList中元素的实际数目</span><br></pre></td></tr></table></figure></p><hr><h3 id="动态数组的应用"><a href="#动态数组的应用" class="headerlink" title="动态数组的应用"></a>动态数组的应用</h3><p>添加数组元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list=new ArrayList();</span><br><span class="line">list.Add(1);</span><br><span class="line">list.insert(3,0);</span><br></pre></td></tr></table></figure></p><p>由于ArrayList中元素的类型位Object，若要使用foreach语句则为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach (object obj in list)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>删除数组元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Remove(2);</span><br><span class="line">list.RemoveAt(1);</span><br><span class="line">list.RemoveRange(2,5);</span><br></pre></td></tr></table></figure></p><hr><p>打这么多名字有点累，可能会出错，但是报错应该还是很友好的，百度一下就知道该怎么用了。</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于之前学过Java的相关知识，但是由于Java在桌面程序表现的无力，决定选择新的语言，在QT和C#中还是选择了C#，不瞎扯了，我也不会扯，简单粗暴一点，C#语法和Java也很类似。&lt;br&gt;老规矩，我写的教程一向都是伪教程，指不定哪天我都看不懂的那种。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>使用HEXO+GITHUB搭建自己的博客</title>
    <link href="https://bluerbk.top/2018/03/15/hexo_use/"/>
    <id>https://bluerbk.top/2018/03/15/hexo_use/</id>
    <published>2018-03-15T15:47:44.000Z</published>
    <updated>2018-03-17T15:53:01.433Z</updated>
    
    <content type="html"><![CDATA[<p>博客这个东西很多网站都有，什么博客园、CSDN、简书之类的。上周还在考虑在网站上写博客，因为我一直都是自己在本地写word或者txt来记录的。突发奇想自己搭一个博客来写，又高大上还记录了还练手了。说做就做，用了两天时间差不多把基本功能实现了。</p><h4 id="使用的工具和环境"><a href="#使用的工具和环境" class="headerlink" title="使用的工具和环境"></a>使用的工具和环境</h4><ul><li>Windows7 x64</li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js v8.1</a></li><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git 2.16.2</a></li><li><a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkdownPad 2</a></li></ul><p>本文主要说一下博客的搭建，hexo和github联系起来，初步发布文章，修改主题，还会说一些存在的坑。（随缘配图）<br><a href="https://www.appinn.com/markdown/#img" target="_blank" rel="noopener">点击此处查看Markdown语法说明</a></p><h2 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h2><h3 id="node-js的安装"><a href="#node-js的安装" class="headerlink" title="node.js的安装"></a>node.js的安装</h3><p>运行node.js安装包，一路next，完成安装，退出。<br>随后打开控制台界面（ctrl-R，输入cmd回车）<br>运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果依次出现相对应的版本号，则表示安装成功。</p><h3 id="Git的安装和配置"><a href="#Git的安装和配置" class="headerlink" title="Git的安装和配置"></a>Git的安装和配置</h3><p>运行下载的Git安装包，进入Git的安装<br>当到了Git PATH的步骤时，选择“Use Git from the Windows Command Prompt“这个选项，这是为了将Git添加到系统环境变量里，不用再单独打开git bash运行命令了，cmd即可运行。<br>安装成功后，执行如下命令，若安装成功则会出现Git的版本号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -version</span><br></pre></td></tr></table></figure></p><h3 id="github账号的注册和配置"><a href="#github账号的注册和配置" class="headerlink" title="github账号的注册和配置"></a>github账号的注册和配置</h3><p><a href="https://github.com/" target="_blank" rel="noopener">点击此处</a>或打开链接<a href="https://github.com/，进行账号注册" target="_blank" rel="noopener">https://github.com/，进行账号注册</a><br>之后进入注册时填的邮箱，确认账号，不然无法成功。注册成功后，点击右上角的头像，点击 New repository，在Repository name下填写yourname.github.io，即你的github page网站的名字（比如我的是 RBK.github.io)<br>创建成功后，代码库的右上角点击 Setting，向下找Github Page，选择master然后配置主题什么的，之后直接登录你的网站即可看到你的github page。<br>如登陆 blueprok.github.io/RBK.github.io 就是我的主页。在Setting页面的最右下也有写你的网站地址。</p><h3 id="HEXO的安装和配置"><a href="#HEXO的安装和配置" class="headerlink" title="HEXO的安装和配置"></a>HEXO的安装和配置</h3><p>最关键的地方来了，我在搭建的时候就在这折腾了一天。后面会写碰到的问题。关于安装hexo好像很有争议，在此我写一个我用的方法：<br>在一个位置新建一个文件夹，最好是某个盘的根目录吧，比如我的位置时 D：\hexo，然后运行以下命令，Hexo就安装成功了。可以通过查看版本判断是否安装成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure></p><p>随后进行创建站点。以此执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init [new empty folder]</span><br><span class="line">cd [new empty folder]</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>切记一定要是一个空的文件夹不然会报错，之后的所有步骤都要在<strong>[new empty folder]</strong>这个目录下执行命令<br>还有要注意<strong>node.js版本</strong>，最开始我就因为node.js版本太低，导致安装hexo失败，因为npm安装的hexo是最新的，node版本也需要更新。<br>执行完命令后执行以下命令，来生成静态页面<br><code>hexo g</code><br>或者<br><code>hexo generate</code></p><p>执行<code>hexo s</code><br>或者<br><code>hexo server</code><br>来开启本地web服务,会提示<br><code>INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code><br>在浏览器中输入<a href="http://localhost:4000/即可看到网页了。" target="_blank" rel="noopener">http://localhost:4000/即可看到网页了。</a></p><h3 id="将github-page和hexo联系起来"><a href="#将github-page和hexo联系起来" class="headerlink" title="将github page和hexo联系起来"></a>将github page和hexo联系起来</h3><p>执行命令来设置Git账户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;BluePROK&quot;</span><br><span class="line">git config --global user.email &quot;568406972@qq.com&quot;</span><br></pre></td></tr></table></figure><p>生成密钥（登录时需要，执行命令后按三次回车即可)<br><code>ssh-keygen -t rsa -C &quot;568406972@qq.com&quot;</code><br>如果提示找不到命令，说明ssh-keygen没有配置环境变量，切换路径到Git\usr\bin即可运行ssh-keygen。在Users文件夹里搜索密钥文件***.pub，把它打开，复制里面的内容。打开github的账户Setting，设置SSH安全，标题随便写，把pub内容复制出来完成即可，不然后面会出现无法提交网页到github的情况。<br>在根目录的_config.yml里找到Deploy，修改信息</p><ol><li>deploy:</li><li>type: git</li><li>repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:BluePROK/RBK.github.io.git</li><li>branch: master<br>这样就配置完成了</li></ol><p>新建博客，执行命令<br><code>hexo new post &quot;article title&quot;</code></p><p>会在hexo的根目录source_post里看到artitle title.md，这就是发布的文章，语法为Markdown。<br>执行命令发布文章，每次修改都要这样<br><code>hexo d -g</code><br>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>到目前为止hexo博客搭建完成，访问 blueprok.github.io/RBK.github.io即可看到我的网页。</p><p>PS.可能需要一个扩展，命令如下<br><code>npm install hexo-deployer-git --save</code></p><p>在此列出借鉴的两个文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://blog.csdn.net/gdutxiaoxu/article/details/53576018</span><br><span class="line">https://www.cnblogs.com/blogjun/articles/8289977.html</span><br></pre></td></tr></table></figure><h2 id="主题的设置"><a href="#主题的设置" class="headerlink" title="主题的设置"></a>主题的设置</h2><p>这是HEXO的主页：<a href="https://hexo.io/，上面有关于hexo的安装、命令、使用、主题等各种内容。" target="_blank" rel="noopener">https://hexo.io/，上面有关于hexo的安装、命令、使用、主题等各种内容。</a><br>我在这个网站上找的一个主题BlueLake，巧了，正好也是Blue，地址是这个<br><a href="http://chaoo.oschina.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.html" target="_blank" rel="noopener">http://chaoo.oschina.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.html</a><br>这是完整的教程，可以跟着做，我就不一一写出来了。<br>更换主题的时候也有一个小问题，hexo s本地网站主题更换了，但是更新github主题却无法显示出来。这是第二个难题，经过多方查找，需要修改以下配置文件，根_config.yml里的URL属性修改一下，我是这样修改的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https://blueprok.github.io/RBK.github.io/</span><br><span class="line">root: /RBK.github.io</span><br></pre></td></tr></table></figure></p><p>url的属性即为github page网站的地址，root属性为github page仓库项目的名字。然后再hexo d -g就可以成功修改github page的主题了。</p><h2 id="域名的绑定解析"><a href="#域名的绑定解析" class="headerlink" title="域名的绑定解析"></a>域名的绑定解析</h2><p>购买了域名之后，供应商都应该提供解析服务，我用的是阿里云，以这个为例。</p><ol><li>在阿里云控制台，设置主机记录www，记录类型为A，记录值是IP192.30.252.153。其中192.30.252.153是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Github Pages。</li><li>在阿里云控制台，设置主机记录www，记录类型为A，记录值是IP192.30.252.154。同上。</li><li>在阿里云控制台，设置主机记录@，记录类型为CNAME，记录值是bluerbk.github.io.。表示将<a href="http://bluerbk.top这个主域名映射bluerbk.github.io。在这里千万不要忘记记录值中.io后面还有一个点.！" target="_blank" rel="noopener">http://bluerbk.top这个主域名映射bluerbk.github.io。在这里千万不要忘记记录值中.io后面还有一个点.！</a></li></ol><hr><p>解析设置完成之后，在本地hexo\source新建一个文件，名字为CNAME，不要后缀，内容为域名即可（即bluerbk.top)。因为如果在github上建立文件的话下次上传的时候这个文件就被覆盖了，所以添加到本地文件，以便每次都可以保证上传，不丢失。<br>但是此时需要修改一下根_config.yml的配置信息，即上文所说的URL信息，修改为如下，否则主题又将不能应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https://bluerbk.top/</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure></p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客这个东西很多网站都有，什么博客园、CSDN、简书之类的。上周还在考虑在网站上写博客，因为我一直都是自己在本地写word或者txt来记录的。突发奇想自己搭一个博客来写，又高大上还记录了还练手了。说做就做，用了两天时间差不多把基本功能实现了。&lt;/p&gt;
&lt;h4 id=&quot;使用的
      
    
    </summary>
    
      <category term="Hexo" scheme="https://bluerbk.top/categories/Hexo/"/>
    
    
      <category term="博客" scheme="https://bluerbk.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="https://bluerbk.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://bluerbk.top/2018/03/14/article-title/"/>
    <id>https://bluerbk.top/2018/03/14/article-title/</id>
    <published>2018-03-14T15:29:26.697Z</published>
    <updated>2018-03-23T11:42:04.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Welcome-to-MarkdownPad-2"><a href="#Welcome-to-MarkdownPad-2" class="headerlink" title="Welcome to MarkdownPad 2"></a>Welcome to MarkdownPad 2</h2><p><strong>MarkdownPad</strong> is a full-featured Markdown editor for Windows.</p><h3 id="Built-exclusively-for-Markdown"><a href="#Built-exclusively-for-Markdown" class="headerlink" title="Built exclusively for Markdown"></a>Built exclusively for Markdown</h3><p>Enjoy first-class Markdown support with easy access to  Markdown syntax and convenient keyboard shortcuts.</p><p>Give them a try:</p><ul><li><strong>Bold</strong> (<code>Ctrl+B</code>) and <em>Italic</em> (<code>Ctrl+I</code>)</li><li>Quotes (<code>Ctrl+Q</code>)</li><li>Code blocks (<code>Ctrl+K</code>)</li><li>Headings 1, 2, 3 (<code>Ctrl+1</code>, <code>Ctrl+2</code>, <code>Ctrl+3</code>)</li><li>Lists (<code>Ctrl+U</code> and <code>Ctrl+Shift+O</code>)</li></ul><h3 id="See-your-changes-instantly-with-LivePreview"><a href="#See-your-changes-instantly-with-LivePreview" class="headerlink" title="See your changes instantly with LivePreview"></a>See your changes instantly with LivePreview</h3><p>Don’t guess if your <a href="http://markdownpad.com" target="_blank" rel="noopener">hyperlink syntax</a> is correct; LivePreview will show you exactly what your document looks like every time you press a key.</p><h3 id="Make-it-your-own"><a href="#Make-it-your-own" class="headerlink" title="Make it your own"></a>Make it your own</h3><p>Fonts, color schemes, layouts and stylesheets are all 100% customizable so you can turn MarkdownPad into your perfect editor.</p><h3 id="A-robust-editor-for-advanced-Markdown-users"><a href="#A-robust-editor-for-advanced-Markdown-users" class="headerlink" title="A robust editor for advanced Markdown users"></a>A robust editor for advanced Markdown users</h3><p>MarkdownPad supports multiple Markdown processing engines, including standard Markdown, Markdown Extra (with Table support) and GitHub Flavored Markdown.</p><p>With a tabbed document interface, PDF export, a built-in image uploader, session management, spell check, auto-save, syntax highlighting and a built-in CSS management interface, there’s no limit to what you can do with MarkdownPad.<br><img src="C:/Users/Administrator/Desktop/2.png" alt="image"><br><img src="C:\Users\Administrator\Desktop\2.png" alt="image">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Welcome-to-MarkdownPad-2&quot;&gt;&lt;a href=&quot;#Welcome-to-MarkdownPad-2&quot; class=&quot;headerlink&quot; title=&quot;Welcome to MarkdownPad 2&quot;&gt;&lt;/a&gt;Welcome to Mar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bluerbk.top/2018/03/14/hello-world/"/>
    <id>https://bluerbk.top/2018/03/14/hello-world/</id>
    <published>2018-03-14T15:06:10.005Z</published>
    <updated>2018-03-14T15:06:10.005Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
