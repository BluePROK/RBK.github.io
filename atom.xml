<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蓝色的博客</title>
  
  <subtitle>RBK</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bluerbk.top/"/>
  <updated>2018-03-25T14:29:09.008Z</updated>
  <id>https://bluerbk.top/</id>
  
  <author>
    <name>Borui Kang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C#基础伪教程（三）</title>
    <link href="https://bluerbk.top/2018/03/25/CSharp-Third-Teaching/"/>
    <id>https://bluerbk.top/2018/03/25/CSharp-Third-Teaching/</id>
    <published>2018-03-25T11:48:38.000Z</published>
    <updated>2018-03-25T14:29:09.008Z</updated>
    
    <content type="html"><![CDATA[<p>现在说一说关于枚举，很久之前才C语言里面用过一点点，但是没有深入，C#学习之后想真正深入一下，就得好好学习。枚举是一个被命名的整型常数集合，如一周只能为周一到周日等，只有固定的几种取值的时候可以定义为枚举。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>所谓枚举是将变量值一一列举出来，变量取值仅限于列举出来的值的范围内。<br>C#的枚举属于值类型，而且所有枚举都派生字System.Enum类，而值类型都继承于System.ValueType类，派生于该类的不一定全是值类型，枚举是唯一的例外。</p><h4 id="枚举的好处"><a href="#枚举的好处" class="headerlink" title="枚举的好处"></a>枚举的好处</h4><blockquote><p>枚举使代码更易于维护，有助于确保给变量指定合法的、期望的值。<br>枚举使代码更加清晰，允许用描述性的名称表示整数值，而不用含义模糊的数来表示。</p></blockquote><h4 id="枚举的特点体现"><a href="#枚举的特点体现" class="headerlink" title="枚举的特点体现"></a>枚举的特点体现</h4><blockquote><p>枚举不能继承其他的类，也不能被其他的类继承。<br>枚举类型实现了IComparable接口，可以实现多个接口。<br>枚举类型只能拥有私有构造器。<br>枚举类型中成员的访问修饰符是public static final。<br>枚举类型中成员列表名称是区分大小写的。</p></blockquote><h3 id="声明枚举"><a href="#声明枚举" class="headerlink" title="声明枚举"></a>声明枚举</h3><p>使用关键字enum进行声明，还需要定义枚举的名称、访问修饰符和类型等。具体用法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] enum 枚举类型 [:类型]&#123;</span><br><span class="line">标识符[=整型常数],</span><br><span class="line">...</span><br><span class="line">标识符[=整型常数],</span><br><span class="line">标识符[=整型常数]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上述各部分含义如下</p><ul><li>枚举类型修饰符为public、private或internal，默认为public。</li><li>枚举名称必须符合C#标识符定义规则。</li><li>枚举类型可以使byte、short、sbyte、ushort、int、unit、long或ulong，默认为int。</li><li>整型常数必须符合枚举类型。<br>如下创建一个四季的枚举类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Season:int&#123;</span><br><span class="line">Spring=0,</span><br><span class="line">Summer=1,</span><br><span class="line">Autumn,</span><br><span class="line">Winter=2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>可以指定整型常数，如果都不指定，默认第一个元素为0，后一个元素的值总是第一个元素的值加1，如Autumn和Winter均为2。</p><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>以一个具体的代码来示例，枚举类型就用上面的Season<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Season se;</span><br><span class="line">se=Season.Spring;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="枚举类型的转换"><a href="#枚举类型的转换" class="headerlink" title="枚举类型的转换"></a>枚举类型的转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//成员对应的数字</span><br><span class="line">Console.WriteLine((Season)Spring);</span><br><span class="line">Console.WriteLine((int)Season.Winter);</span><br><span class="line">//输出0</span><br><span class="line">//输出2</span><br><span class="line">//数字对应的成员</span><br><span class="line">Console.WriteLine((Season)1);</span><br><span class="line">//输出Summer</span><br></pre></td></tr></table></figure><h3 id="枚举的相关方法"><a href="#枚举的相关方法" class="headerlink" title="枚举的相关方法"></a>枚举的相关方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enum.GetName(typeof(Season),1);</span><br><span class="line">(Season)Enum.Parse(typeof(Season),&quot;Spring&quot;,true);</span><br><span class="line">(Season)Enum.Parse(typeof(Season),3,true);</span><br><span class="line">//以下两个方法可用于遍历，如foreach语句里</span><br><span class="line">Enum.GetName(typeof(Season));</span><br><span class="line">Enum.GetValues(typeof(Season));</span><br></pre></td></tr></table></figure><p>Parse()方法有三个参数，第一个数枚举类型，第二个是要转换的字符串，第三个true是忽略大小写。该方法返回的是一个引用，需要强制类型转换。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>结构和类很相似，都可以表示包含数据成员和函数成员的数据结构，但是结构是一种值类型，不用堆分配。<br>结构派生System.ValueType类，适用于具有值语义的小的数据结构，比如平面世界的点，几何世界的一个边，一个矩形等，都是少量数据成员，不要求使用继承或引用表示，而且他们适合值语义（赋值的时候直接复制值，而不是复制引用）方便地实现。<br>结构和类的区别如下</p><ul><li>结构是值类型，而类是引用类型。</li><li>结构早栈中分配空间，类在堆中分配空间。</li><li>在结构中所有成员默认为public修饰符，类中默认为private。</li><li>结构支持构造函数，但无构造函数不能自定义，类可以。</li><li>结构不支持析构函数，类支持。</li><li>在结构中不对成员进行初始化操作，类可以。</li><li>结构派生自System.ValueType，类派生自System.Object。</li><li>结构不支持继承，也不能被继承，类可以。</li><li>结构可以不用new初始化，类必须要用类初始化。<br>结构和类在使用时有很多区别，因此实际编程时应遵循以下规则使用结构还是类</li><li>堆栈空间有限，对于大量的逻辑对象，创建类比创建结构好。</li><li>大多数情况下该类型只是一些数据时，结构是最好的选择，否则创建类。</li><li>在表现抽象或者多层次的数据时，类是最好的选择。</li><li>如果该类型不继承自任何类型时使用结构，否则使用类。</li><li>该类型的实例不会被频繁用于集合中时使用结构，否则使用类。<h3 id="声明结构"><a href="#声明结构" class="headerlink" title="声明结构"></a>声明结构</h3>C#中声明一个结构用关键字struct，语法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] struct 结构名称 [接口]&#123;</span><br><span class="line">结构体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>上述语法主要参数含义：</p><ol><li>修饰符主要为public、private、internal、protected或new，默认为public。</li><li>结构名称必须符合C#标识符定义规则。</li><li>接口是可选参数。结构可以实现接口，但是不能从另一个结构或者类继承，而且不能作为一个类的基类。</li><li>结构体包括数据成员和成员函数，它们不能使用protected或protected internal修饰符，也不能使用abstract或sealed修饰符。<br>简单示例代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Point&#123;</span><br><span class="line">public int X&#123;get;set;&#125;</span><br><span class="line">public int Y&#123;get;set;&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Student&#123;</span><br><span class="line">public int ID;</span><br><span class="line">public string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="结构的使用"><a href="#结构的使用" class="headerlink" title="结构的使用"></a>结构的使用</h3><p>结构成员分为两类：数据成员和成员函数以及类型。<br>数据成员包括常量和字段。函数成员包括属性、方法、事件、索引器、运算符以及构造函数。具体如下：</p><ul><li>常量：表示常量的值。</li><li>字段：结构中声明的变量。</li><li>属性：用于访问对象或结构特性的成员。</li><li>方法：包含一系列语句的代码块，通过这些代码能够实现预先定义的计算或操作。</li><li>事件：一种使对象或结构能够提供通知的成员。</li><li>索引器：又被称为含参属性，是一种含有参数的属性，提供以索引的方式访问对象。</li><li>运算符：通过表达式运算符可以对该结构体的实例进行运算。</li><li>构造函数：包括静态构造函数和实例构造函数。静态构造函数用static修饰，实例构造函数不必static。<br>简单代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct Time&#123;</span><br><span class="line">public bool off;</span><br><span class="line">private int hour,minute,second;</span><br><span class="line">public Time(int h,int m,int s)&#123;</span><br><span class="line">this.h=h;</span><br><span class="line">this.s=s;</span><br><span class="line">this.m=m;</span><br><span class="line">this.off=false;</span><br><span class="line">&#125;</span><br><span class="line">public int Hour&#123;</span><br><span class="line">get&#123;return this.hour;&#125;</span><br><span class="line">set&#123;</span><br><span class="line">if (value &gt;= 0&amp;&amp; value &lt;= 23)</span><br><span class="line">this.hour=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public int Minute&#123;</span><br><span class="line">get&#123;return this.minute;&#125;</span><br><span class="line">set&#123;</span><br><span class="line">if (value&gt;=0&amp;&amp;value&lt;=59)</span><br><span class="line">this.minute=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public int Second&#123;</span><br><span class="line">get&#123;return this.second;&#125;</span><br><span class="line">set&#123;</span><br><span class="line">if (value&gt;=0&amp;&amp;value&lt;=59)</span><br><span class="line">this.second=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void Show()&#123;</span><br><span class="line">string s=&quot;&quot;;</span><br><span class="line">if (off)&#123;</span><br><span class="line">s=this.hoir&gt;12?&quot;PM&quot;:&quot;AM&quot;;</span><br><span class="line">this.hour=this.hour&gt;12?this.hour-12:this.hour;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(&quot;当前时间是：&#123;0&#125;时&#123;1&#125;分&#123;2&#125;秒&#123;3&#125;&quot;,this.hour,this.minute,this.second,s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以下是简单应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)&#123;</span><br><span class="line">Time t1=new Time();</span><br><span class="line">t1.hour=19;</span><br><span class="line">t1.minute=32;</span><br><span class="line">t1.second=50;</span><br><span class="line">t1.Show();</span><br><span class="line"></span><br><span class="line">Time t2=new Time(10,15,58);</span><br><span class="line">t2.Show();</span><br><span class="line"></span><br><span class="line">Time t3=new Time(23,4,27);</span><br><span class="line">t3.off=true;</span><br><span class="line">t3.Show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>和类一样，接口也定义了一系列属性、方法和事件。不同的是接口不提供实现，由类去实现，从类中被定义为单独的实体。接口表示一种约定。<br>C#中的接口和雷一样都属于引用类型，用来描述属于类或结构的一组相关功能，即定义了一种协议或者规范和标准。使用借接口注意以下几点：</p><ol><li>接口中只能包含属性、方法、事件和索引器，但是都不能够实现。</li><li>接口名称通常是以”I”开头的，例如IList，IComparable。</li><li>实现一个接口的语法和继承类似，如class Person ： IPerson。</li><li>通常都称继承了一个类，实现了一个接口。</li><li>如果累已经继承了一个父类，以逗号”,”分隔父类和接口。<h3 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名称&#123;</span><br><span class="line">接口主体</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></li></ol><p>上述语法主要参数如下：</p><ol><li>接口的修饰符包括private，public，protected，internal和new，默认为public。</li><li>接口名称必须符合C#标识符的定义规则。</li><li>接口的主体是接口的详细定义，可以包括属性、方法以及事件等。<br>如下为一个简单示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ISubject&#123;</span><br><span class="line">//接口代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="定义接口成员"><a href="#定义接口成员" class="headerlink" title="定义接口成员"></a>定义接口成员</h3><p>接口成员可以是方法、属性、索引器或者事件，而不能包括常量、字段、运算符、构造函数、析构函数或类型等，也不能包含任何类的静态成员。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IProduct&#123;</span><br><span class="line">void AddProduct(Product P);</span><br><span class="line">void DeleteProduct(Product P);</span><br><span class="line">void ModifyProduct(Product P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int ProductID&#123;</span><br><span class="line">get&#125;;</span><br><span class="line">string MadeDate&#123;</span><br><span class="line">set&#125;;</span><br><span class="line">string ProductName&#123;</span><br><span class="line">get;</span><br><span class="line">set;&#125;</span><br></pre></td></tr></table></figure><h4 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int this[int index]&#123;//添加一个int类型索引器</span><br><span class="line">get;</span><br><span class="line">set;&#125;</span><br></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event EventHandler Expired;</span><br></pre></td></tr></table></figure><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p>简单示例如下：<br>创建一个表示商品基本信息的Product类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Product&#123;</span><br><span class="line">public int pid;</span><br><span class="line">public string MadeDate;</span><br><span class="line">public string ProductName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建ProducrDao类并实现IProduct接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class ProductDao:IProduct</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在Product类中声明一个Product类的实例P，并在ProductDao类的构造函数中对P进行初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Product p;</span><br><span class="line">public ProductDao(Product p)&#123;</span><br><span class="line">this.p=new pRODUCT();</span><br><span class="line">this.p=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字ProductDao类中实现接口中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void AddProduct(Product p)&#123;</span><br><span class="line">Console.WriteLie(&quot;添加&quot;);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">public Product QueryById(int ProductId)&#123;</span><br><span class="line">ConsoleWriteLine(&quot;实现商品编号为&#123;0&#125;的查询功能&quot;,ProductId);</span><br><span class="line">Product p=new Product();</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现接口中的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int ProductId&#123;</span><br><span class="line">get&#123;return p.pid;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public string MadeDate&#123;</span><br><span class="line">set&#123; p.MadeDate=value;&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>在ProductDao类中实现对IProduct接口中定义的索引器进行实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int this[int index]&#123;</span><br><span class="line">get&#123;</span><br><span class="line">if (indes&lt;0||index&gt;=100)</span><br><span class="line">return 0;</span><br><span class="line">else</span><br><span class="line">return index;</span><br><span class="line">&#125;</span><br><span class="line">set&#123;</span><br><span class="line">if (!(index&lt;0||index&gt;=100))</span><br><span class="line">index=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在ProductDao中对事件进行实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public event EventHandler Expired&#123;</span><br><span class="line">add&#123;Expired+=value;&#125;//注册事件</span><br><span class="line">remove &#123;Expired-=value;&#125;//移除事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来就是进行主函数的编写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)&#123;</span><br><span class="line">product p=new  p=roduct();</span><br><span class="line">p.pid=123456;</span><br><span class="line">p.madeDate&quot;2018-03-25&quot;;</span><br><span class="line">p.ProductName=&quot;手套&quot;;</span><br><span class="line">ProductDao=new PriductDao(p);</span><br><span class="line">Console.WriteLine(&quot;jjj&quot;);</span><br><span class="line"></span><br><span class="line">pd.ADDProduct(o);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="IComparable"><a href="#IComparable" class="headerlink" title="IComparable"></a>IComparable</h2><p>程序中常用到对数据进行排序，如结构数组或其他对象数组等。<br>.NET Framework内置了一个通用的比较方法，由值类型或类实现以创建类型的特定比较方法<br>IComparable接口声明如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IComparable&#123;</span><br><span class="line">int CompareTo(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仅提供一个方法，该方法作用是将当前实例与同一类型的另一个对象进行比和奥并返回一个帧数，该整数指示当前实例在排序顺序中的位置是位于另一个对象之前还是之后还是位置相当。</p><ul><li>小于零    当前实例小于obj参数</li><li>等于零    当前实例等于obj参数</li><li>大于零    当前实例大于obj参数<br>对一个课程类Course，包含了趁机和课程名称，进行成绩排序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Course : IComparable</span><br><span class="line">&#123;</span><br><span class="line">public string Name;</span><br><span class="line">public int Score;</span><br><span class="line">public Course(stringname,int score)</span><br><span class="line">&#123;</span><br><span class="line">Name=name;</span><br><span class="line">Score=score;</span><br><span class="line">&#125;</span><br><span class="line">public int CompareTo(object obj)</span><br><span class="line">&#123;</span><br><span class="line">if (obj is Course)//obj是否为Course类型</span><br><span class="line">&#123;</span><br><span class="line">Course otherCourse=obj as Course;</span><br><span class="line">return this.Score-otherCourse.Score;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">throw new ArgumentException(&quot;当前比较的对象不是Course类型&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在主函数中进行测试，创建一个集合，添加多个Course类对象，分别输出排序前后的结构，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">ArrayList list=new ArrayList();</span><br><span class="line">list.Add(new Course(&quot;ASP.NET&quot;,60));</span><br><span class="line">list.Add(new Course(&quot;SQL&quot;,85));</span><br><span class="line">list.Add(new Course(&quot;C#&quot;,73));</span><br><span class="line">list.Add(new Course(&quot;PHP&quot;,90));</span><br><span class="line">Console.WriteLine(&quot;按成绩排序前结果如下：&quot;);</span><br><span class="line">for (int i=0;i&lt;list.Count;i++)&#123;</span><br><span class="line">Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;,(list[i]as Course).Name,(list[i] as Course).Score);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(&quot;按成绩排序后结果如下&quot;);</span><br><span class="line">list.Sort();//调用Course类中CompareTo()方法进行排序</span><br><span class="line">for (int i=0;i&lt;list.Count;i++)&#123;</span><br><span class="line">Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;,(list[i]as Course).Name,(list[i] as Course).Score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在调用Sort()方法时会对每个实例调用CompareTo()方法进行比较排序。</p><h2 id="IComparer"><a href="#IComparer" class="headerlink" title="IComparer"></a>IComparer</h2><p>.NET Framework还提供一个IComparer接口进行排序。<br>以上两个接口区别主要有两点：</p><ol><li>IComparable在需要比较的对象的类中实现，可以比较该对象和另外一个对象。</li><li>IComparer在单独的一个类中实现，可以比较任意两个对象。</li></ol><p>IComparer接口声明如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IComparer</span><br><span class="line">&#123;</span><br><span class="line">int Compare(object x,object y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仅包含一个Compare()方法，比较两个对象并返回一个值，指示一个对象是小于、等于还是大于另一个对象。</p><ul><li>小于零    x参数小于y参数</li><li>等于零    x参数等于y参数</li><li>大于零    x参数大于y参数<br>以下为实现接口的简单示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ComparerName:IComparer</span><br><span class="line">&#123;</span><br><span class="line">public int Compare(object x,object y)</span><br><span class="line">&#123;</span><br><span class="line">if (x is Course &amp;&amp;y is Course)</span><br><span class="line">&#123;</span><br><span class="line">return Comparer.Default.Compare(((Course)x).Name,((Course)y).Name);</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">throw new ArgumentException(&quot;要比较的对象不是Course类型&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>接下来使用代码测试排序结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;排序后的结果&quot;）;</span><br><span class="line">IComparer SortByName=new ComparerName();</span><br><span class="line">//创建一个按名称排序的实例，以下会调用ComparerName类中的Compare()方法进行排序</span><br><span class="line">list.Sort(SortByName);</span><br><span class="line">for (int i=0;i&lt;list.Count;i++)</span><br><span class="line">&#123;</span><br><span class="line">ConsoleWriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;,(list[i] as Course).Name,(list[i] s Course).Score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>这次就写到这里，突然发现要真的一字不差的写出来，真的太多了，下次真得精简一下了，难怪这么累。</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在说一说关于枚举，很久之前才C语言里面用过一点点，但是没有深入，C#学习之后想真正深入一下，就得好好学习。枚举是一个被命名的整型常数集合，如一周只能为周一到周日等，只有固定的几种取值的时候可以定义为枚举。&lt;/p&gt;
&lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; cla
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>使用aircrack进行WiFi监听和密码破解以及在Markdown插入图片</title>
    <link href="https://bluerbk.top/2018/03/23/aircrack-and-ali-s-oss/"/>
    <id>https://bluerbk.top/2018/03/23/aircrack-and-ali-s-oss/</id>
    <published>2018-03-23T14:09:12.000Z</published>
    <updated>2018-03-23T16:18:07.927Z</updated>
    
    <content type="html"><![CDATA[<p>先说点题外话，写了几篇文章一直都是纯文字，并不是我觉得简约，而是我不会再MarkdownPad里插入图片。。。本地图片路径没问题，但就是显示不出来，无奈之下我只好进行万能的百度，找到了一个东西叫对象存储oss，鬼知道这是干啥的，反正它可以保存我的图片，这样可以生成一个链接然后我就可以在md里插入图片了。<br>我选择的是阿里云的对象存储服务，在控制台点击开通即可，因为博客等小网站用量不是很多，采取按量计费的措施即可，具体部分价目如下表</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/22200731.jpg" alt="ALi_OSS_Price"></h2><p>如图，有三种计费方式，标准，低频和归档。标准就是标准模式，低频是指访问量较低，当然便宜，但是有最低存储期限，单个文件必须存储一个月能删除，不然会多收费。归档是几乎不用来进行访问，更多情况用来进行文件的备份存储的。推荐使用低频计费方式。<br>oss开通之后，<a href="http://jiantuku.com/" target="_blank" rel="noopener">点击此处</a>进入极简图床，这里可以帮助你上传图片到你的oss里，只需要简单的配置即可。<br>因为是按量计费，还是得少弄图，不过也无所谓，也没多少人看我的博客（手动大滑稽）。</p><hr><p>好了，进入正题吧，使用aircrack进行无线网络的监听和WiFi密码的破译等功能。这属于无线安全范畴的知识，以前有人稍微的教过一点，在加上我自己百度的一些，写一篇文章稍微总结一下。</p><h2 id="这是正文"><a href="#这是正文" class="headerlink" title="这是正文"></a>这是正文</h2><p>使用的平台以及工具：</p><ul><li>linux（我用的是kali）</li><li>aircrack - ng工具</li><li>无线网卡 LK-110 USB无线网卡</li></ul><h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><p>先启动kali linux，然后插入网卡，输入命令查看网卡是否正确接入，至于这个和Windows主机装不装驱动有没有关系我就不太了解了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwconfig</span><br></pre></td></tr></table></figure></p><p><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/11203430.jpg" alt="image"><br>如图，wlan0便是我的网卡<br>网卡正确识别之后，使用如下命令改变网卡模式，使之监听模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airmon-ng start wlan0 </span><br><span class="line">airmon-ng stop wlan0mon</span><br></pre></td></tr></table></figure></p><p><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/66987465.jpg" alt="image"><br>如图所示，改变模式之后网卡的名字也随之而变，wlan0mon即为wlan0的监听模式的名字，之后的网卡名字都要使用这个监听模式的名字。<br>启动监听了之后，监听范围内所有的AP，并显示相关AP信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airodump-ng wlan0mon</span><br></pre></td></tr></table></figure></p><p><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/7166935.jpg" alt="image"><br>bssid为AP的MAC地址，essid为AP的名字，ch为信道，这是常用的参数信息，之后的操作都要用到MAC地址。<br>然后使用如下命令监听具体的AP的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">airodump-ng --ivs -w 包名 --bssid 目标MAC -c 信道 mon0（接口名称）</span><br><span class="line">//下面是我用的命令</span><br><span class="line">airodump-ng --ivs -w a --bssid F4:83:CD:C6:29:CE -c 1 wlan0mon</span><br></pre></td></tr></table></figure></p><p><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/3908329.jpg" alt="image"><br>命令里的–ivs表示抓取的文件格式为*.ivs格式，包名表示给抓取的包重命名，但是他会默认加上数字，比如你的命令是…-w a…，那么出来的文件不是a.ivs，而是a-01.ivs。<br>station表示这个AP连接了两个设备，一个是我的手机一个是我的电脑，第二个是我的手机，下面我需要获取握手包，里面有关于密码的一些信息，怎么获取呢？有这么一个命令，aireplay-ng攻击命令，有很多种攻击模式和不同的参数，功能很多，但此处只需要使用一个，使用冲突模式攻击指定MAC设备，使其强制断开连接，因为设备终端会重新自动连接AP，此时便可以抓到握手包，如果抓到握手包会在监听终端的右上角看到提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aireplay-ng -0 10 –a F4:83:CD:C6:29:CE -c 14:1F:78:30:73:C8 wlan0mon</span><br></pre></td></tr></table></figure></p><p><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-23/31625635.jpg" alt="image"><br>如果获取到了握手包，如图所指的地方就会出现这个字样提示你获取到指定MAC设备的握手包，接下来就可以进行密码破解了，采用的是暴力破解方法，众所周知，暴力破解关键就是强大的字典，在此我写一个十分简单的字典，其中包含了我的AP密码，以及其他几个干扰，字典格式可以为<em>.lst，</em>.txt等格式不知道可不可以，还没有试过，理论上可以。<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-24/80061633.jpg" alt="image"><br>这是我的字典，作为实验，随便写一点就好了。<br>随后执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aircrack-ng  /root/a-01.ivs -w wordlist.lst</span><br></pre></td></tr></table></figure></p><p>参数解释一下，第一个参数是上一步获取握手包时候生成的*.ivs文件，-w参数就是你的字典文件，可以用相对路径也可以用绝对路径，执行之后就是等待，如果你是真的在暴力破解密码的话，可能你会等一段时间，等成功破解出来密码之后，会出现如下的图<br><img src="http://my-web-image.oss-cn-beijing.aliyuncs.com/18-3-24/44168240.jpg" alt="image"><br>到此为止，恭喜，成功破解了这个AP的密码，其实看起来还是很有用的是不是呢（再此手动滑稽），当然，前提是你需要有一个强大的字典。<br>无线其实挺好玩的，比如抓包可以进行相应分析啊，像是校园网这种网络，很多都是不加密的，甚至可以把目标的学号密码什么都找出来，是不是很好玩呢？有时间我会学一下关于抓包和分析的相关知识然后再写出来。</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先说点题外话，写了几篇文章一直都是纯文字，并不是我觉得简约，而是我不会再MarkdownPad里插入图片。。。本地图片路径没问题，但就是显示不出来，无奈之下我只好进行万能的百度，找到了一个东西叫对象存储oss，鬼知道这是干啥的，反正它可以保存我的图片，这样可以生成一个链接然
      
    
    </summary>
    
      <category term="无线安全" scheme="https://bluerbk.top/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="kali" scheme="https://bluerbk.top/tags/kali/"/>
    
      <category term="aircrack-ng" scheme="https://bluerbk.top/tags/aircrack-ng/"/>
    
      <category term="无线安全" scheme="https://bluerbk.top/tags/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于Socket的Java网络通信讲解与实例</title>
    <link href="https://bluerbk.top/2018/03/22/Java-SocketProgramming/"/>
    <id>https://bluerbk.top/2018/03/22/Java-SocketProgramming/</id>
    <published>2018-03-22T15:55:20.000Z</published>
    <updated>2018-03-22T17:06:58.173Z</updated>
    
    <content type="html"><![CDATA[<p>在之前学Jva的时候看到了这个Socket编程，觉得网络通信还是很有意思，比如说啊，可以通过Socket进行客户端和服务器端的通信，文字消息啊、文件传输啊之类的。<br>这次说一下关于Socket阻塞式和非阻塞式通信，进行文件传输和字符串的传输。同时，Socket的使用关键主要是对Java中的流的正确使用，主要是用DataInputStream、DataOutputStream、BufferedReader、PrintWriter等流，对文件的操作主要是FileInputStream和FileOutputStream。</p><h2 id="阻塞式通信"><a href="#阻塞式通信" class="headerlink" title="阻塞式通信"></a>阻塞式通信</h2><p>阻塞式通信是最简单的一种通信，通过缓冲区的相关方法（瞎扯）进行输出等操作，但是随之的问题便是，只能是一句一句的传输，比如我给服务器发送一个字符串，如果服务器端不进行回复的话，客户端只能处于等待状态，此时输入任何字符都没有用，但严格地说不是没有用，而是在缓冲区中，并没有显示出来，如果服务器端回复了会发现客户端的终端里有刚才输入的字符串。非阻塞式通信还是比较简单易懂，代码如下：<br>客户端代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">public class Socket_Client&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(&quot;\n\nClient Stsrted&quot;);</span><br><span class="line">Date date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">//构造socket连接，端口4700</span><br><span class="line">Socket socket=new Socket(&quot;127.0.0.1&quot;,4700);</span><br><span class="line">//系统标准输入设备</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">//构造socket的输出流，输出给客户端</span><br><span class="line">PrintWriter os=new PrintWriter(socket.getOutputStream());</span><br><span class="line">//构造socket的输入流，获取信息</span><br><span class="line">BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">try&#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">System.out.println(is.readLine()+&quot;\n&quot;);</span><br><span class="line">&#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">String readline;</span><br><span class="line">readline=br.readLine();</span><br><span class="line">while (!readline.equals(&quot;bye&quot;))&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">//将消息输出到socket</span><br><span class="line">os.println(readline+&quot;\t\t\t#&quot;+date.toString());</span><br><span class="line">//使服务器端立刻接收到消息</span><br><span class="line">os.flush();</span><br><span class="line">System.out.println(&quot;Server：&quot;+is.readLine());</span><br><span class="line">readline=br.readLine();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">os.close();</span><br><span class="line">is.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;catch(IOException e)&#123;System.out.println(&quot;Error&quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用Socket创建一个Socket对象用以进行连接，使用BufferedReader进行标准输入，如从控制台获取字符串或者从服务器端接受字符串信息。构造PrintWriter对象以输出字符串到服务器端。使用（PrintWriter）.println即可输出字符串到服务器端，在输出之后一定要记得调用（PrintWriter）.flush（）函数强制刷新缓冲区，相当于把字符串挤出去了，不然无法正确传输。程序结束之后要记得关闭相应的流，有些流垃圾回收器是不会进行处理的。<br>下面是服务器端的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">public class Socket_Server&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(&quot;\n\nServer Started&quot;);</span><br><span class="line">try&#123;</span><br><span class="line">ServerSocket server=null;</span><br><span class="line">try&#123;</span><br><span class="line">//创建一个serversocket监听4700端口</span><br><span class="line">server=new ServerSocket(4700);</span><br><span class="line">System.out.println(&quot;Waiting for connection......\n&quot;);</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Open Port falied &quot;+e);&#125;</span><br><span class="line">Socket socket=null;</span><br><span class="line">try&#123;</span><br><span class="line">//accept（）阻塞方法，如果有请求产生一个socket对象</span><br><span class="line">socket=server.accept();</span><br><span class="line">System.out.println(&quot;Socket get successfully&quot;+&quot;\t\t\t#&quot;+date.toString()+&quot;\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">String line;</span><br><span class="line">//由socket构造得到输入流，从socket获取输入信息</span><br><span class="line">BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">//由socket构造输出信息，从socket输出信息</span><br><span class="line">PrintWriter os=new PrintWriter(socket.getOutputStream());</span><br><span class="line">//标准输入设备获取输入</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">//获取客户端的消息</span><br><span class="line">os.println(&quot;Socket get successfully...Connection linked\t#&quot;+date.toString());</span><br><span class="line">os.flush();</span><br><span class="line">System.out.println(&quot;Client：&quot;+is.readLine()+&quot;\t\t\t#&quot;+date.toString());</span><br><span class="line">//获取服务端的信息</span><br><span class="line">line=br.readLine();</span><br><span class="line">while (!line.equals(&quot;bye&quot;))&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">//向客户端输出信息</span><br><span class="line">os.println(line+&quot;\t\t\t#&quot;+date.toString());</span><br><span class="line">//刷新输出流，使客户端立刻接收消息</span><br><span class="line">os.flush();</span><br><span class="line">System.out.println(&quot;Client：&quot;+is.readLine());</span><br><span class="line">line=br.readLine();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">//关闭socket输出流</span><br><span class="line">os.close();</span><br><span class="line">//关闭socket输出流</span><br><span class="line">is.close();</span><br><span class="line">//关闭socket和serversocket</span><br><span class="line">socket.close();</span><br><span class="line">server.close();</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了上面的客户端代码，服务器端应该也就更好理解了。服务器端的Socket是通过SocketServer建立一个对象server，负责监听指定端口是否有一个连接，如有链接，通过server.accept()阻塞式获取一个socket连接对象，进行通信传输。输入输出的相关函数用法同客户端，所以很好记的。同样，在程序结束之后记得关闭相应的流。</p><h2 id="非阻塞式通信"><a href="#非阻塞式通信" class="headerlink" title="非阻塞式通信"></a>非阻塞式通信</h2><p>有了上面说的阻塞式通信的例子，对非阻塞式通信从名字上应该有一点懂了吧，顾名思义就是不会碰到阻塞的情况，也就是不用等待服务器端的回复，我都可以一直想服务器端发送字符串，这就是非阻塞式通信。从思路上来看，我们需要使用到多线程，通过两个线程的运行，分别控制消息的接受和消息的发送，这样不用去等待对方回复。<br>但是非阻塞式带来的问题就是不好判定对方是否结束，一方中断连接的时候只可以中断一个线程，由于另一个线程在等待消息，可能是在一直等待输入也可能是在等待接收消息，即便是使用同步的方法也无法在两个这样的线程里传递信息，导致不能在一方就进行双向切断。<br>代码如下：<br>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Socket_Client&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(&quot;\n\nClient Stsrted&quot;);</span><br><span class="line">String ip=&quot;127.0.0.1&quot;;</span><br><span class="line">Date date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">//构造socket连接，端口4700</span><br><span class="line">Socket socket=new Socket(ip,4700);</span><br><span class="line">//系统标准输入设备</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">//构造socket的输出流，输出给客户端</span><br><span class="line">PrintWriter os=new PrintWriter(socket.getOutputStream());</span><br><span class="line">//构造socket的输入流，获取信息</span><br><span class="line">BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">try&#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">System.out.println(is.readLine()+&quot;\n&quot;);</span><br><span class="line">&#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">Client_SendThread send=new Client_SendThread(os);</span><br><span class="line">Client_PrintThread print=new Client_PrintThread(is,socket.getInetAddress().toString());</span><br><span class="line">Thread sendthread=new Thread(send);</span><br><span class="line">sendthread.start();</span><br><span class="line">Thread printthread=new Thread(print);</span><br><span class="line">printthread.start();</span><br><span class="line">printthread.join();</span><br><span class="line">sendthread.join();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">os.close();</span><br><span class="line">is.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Error&quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client_PrintThread implements Runnable&#123;</span><br><span class="line">private BufferedReader is;</span><br><span class="line">private String ip;</span><br><span class="line">public Client_PrintThread(BufferedReader is,String ip)&#123;</span><br><span class="line">super();</span><br><span class="line">this.is=is;</span><br><span class="line">this.ip=ip;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;print thread started&quot;);</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">String s=new String();</span><br><span class="line">String Server_Name=&quot;Server&quot;;</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">s=is.readLine();</span><br><span class="line">System.out.println(Server_Name+&quot;\t&quot;+s);</span><br><span class="line">if (s.split(&quot;:&quot;)[3].trim().equals(&quot;bye&quot;))&#123;</span><br><span class="line">ifrun=false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Sorry The link has been cut(Please input &quot;bye&quot; to end the link)\tprint thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Client_SendThread implements Runnable&#123;</span><br><span class="line">private PrintWriter os;</span><br><span class="line">public Client_SendThread(PrintWriter os)&#123;</span><br><span class="line">super();</span><br><span class="line">this.os=os;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;send thread started&quot;);</span><br><span class="line">String s=new String();</span><br><span class="line">Date date;</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">s=br.readLine();</span><br><span class="line">os.println(&quot;[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.flush();</span><br><span class="line">if (s.equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Sorry The link has been cut\tsend thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有两个线程Client_SendThread和Client_PrintThread，分别控制消息的发送和接受。也没有太多的难点，主要就是开两个线程即可。<br>服务器端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Socket_Server&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(&quot;\n\nServer Started&quot;);</span><br><span class="line">try&#123;</span><br><span class="line">ServerSocket server=null;</span><br><span class="line">try&#123;</span><br><span class="line">//创建一个serversocket监听4700端口</span><br><span class="line">server=new ServerSocket(4700);</span><br><span class="line">System.out.println(&quot;Waiting for connection......\n&quot;);</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Open Port falied &quot;+e);&#125;</span><br><span class="line">Socket socket=null;</span><br><span class="line">try&#123;</span><br><span class="line">//accept（）阻塞方法，如果有请求产生一个socket对象</span><br><span class="line">socket=server.accept();</span><br><span class="line">System.out.println(&quot;Socket get successfully&quot;+&quot;\t\t\t#&quot;+date.toString()+&quot;\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">String line;</span><br><span class="line">//由socket构造得到输入流，从socket获取输入信息</span><br><span class="line">BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">//由socket构造输出信息，从socket输出信息</span><br><span class="line">PrintWriter os=new PrintWriter(socket.getOutputStream());</span><br><span class="line">//标准输入设备获取输入</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">//获取客户端的消息</span><br><span class="line">os.println(&quot;Socket get successfully...Connection linked\t#&quot;+date.toString());</span><br><span class="line">os.flush();</span><br><span class="line">Server_SendThread send=new Server_SendThread(os);</span><br><span class="line">Server_PrintThread print=new Server_PrintThread(is,socket.getInetAddress().toString());</span><br><span class="line">Thread sendthread=new Thread(send);</span><br><span class="line">sendthread.start();</span><br><span class="line">Thread printthread=new Thread(print);</span><br><span class="line">printthread.start();</span><br><span class="line">printthread.join();</span><br><span class="line">sendthread.join();</span><br><span class="line">System.out.println(&quot;The MAINTHRED closed\t\tMAIN&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">//关闭socket输出流</span><br><span class="line">os.close();</span><br><span class="line">//关闭socket输出流</span><br><span class="line">is.close();</span><br><span class="line">//关闭socket和serversocket</span><br><span class="line">socket.close();</span><br><span class="line">server.close();</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Server_PrintThread implements Runnable&#123;</span><br><span class="line">private BufferedReader is;</span><br><span class="line">private String ip;</span><br><span class="line">Date date=new Date();</span><br><span class="line">public Server_PrintThread(BufferedReader is,String ip)&#123;</span><br><span class="line">super();</span><br><span class="line">this.is=is;</span><br><span class="line">this.ip=ip;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;print thread started&quot;);</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">String s=new String();</span><br><span class="line">String Client_Name=&quot;Client&quot;;</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">s=is.readLine();</span><br><span class="line">System.out.println(Client_Name+&quot;\t&quot;+s);</span><br><span class="line">if (s.split(&quot;:&quot;)[3].trim().equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Sorry The link has been cut(Please input &quot;bye&quot; to end the link)\tprint thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Server_SendThread implements Runnable&#123;</span><br><span class="line">MyObj obj=new MyObj();</span><br><span class="line">private PrintWriter os;</span><br><span class="line">public Server_SendThread(PrintWriter os)&#123;</span><br><span class="line">super();</span><br><span class="line">this.os=os;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;send thread started&quot;);</span><br><span class="line">String s=new String();</span><br><span class="line">Date date;</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">s=br.readLine();</span><br><span class="line">os.println(&quot;[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.flush();</span><br><span class="line">if (s.equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Sorry The link has been cut\tsend thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="同样也没有太多好说的。。。"><a href="#同样也没有太多好说的。。。" class="headerlink" title="同样也没有太多好说的。。。"></a>同样也没有太多好说的。。。</h2><p>下面是两个关于Socket有关的小栗子</p><h2 id="关于传输和接收的格式和方式"><a href="#关于传输和接收的格式和方式" class="headerlink" title="关于传输和接收的格式和方式"></a>关于传输和接收的格式和方式</h2><p>文件，不能像字符串那样直接发送，所幸的是Java中有一个强大的东西叫流，可以把文件转化成字节流，然后通过DataOutputStream将字节流发送出去，服务器端可以通过DataInputStream接受字节流，然后对字节流进行相应的处理，比如转换成字符串、写入某一个文件等等。<br><a href="https://blog.csdn.net/liuhenghui5201/article/details/8351574" target="_blank" rel="noopener">点击此处查看以下内容原文</a><br>以下是DataOutputStream的有关方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">构造函数：</span><br><span class="line"></span><br><span class="line">DataOutputStream(OutputStream out);//创建一个将数据写入指定输出流out的数据输出流。</span><br><span class="line"></span><br><span class="line">字段摘要：</span><br><span class="line"></span><br><span class="line">int written;//到目前为止写入数据流的字节数。</span><br><span class="line"></span><br><span class="line">主要方法：</span><br><span class="line"></span><br><span class="line">void write(byte[] b,int off,int len);//将byte数组off角标开始的len个字节写到OutputStream 输出流对象中。</span><br><span class="line"></span><br><span class="line">void write(int b);//将指定字节的最低8位写入基础输出流。</span><br><span class="line"></span><br><span class="line">void writeBoolean(boolean b);//将一个boolean值以1-byte形式写入基本输出流。</span><br><span class="line"></span><br><span class="line">void writeByte(int v);//将一个byte值以1-byte值形式写入到基本输出流中。</span><br><span class="line"></span><br><span class="line">void writeBytes(String s);//将字符串按字节顺序写入到基本输出流中。</span><br><span class="line"></span><br><span class="line">void writeChar(int v);//将一个char值以2-byte形式写入到基本输出流中。先写入高字节。</span><br><span class="line"></span><br><span class="line">void writeInt(int v);//将一个int值以4-byte值形式写入到输出流中先写高字节。</span><br><span class="line"></span><br><span class="line">void writeUTF(String str);//以机器无关的的方式用UTF-8修改版将一个字符串写到基本输出流。该方法先用writeShort写入两个字节表示后面的字节数。</span><br><span class="line"></span><br><span class="line">int size();//返回written的当前值。</span><br></pre></td></tr></table></figure></p><p>以下是有关DataInputStream的一些方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">构造方法：DataInputStream(InputStream in);</span><br><span class="line"></span><br><span class="line">主要方法：</span><br><span class="line"></span><br><span class="line">int read(byte[] b);//从输入流中读取一定的字节，存放到缓冲数组b中。返回缓冲区中的总字节数。</span><br><span class="line"></span><br><span class="line">int read(byte[] buf,int off,int len);//从输入流中一次读入len个字节存放在字节数组中的偏移off个字节及后面位置。</span><br><span class="line"></span><br><span class="line">String readUTF();//读入一个已使用UTF-8修改版格式编码的字符串</span><br><span class="line"></span><br><span class="line">String readLine();</span><br><span class="line"></span><br><span class="line">boolean readBoolean;</span><br><span class="line"></span><br><span class="line">int readInt();</span><br><span class="line"></span><br><span class="line">byte readByte();</span><br><span class="line"></span><br><span class="line">char readChar();</span><br></pre></td></tr></table></figure></p><p>转换成二进制格式也可以进行传输，使用InputStream和OutputStream进行发送和接受。</p><h2 id="简单的客户端和服务器端进行文件传输的例子"><a href="#简单的客户端和服务器端进行文件传输的例子" class="headerlink" title="简单的客户端和服务器端进行文件传输的例子"></a>简单的客户端和服务器端进行文件传输的例子</h2><p>由于是一个很简单的文件传输，但是使用的方法还是相当实用的，甚至比上面的阻塞式通信还实用（本人觉得），具体代码如下<br>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">class SendMsg&#123;</span><br><span class="line">public SendMsg(String[] args)throws Exception&#123;</span><br><span class="line">int Length;</span><br><span class="line">File file=new File(args[0]);</span><br><span class="line">FileInputStream fis=new FileInputStream(file);</span><br><span class="line">System.out.println(&quot;Get File Name Successfully\t&quot;);</span><br><span class="line">System.out.println(file.getName());</span><br><span class="line">DataInputStream in=new DataInputStream(fis);</span><br><span class="line">Length=fis.available();</span><br><span class="line">byte[] Byte=new byte[Length];</span><br><span class="line"></span><br><span class="line">in.read(Byte);</span><br><span class="line">Socket_FileSend(Byte,Length,file.getName());</span><br><span class="line">System.out.println(Length+&quot;\t&quot;+file.getName());</span><br><span class="line">fis.close();</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br><span class="line">public void Socket_FileSend(byte[] Byte,int Length,String name)&#123;</span><br><span class="line">System.out.println(&quot;Socket is ready to start&quot;);</span><br><span class="line">try&#123;</span><br><span class="line">Socket socket=new Socket(&quot;127.0.0.1&quot;,4700);</span><br><span class="line">DataOutputStream dos=new DataOutputStream(socket.getOutputStream());</span><br><span class="line">dos.writeUTF(name);</span><br><span class="line">dos.flush();</span><br><span class="line">dos.writeInt(Length);</span><br><span class="line">dos.flush();</span><br><span class="line">dos.write(Byte);</span><br><span class="line">dos.flush();</span><br><span class="line"></span><br><span class="line">socket.close();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">System.exit(1);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;File send successfully&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Socket_Client&#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">if (args.length&lt;1)&#123;</span><br><span class="line">System.out.println(&quot;Cannot find the file.Please input filename&quot;);</span><br><span class="line">System.exit(1);</span><br><span class="line">&#125;</span><br><span class="line">SendMsg send=new SendMsg(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用的时候记得传入一个正确的文件路径，否则会报错。</p><p>服务器端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">class GetMsg&#123;</span><br><span class="line">public GetMsg()throws Exception&#123;</span><br><span class="line">String name=new String();</span><br><span class="line">int Length;</span><br><span class="line">System.out.println(&quot;Waiting for Connection...&quot;);</span><br><span class="line">ServerSocket server=new ServerSocket(4700);</span><br><span class="line">Socket socket=server.accept();</span><br><span class="line">System.out.println(&quot;Connection get Successfully&quot;);</span><br><span class="line"></span><br><span class="line">DataInputStream dis=new DataInputStream(socket.getInputStream());</span><br><span class="line">name=dis.readUTF();</span><br><span class="line">Length=dis.readInt();</span><br><span class="line">System.out.println(name+&quot;\t&quot;+Length);</span><br><span class="line"></span><br><span class="line">byte[] Byte=new byte[Length];</span><br><span class="line">System.out.println(&quot;Get File successfully&quot;+Byte.length);</span><br><span class="line">File file=new File(name);</span><br><span class="line">FileOutputStream fos=new FileOutputStream(file);</span><br><span class="line">dis.read(Byte);</span><br><span class="line">fos.write(Byte);</span><br><span class="line">fos.flush();</span><br><span class="line">fos.close();</span><br><span class="line">System.out.println(&quot;write successfullt&quot;);</span><br><span class="line"></span><br><span class="line">server.close();</span><br><span class="line">socket.close();</span><br><span class="line"></span><br><span class="line">dis.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Socket_Server&#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">GetMsg send=new GetMsg();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一定要有这一步dis.read(Byte);不然Byte里面什么都没有，即便Byte.length也会出来正确的字节数，因为数组初始化了这么多的字节，即便里面没有内容。</p><h2 id="基于Socket的CSC模式通信"><a href="#基于Socket的CSC模式通信" class="headerlink" title="基于Socket的CSC模式通信"></a>基于Socket的CSC模式通信</h2><p>重头戏来了，这才是Socket应该做的事，我们进行通信当然是在客户端之间进行了，毕竟不可能点对点进行，我们需要使用服务器进行中转处理我们希望传输的内容以达到我们的要求。<br>基本思路如下，传输还是采用双线程的非阻塞式，客户端代码变动不大，服务器代码需要修改，在这里我假设是两台客户端进行通信，多个客户端相互通信或者群组通信原理差不多，可以类推。所有对象都需要两个，分别代表两个不同的客户端，如果是多客户端采用多线程建立多个对象即可。<br>重点的部分在这里，需要将接受的客户端1的信息发送给客户端2，接受的客户端2的信息发送给客户端1，这样就实现了信息的交换，建议实际写代码的时候可以画一个草图方便缕清思路，因为流真的有点多，稍微一乱的话就会搞不清了。<br>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Socket_Client&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(&quot;\n\nClient Started&quot;);</span><br><span class="line">String ip=&quot;204.44.91.156&quot;;</span><br><span class="line">Date date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">//构造socket连接，端口4700</span><br><span class="line">Socket socket=new Socket(ip,4700);</span><br><span class="line">//系统标准输入设备</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">//构造socket的输出流，输出给客户端</span><br><span class="line">PrintWriter os=new PrintWriter(socket.getOutputStream());</span><br><span class="line">//构造socket的输入流，获取信息</span><br><span class="line">BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">try&#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">System.out.println(is.readLine()+&quot;\n&quot;);</span><br><span class="line">&#125;catch(InterruptedException e)&#123;&#125;</span><br><span class="line">Client_SendThread send=new Client_SendThread(os);</span><br><span class="line">Client_PrintThread print=new Client_PrintThread(is,socket.getInetAddress().toString());</span><br><span class="line">Thread sendthread=new Thread(send);</span><br><span class="line">sendthread.start();</span><br><span class="line">Thread printthread=new Thread(print);</span><br><span class="line">printthread.start();</span><br><span class="line">printthread.join();</span><br><span class="line">sendthread.join();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">os.close();</span><br><span class="line">is.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Error&quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client_PrintThread implements Runnable&#123;</span><br><span class="line">private BufferedReader is;</span><br><span class="line">private String ip;</span><br><span class="line">public Client_PrintThread(BufferedReader is,String ip)&#123;</span><br><span class="line">super();</span><br><span class="line">this.is=is;</span><br><span class="line">this.ip=ip;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;print thread started&quot;);</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">String s=new String();</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">s=is.readLine();</span><br><span class="line">System.out.println(s);</span><br><span class="line">if (s.split(&quot;:&quot;).length&gt;3)&#123;</span><br><span class="line">if (s.split(&quot;:&quot;)[3].trim().equals(&quot;bye&quot;))&#123;</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Sorry The link has been cut(Please input &apos;bye&apos; to end the link)\tprint thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Client_SendThread implements Runnable&#123;</span><br><span class="line">private PrintWriter os;</span><br><span class="line">public Client_SendThread(PrintWriter os)&#123;</span><br><span class="line">super();</span><br><span class="line">this.os=os;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;send thread started&quot;);</span><br><span class="line">String s=new String();</span><br><span class="line">Date date;</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">s=br.readLine();</span><br><span class="line">os.println(s);</span><br><span class="line">os.flush();</span><br><span class="line">if (s.equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Sorry The link has been cut\tsend thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务器端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">//CSC模式经由服务器使得两个客户端之间进行非阻塞式通信</span><br><span class="line">public class Socket_Server&#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(&quot;\n\nServer Started&quot;);</span><br><span class="line">try&#123;</span><br><span class="line">ServerSocket server=null;</span><br><span class="line">try&#123;</span><br><span class="line">//创建一个serversocket监听4700端口</span><br><span class="line">server=new ServerSocket(4700);</span><br><span class="line">System.out.println(&quot;Waiting for connection......\n&quot;);</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Open Port falied &quot;+e);&#125;</span><br><span class="line">Socket socket_1=null,socket_2=null;</span><br><span class="line">//第一个客户端链接</span><br><span class="line">try&#123;</span><br><span class="line">//accept（）阻塞方法，如果有请求产生一个socket对象</span><br><span class="line">socket_1=server.accept();</span><br><span class="line">System.out.println(&quot;First Socket got successfully&quot;+&quot;\t\t\t#&quot;+date.toString()+&quot;\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">String line_1;</span><br><span class="line">//由socket构造得到输入流，从socket获取输入信息</span><br><span class="line">BufferedReader is_1=new BufferedReader(new InputStreamReader(socket_1.getInputStream()));</span><br><span class="line">//由socket构造输出信息，从socket输出信息</span><br><span class="line">PrintWriter os_1=new PrintWriter(socket_1.getOutputStream());</span><br><span class="line">//向第一个客户端发出信号</span><br><span class="line">os_1.println(&quot;You have got the Socket linked.Please waiting for another.\t#&quot;+date.toString());</span><br><span class="line">os_1.flush();</span><br><span class="line">//第二个客户端链接</span><br><span class="line">try&#123;</span><br><span class="line">//accept（）阻塞方法，如果有请求产生一个socket对象</span><br><span class="line">socket_2=server.accept();</span><br><span class="line">System.out.println(&quot;Second Socket got successfully&quot;+&quot;\t\t\t#&quot;+date.toString()+&quot;\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">String line_2;</span><br><span class="line">//由socket构造得到输入流，从socket获取输入信息</span><br><span class="line">BufferedReader is_2=new BufferedReader(new InputStreamReader(socket_2.getInputStream()));</span><br><span class="line">//由socket构造输出信息，从socket输出信息</span><br><span class="line">PrintWriter os_2=new PrintWriter(socket_2.getOutputStream());</span><br><span class="line">//向第二个客户端发出信号</span><br><span class="line">os_2.println(&quot;You have got the Socket linked.Please waiting for another.\t#&quot;+date.toString());</span><br><span class="line">os_2.flush();</span><br><span class="line">//链接成功，发出信号</span><br><span class="line">os_1.println(&quot;Both Socket Linked Successfully&quot;);</span><br><span class="line">os_1.flush();</span><br><span class="line">os_2.println(&quot;Both Socket Linked Successfully&quot;);</span><br><span class="line">os_2.flush();</span><br><span class="line">System.out.println(&quot;Both linked successfully&quot;);</span><br><span class="line">//开始通信</span><br><span class="line">Two_to_One two_to_one=new Two_to_One(is_2,socket_2,os_1);</span><br><span class="line">One_to_Two one_to_two=new One_to_Two(is_1,socket_1,os_2);</span><br><span class="line">Thread two_to_one_thread=new Thread(two_to_one);</span><br><span class="line">two_to_one_thread.start();</span><br><span class="line">Thread one_to_two_thread=new Thread(one_to_two);</span><br><span class="line">one_to_two_thread.start();</span><br><span class="line">one_to_two_thread.join();</span><br><span class="line">two_to_one_thread.join();</span><br><span class="line">System.out.println(&quot;The MAINTHRED closed\t\tMAIN&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nConnection has closed\nBYEBYE&quot;);</span><br><span class="line">//关闭socket输出流</span><br><span class="line">os_1.close();</span><br><span class="line">os_2.close();</span><br><span class="line">//关闭socket输出流</span><br><span class="line">is_1.close();</span><br><span class="line">is_2.close();</span><br><span class="line">//关闭socket和serversocket</span><br><span class="line">socket_1.close();</span><br><span class="line">socket_2.close();</span><br><span class="line">server.close();</span><br><span class="line">&#125;catch(Exception e)&#123;System.out.println(&quot;Error &quot;+e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class One_to_Two implements Runnable&#123;</span><br><span class="line">private BufferedReader is;</span><br><span class="line">private PrintWriter os;</span><br><span class="line">private String ip=new String();</span><br><span class="line">Date date=new Date();</span><br><span class="line">public One_to_Two(BufferedReader is_1,Socket socket_1,PrintWriter os_2)&#123;</span><br><span class="line">super();</span><br><span class="line">this.os=os_2;</span><br><span class="line">this.is=is_1;</span><br><span class="line">this.ip=socket_1.getInetAddress().getHostAddress();</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;print thread started&quot;);</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">String s=new String();</span><br><span class="line">String Client_Name_1=ip;</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">s=is.readLine();</span><br><span class="line">System.out.println(Client_Name_1+&quot;\t[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.println(Client_Name_1+&quot;\t[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.flush();</span><br><span class="line">if (s.equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//os.println(&quot;Sorry The link has been cut(Please input &apos;bye&apos; to end the link)\tprint thread closed&quot;);</span><br><span class="line">//os.flush();</span><br><span class="line">System.out.println(ip+&quot;has cut his sendthread\nanother has been cut the printthread&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Two_to_One implements Runnable&#123;</span><br><span class="line">private PrintWriter os;</span><br><span class="line">private BufferedReader is;</span><br><span class="line">Date date=new Date();</span><br><span class="line">String ip=new String();</span><br><span class="line">public Two_to_One(BufferedReader is_2,Socket socket_2,PrintWriter os_1)&#123;</span><br><span class="line">super();</span><br><span class="line">this.is=is_2;</span><br><span class="line">this.ip=socket_2.getInetAddress().getHostAddress();</span><br><span class="line">this.os=os_1;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;send thread started&quot;);</span><br><span class="line">String s=new String();</span><br><span class="line">String Client_Name_2=ip;</span><br><span class="line">boolean ifrun=true;</span><br><span class="line">while (ifrun)&#123;</span><br><span class="line">date=new Date();</span><br><span class="line">try&#123;</span><br><span class="line">s=is.readLine();</span><br><span class="line">System.out.println(Client_Name_2+&quot;\t[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.println(Client_Name_2+&quot;\t[&quot;+date.toString()+&quot;]: &quot;+s);</span><br><span class="line">os.flush();</span><br><span class="line">if (s.equals(&quot;bye&quot;))</span><br><span class="line">ifrun=false;</span><br><span class="line">&#125;catch(IOException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Sorry The link has been cut\tsend thread closed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其实难点也没有太多，处理好两个服务器之间输入输出流的关系就可以了，之后就像普通的Socket通信一样即可。"><a href="#其实难点也没有太多，处理好两个服务器之间输入输出流的关系就可以了，之后就像普通的Socket通信一样即可。" class="headerlink" title="其实难点也没有太多，处理好两个服务器之间输入输出流的关系就可以了，之后就像普通的Socket通信一样即可。"></a>其实难点也没有太多，处理好两个服务器之间输入输出流的关系就可以了，之后就像普通的Socket通信一样即可。</h2><p>今天就到这吧，可能因为今天代码有点多，已经两万个字符了。我现在在进行C#和Java的通信学习，也是通过Socket，Java负责编写服务器端，目前已经可以正常连接了，下面需要的就是进行相应的数据传输任务即可。等有成效了还会写一个文章的。<br>PS.这些代码都是经过测试的，不仅是在我本地测试过，还用同学的电脑进行真实CSC模式的连接，完美成功实现了。</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前学Jva的时候看到了这个Socket编程，觉得网络通信还是很有意思，比如说啊，可以通过Socket进行客户端和服务器端的通信，文字消息啊、文件传输啊之类的。&lt;br&gt;这次说一下关于Socket阻塞式和非阻塞式通信，进行文件传输和字符串的传输。同时，Socket的使用关键
      
    
    </summary>
    
      <category term="Java" scheme="https://bluerbk.top/categories/Java/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://bluerbk.top/tags/Java/"/>
    
      <category term="Socket" scheme="https://bluerbk.top/tags/Socket/"/>
    
      <category term="网络编程" scheme="https://bluerbk.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="多线程" scheme="https://bluerbk.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C#基础伪教程（二）</title>
    <link href="https://bluerbk.top/2018/03/18/CSharp-Second-Teaching/"/>
    <id>https://bluerbk.top/2018/03/18/CSharp-Second-Teaching/</id>
    <published>2018-03-18T08:53:09.000Z</published>
    <updated>2018-03-18T15:20:05.893Z</updated>
    
    <content type="html"><![CDATA[<p>今天啥都没干，干脆写一点C#吧，就当作是第二个教程了，不多说，进入正题。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是用class关键字定义声明，具体框架如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class name</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>public属于访问修饰符，表示访问权限，也可以为protected、internal或者private。<br>C#的类同样支持继承，被继承的类称为基类，继承基类的类称作派生类。派生类可以使用基类的数据、行为的基础上创建自己的数据和行为。<br>类的主题成员有</p><blockquote><p>字段<br>属性<br>方法<br>构造函数<br>析构函数</p></blockquote><hr><p>对象的创建使用new关键字<br>    Class class=new Class();</p><h3 id="静态类和静态成员"><a href="#静态类和静态成员" class="headerlink" title="静态类和静态成员"></a>静态类和静态成员</h3><p>静态类是不能被实例化的，不能通过new创建对象，只能通过类去直接访问内部成员。一般类中也可以包含静态成员，同样，不能被对象访问，只能由类去访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static class car</span><br><span class="line">&#123;</span><br><span class="line">public static string WriteName()&#123;</span><br><span class="line">return &quot;这是静态成员&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">car.WriteName();</span><br></pre></td></tr></table></figure></p><p>静态类有以下几个特点：</p><ul><li>静态类的所有成员都是静态成员</li><li>静态类不能被实例化</li><li>静态类是封装的，不能被继承</li><li>静态类不能包含实例构造函数，但是可以定义静态构造函数<br>静态成员有以下几个特点：</li><li>含有静态成员的类必须有静态构造函数来初始化</li><li>静态字段通常用来记录实例对象的个数或存储该类所有对象的共享值</li><li>静态方法可以被重载但不能被重写</li><li>局部变量不能被声明为静态变量，如方法中不能声明静态变量</li></ul><h3 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h3><p><strong>字段</strong>默认为私有，可以被标记为public、private、protected、internal或protected internal，还可以声明为<strong>只读变量</strong>，用readonly关键字声明。<br>只读字段只能在初始化或者在构造函数中赋值，静态只读字段类似于常量，但是不能在编译的时候访问，而是在运行的时候访问。<br>字段通常具有以下属性：</p><ul><li>字段可以被类的多个方法访问，否则可以在方法内部定义变量，而非定义类的字段</li><li>字段的生命周期比类中的单个方法的生命期长</li><li>字段可以在声明时赋值，若构造函数包含了字段的初始值，则字段声明值将被覆盖。</li><li>字段出四肢不能引用其他实例字段，但是可以是其他类的静态字段<br>如定义公共的静态只读字段num<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static readonly int num;</span><br></pre></td></tr></table></figure></li></ul><hr><p>若字段被标记为私有则只能通过<strong>属性</strong>来进行访问。<br>属性结合了字段的方法和属性，既可以被当作特殊的方法使用，也可以作为普通字段进行使用。<br>除了访问修饰符，属性还可以具有以下标记</p><blockquote><p>static        静态属性<br>virtual       虚属性<br>sealed        它对派生类不再是虚拟的<br>abstract      在派生类中实现</p></blockquote><p>属性具有get访问器或set访问器或同时拥有，两者可以具有不同的访问修饰符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可访问类型  类型  名称</span><br><span class="line">&#123;</span><br><span class="line">get &#123;&#125;</span><br><span class="line">set &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>get和set均可省略。若只有get则为只读属性，若只有set则为只写属性。<br>get和set相当于Java中私有封装的getter和setter。<br>具体用法如下：</p><blockquote><p>get访问器与方法类似，它必须返回属性类型的值作为属性的值，当引用属性的时候，若没有为属性赋值，则调用get访问器获取属性的值<br>get访问器必须以return或throw结尾，并且控制权不能离开访问器<br>get访问器除了直接返回字段值，还可以通过计算返回字段值<br>set访问器类似于返回类型为void的方法，它使用属性类型的value隐式参数，当对属性赋值时，用提供心智的参数调用set访问器<br>在set访问器中，对据变量声明使用隐式参数名称value是错误的。</p></blockquote><p>使用属性的时候就像是使用方法一样，简单示例代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//第一个</span><br><span class="line">public class count</span><br><span class="line">&#123;</span><br><span class="line">public int num;</span><br><span class="line">public int addnum</span><br><span class="line">&#123;</span><br><span class="line">get &#123; return num + 10; &#125;</span><br><span class="line">set &#123;num = value - 100; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">count id=new count();</span><br><span class="line">id.num=200;</span><br><span class="line">Console.WriteLine(id.addnum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出为</span><br><span class="line">300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二个</span><br><span class="line">public class age</span><br><span class="line">&#123;</span><br><span class="line">public int agenum;</span><br><span class="line">public int num</span><br><span class="line">&#123;</span><br><span class="line">get &#123; return ageuum; &#125;</span><br><span class="line">set </span><br><span class="line">&#123;</span><br><span class="line">if ((value &gt; 0)&amp;&amp;(value &lt; 200))</span><br><span class="line">&#123;</span><br><span class="line">value = agenum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">age ageo=new age();</span><br><span class="line">ageo.num=300;</span><br><span class="line">Console.WriteLine(ageo.agenum);</span><br><span class="line">ageo.agenum=70;</span><br><span class="line">Console.WriteLine(ageo.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果为</span><br><span class="line">0</span><br><span class="line">70</span><br></pre></td></tr></table></figure></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法在类中声明，具体格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问级别 是否静态 返回值类型 方法名 （参数类型 参数1，参数类型 参数2...）</span><br><span class="line">｛...｝</span><br></pre></td></tr></table></figure></p><p><strong>关于参数</strong><br>分为按值传递和按引用传递。<br>前者即为传入该变量的副本，对其形式参数进行使用，不影响原变量的值。<br>后者即为引用，如C语言中的&amp;，直接对变量本身进行操作，不使用副本。在参数前加修饰符ref或out即可。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是类调用中首先执行的函数，构造函数是方法的一种，与方法唯一不同的时构造函数在创建累的对象时执行的类方法，构造函数要与类名同名，不需要写返回值类型。构造函数可以被标记为public、protected、private、internal或者protected internal。<br>若没有写构造函数，在C#编译器中将自动添加一个默认构造函数，来实例化对象，并将所有成员变量设置为各自类型的默认值。<br><strong>静态类</strong>也有构造函数，作用于非静态类构造函数一样，但静态类中构造函数为静态构造函数。<br>构造函数可分为静态构造函数、实例化构造函数和私有化构造函数等。<br>静态构造函数特点如下：</p><blockquote><p>静态构造函数访问修饰符和参数<br>静态构造函数在首次访问类的时候自动调用<br>静态构造函数由编译器控制调用，开发人员无法直接调用静态构造函数<br>私有化构造函数是一种特殊的实例构造函数。它通常用在只包含静态成员的类中，如果类中具有一个或多个私有构造函数而没有公共构造函数，则不允许其他类创建该类的实例。<br>多态允许具有多个含不同参数的构造函数，根据参数的不同选用对应的构造函数。<br><strong>在一个构造函数中可以通过this关键字调用其他的构造函数。</strong></p></blockquote><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数是用来释放类资源的，它与一般方法有很大区别，主要有以下几点：</p><ul><li>一个类只能有一个析构函数</li><li>析构函数不能被继承</li><li>析构函数由编译器调节，开发人员无法控制何时调用，由垃圾回收起决定</li><li>析构函数没有访问修饰符和参数</li><li>析构函数不能定义返回值类型，也没有返回值</li><li>程序退出时自动执行析构函数</li></ul><p>命名的时候在名字前面加’~’以和构造函数区分开<br>通过调用Collect强制进行资源释放，但是可能会导致程序性错误。通过来自IDisposable接口的Dispose（）可以显式地释放一些资源，为对象执行必要的清理。虽然会提高性能但垃圾回收期还是会调用析构函数对对象进行彻底清理。</p><h2 id="类的高级应用"><a href="#类的高级应用" class="headerlink" title="类的高级应用"></a>类的高级应用</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>对类本身，内部成员属性及方法确定是否可被访问等，是否该被隐藏。<br>密封类，不可被继承，通常用来限制扩展性。<br>public sealed class D{…}<br>除此之外与其他类区别不大，可以实例，可以私有，可以共有等。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>C#中，所有类都是直接或间接地继承Object类。类可以被连环继承。继承如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class News&#123;...&#125;</span><br><span class="line">class SportsNews:News&#123;...&#125;</span><br></pre></td></tr></table></figure></p><h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><p>又被称为虚函数，是一种可以被派生类实现、重载或冲写的方法，虚函数同选择语句一样有执行条件，根据不同情况实现。一般方法在编译时就静态地编译到执行文件中，其相对地址在程序运行期间是不变的。但是虚函数在编译期间不能被静态编译，它相对地址是不变的。<br>虚方法根据运行时期对象实例来动态判断要调用的函数，其中声明时定义的类交声明类，执行时实例化的类叫实例类。虚方法有以下特点，如下所示：</p><ul><li>虚方法通过virtual关键字实现</li><li>虚方法通过override关键字在派生类中实现</li><li>虚方法前不允许有static、abstract或override修饰符</li><li>虚方法不能是私有的，因此不能使用private修饰符</li></ul><p>虚函数执行过程如下所示</p><ol><li>当调用一个对象的函数时，系统会直接去检查这个函数声明所在的类，即声明类，查看函数是否为虚函数</li><li>若不是虚函数，那么直接执行该函数。但如果是虚函数，那么程序不会立刻执行该函数，而是检查对象的实例类，即继承函数声明的类</li><li>在这个实例类，程序将检查这个实例类的定义中是否包含实现该虚函数或者重写虚函数的方法</li><li>如果有，执行实例类中实现的虚函数的方法。如果没有，系统就会不停地往上找实例类的父类，并对父类重复刚才在实例类里的检查，直到找到第一个重载该虚函数的父类为止，然后执行该父类里冲在后的方法</li></ol><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种仅用于继承的类。定义一个抽象类的目的主要是为派生类提供可共享的基类成员的公共生命。抽象类对象的抽象成员只有声明部分，没有实现部分。抽象类中的成员实现完全由继承抽象类的派生了来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class A&#123;</span><br><span class="line">public abstract int B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象类的继承必须实现对抽象类中所有未实现的成员，包括属性和方法。抽象类中抽象成员的实现和虚函数的实现一样，在方法名前用override关键字。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>类的方法有三种多态形式</p><blockquote><p>定义同名但参数列表不同的方法，被称为方法的重载<br>定义同名且参数列表也相同的方法，并且父类中的方法用abstract/virtual进行修饰，成为方法的覆盖。子类中的同名方法也用override进行修饰，如虚方法和抽象类的覆盖<br>定义相同且参数列表也相同的方法，其父类中的方法没有用abstract/virtual进行修饰，称为方向的隐藏。</p></blockquote><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><ul><li>方法名必须相同。</li><li>返回值可以相同也可以不同，但参数列表不能相同，因为编译器首先根据方法名选择方法，再根据参数列表在众多重载函数中找到合适的。</li><li>匹配函数时，编译器将不区分类型引用和类型本身，也不区分const和非const变量。</li></ul><h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>有两种形式，覆盖（只能重写被abstract和virtual关键字修饰的方法，在中写的时候需要关键字override）和隐藏（直接使用new关键字重写基类中的一般方法）。<br><strong>重写时针对方法名相同，擦书列表也相同的方法的多态</strong>，通常时在子类中重写基类的方法。<br>重写有以下几个特点</p><ul><li>静态方法、密封方法和非虚方法不能被覆盖。</li><li>非虚方法可以被隐藏，但静态方法和密封方法不能被隐藏。</li><li>重写方法和已重写了的基方法具有相同的返回类型。</li><li>重写声明和已重写了的基方法具有相同的声明可访问性。重写声明不能更改所对应的虚方法的可访问性。<br>如果已重写的基方法时protected internal，并且生命它的程序集不是包含重写方法的程序集，则重写方法声明的可访问性必须是protected。</li></ul><hr><p>关于后面的几个概念的举例，我懒得写了，需要的时候上网查一下就好了（估计一般也用不太上），就这样</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天啥都没干，干脆写一点C#吧，就当作是第二个教程了，不多说，进入正题。&lt;/p&gt;
&lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;p&gt;类是用class关键字定义声明，具体框架如下&lt;br&gt;&lt;fig
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>C#基础伪教程（一）</title>
    <link href="https://bluerbk.top/2018/03/17/C-First-Teaching/"/>
    <id>https://bluerbk.top/2018/03/17/C-First-Teaching/</id>
    <published>2018-03-17T15:56:30.000Z</published>
    <updated>2018-03-17T16:13:04.653Z</updated>
    
    <content type="html"><![CDATA[<p>由于之前学过Java的相关知识，但是由于Java在桌面程序表现的无力，决定选择新的语言，在QT和C#中还是选择了C#，不瞎扯了，我也不会扯，简单粗暴一点，C#语法和Java也很类似。<br>老规矩，我写的教程一向都是伪教程，指不定哪天我都看不懂的那种。</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>我采用的是VSCode工具，虽然我也有VS2013，但是它的体积真的很庞大，写点小代码不太划算，还相当占内存。于是我采用VSCode。<br>首先得添加C#插件，<a href="https://www.microsoft.com/net/download/windows" target="_blank" rel="noopener">点击此处下载.NET Core SDK</a><br>随后安装，成功后重启VSCode<br>打开cmd控制台，任意进入一个路径，执行命令</p><pre><code>dotnet new console dotnet run</code></pre><p>第一个是在当前目录下创建C#控制台程序，第二个命令是运行程序，默认为输出”HelloWorld！“。随后在VSCode中打开对应目录下的.cs文件，进行编写，编译执行即可</p><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>下面一段C#的代码</p><pre><code>using System;namespace C_{    class Program    {        static void Main(string[] args)        {                Console.Write(&quot;Hello,&quot;);            Console.WriteLine(&quot;World&quot;);        }    }}</code></pre><p>由上可见，C#代码包含命名空间，类名和函数名。与其他语言的区别有这些，主函数名为Main，而不是main，类Console在System命名空间中，调用Console类中的Write()和WriteLine()方法向控制台进行输出。<br>Ps.第一个末尾不带换行，第二个自带换行。<br>一个简单的C#程序就编写成功了。</p><h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>如下代码示例装箱<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int val=100;</span><br><span class="line">object obj=val;</span><br><span class="line">Console.WriteLine(&quot;对象的值为=&#123;0&#125;&quot;,obj);</span><br></pre></td></tr></table></figure></p><p>object为任意类型，使用一个非泛型容器，保证其通用性。<br>拆箱示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int val=100;</span><br><span class="line">object obj=val;</span><br><span class="line">int num=(int)obj;</span><br><span class="line">Console.WrtieLine(&quot;num=&#123;0&#125;&quot;,num);</span><br></pre></td></tr></table></figure></p><p>可以转换成原本属于的类型，也可以强制转换到任意可以相容的容易，所以必须显式强制类型转换。</p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>像for(;;)、while()、do … while ();、if、switch等几乎通用，便不多赘述。在此写一个C#新见的一种循环，和用过的迭代器很像。<br>foreach (变量生命 in 数组名或集合类），代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] num=new int [5]&#123;1,2,3,4,5&#125;;</span><br><span class="line">foreach (int i in num)</span><br><span class="line">&#123;</span><br><span class="line">Console.Write(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出为：12345</p><hr><p>跳转语句，例如goto，continue等，也和其他语言区别不大。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>按照Java的方式，如获得一个int数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] num=new int[3]&#123;1,2,3&#125;;</span><br><span class="line">int[] num=&#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure></p><p>可以通过这样进行数组的初始化赋值。<br>二维数组，如下例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[,] num=new int[3,3]&#123;...&#125;;</span><br><span class="line">int[,] num=&#123;</span><br><span class="line">&#123;3,3,3&#125;,</span><br><span class="line">&#123;2,2,2&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>多维数组同二维数组，如[,]变为[,,]即可。</p><h4 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h4><p>即不规则数组<br>如如下定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] inter=new int[3][];</span><br><span class="line">inter[0]=new int[4]&#123;1,2,3,4&#125;;</span><br><span class="line">inter[1]=new int[3]&#123;1,2,3&#125;;</span><br><span class="line">inter[2]=new int[5]&#123;1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure></p><p>即inter数组内容为下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure></p><p>上面说的数组都是静态数组，在<strong>System.Array</strong>类中针对静态数组提供了一些操作的属性及方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Length//数组长度，为32位整数</span><br><span class="line">LongLength//数组长度，为64位整数</span><br><span class="line">Rank//数组的秩，即维度</span><br><span class="line">IsReadOnly//数组是否可读</span><br><span class="line">IsFixedSize//数组大小是否固定</span><br><span class="line">IsSynchronized//是否同步访问数组</span><br><span class="line">SyncRoot//获取同步访问数组的对象</span><br><span class="line"></span><br><span class="line">GetValue()//获取指定元素的值</span><br><span class="line">SetValue()//设置指定元素的值</span><br><span class="line">Clear（）//清除数组的所有元素</span><br><span class="line">IndexOf()//获取匹配的第一个元素的索引</span><br><span class="line">LaseIndexOf()//获取匹配的最后一个元素的索引</span><br><span class="line">Sort()//对一维数组排序</span><br><span class="line">Reverse()//反转一维数组的元素</span><br><span class="line">GetLength()//获取指定唯独数组的元素数量，32位整数</span><br><span class="line">GetLongLength//获取指定维度的数组的元素数量，64位整数</span><br><span class="line">FindIndex()//搜索指定元素，并获取第一个匹配元素的索引</span><br><span class="line">FindLastIndex()//搜索指定元素，并获取最后一个匹配元素的索引</span><br><span class="line">Copy()//复制一个数组的部分元素到另一个数组</span><br><span class="line">CopyTo()//将一维数组中的所有元素复制到另一个一维数组中</span><br><span class="line">Clone()//复制数组</span><br><span class="line">ConstrainedCopy()//指定开始位置，并复制一系列元素到另一个数组</span><br><span class="line">BinarySearch()//二进制搜索算法在一维的排序数组中搜索指定元素</span><br><span class="line">GetLowerBound()//获取数组中指定维度的下限</span><br><span class="line">GetUpperBound()//获取数组中指定维度的上限</span><br></pre></td></tr></table></figure></p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>动态数组能够在程序的执行中改变数组的长度，可以增加、释放元素所占的空间，又被称为可变数组。这里主要说由System.ArrayList实现得动态数组。<br>需要导入命名空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br></pre></td></tr></table></figure></p><p>创建动态数组对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list=new ArrayList();</span><br></pre></td></tr></table></figure></p><p>ArrayList类的属性及方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Capacity//数组容量</span><br><span class="line">Count //数组元素的数量</span><br><span class="line">IsFixedSize//数组大小是否固定</span><br><span class="line">IsReadOnly//数组是否为只读</span><br><span class="line">IsSynchronized//是否同步访问数组</span><br><span class="line">SyncRoot//获取同步访问数组的对象</span><br><span class="line"></span><br><span class="line">Adapter()//为指定的IList创建ArrayList包装</span><br><span class="line">Add()//将对象添加到ArrayList的尾部</span><br><span class="line">AddRange()//将ICollection的元素添加到ArrayList的尾部</span><br><span class="line">BinarySearch()//使用对分检索算法在已排序的ArrayList或它的一部分查找特定元素</span><br><span class="line">Clear()//移除所有元素</span><br><span class="line">Clone()//创建ArrayList的浅表副本</span><br><span class="line">Contains//确定某元素是否在ArrayList中</span><br><span class="line">CopyTo()//将ArrayList或它的一部分复制到一维数组中</span><br><span class="line">Equals()//确定两个Object实例是否相等</span><br><span class="line">FixedSize()//返回具有固定大小的列表包装，其中的元素允许修改，但不允许添加或移除</span><br><span class="line">GetEnumerator()//返回循环访问ArrayList的枚举数</span><br><span class="line">GetHashCode()//用于特定类型的哈希函数，GetHshCode适合在哈希算法和数据结构（哈希表等）中使用</span><br><span class="line">GetRange()//返回ArrayList，它表示源ArrayList中元素的子集</span><br><span class="line">GetType()//获取当前实例的Type</span><br><span class="line">IndexOf()//返回ArrayList或它的一部分中某个值的第一个匹配项的从零开始的索引</span><br><span class="line">Insert()//将元素插入ArrayList指定的索引处</span><br><span class="line">InsertRange()//将集合中的某个元素插入ArrayList的指定索引处</span><br><span class="line">LastIndexOf()//返回ArrayList或它的一部分中某个值的最后一个匹配项的从零开始的索引</span><br><span class="line">ReadOnly()//返回只读的列表包装</span><br><span class="line">ReferenceEquals()//确定指定的Object实例是否是相同的实例</span><br><span class="line">Remove()//从ArrayList移除特定对象的第一个匹配项</span><br><span class="line">RemoveAt()//移除ArrayList的指定索引处的元素</span><br><span class="line">RemoveRange()//从ArrayList中移除一定范围的元素</span><br><span class="line">Repeat()//返回ArrayList，它元素是指定值的副本</span><br><span class="line">Reverse()//将ArrayList或它的一部分元素顺序反转</span><br><span class="line">SetRange()//将集合中的元素复制到ArrayList中的一定范围的元素上</span><br><span class="line">Sort()//堆ArrayList或它的一部分的元素进行排序</span><br><span class="line">Synchronized()//返回同步的（线程安全）列表包装</span><br><span class="line">ToArray()//将ArrayList的元素复制到新的数组中</span><br><span class="line">ToString()//返回当前Object的String</span><br><span class="line">TrimTpSize()//将容量设置为ArrayList中元素的实际数目</span><br></pre></td></tr></table></figure></p><hr><h3 id="动态数组的应用"><a href="#动态数组的应用" class="headerlink" title="动态数组的应用"></a>动态数组的应用</h3><p>添加数组元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list=new ArrayList();</span><br><span class="line">list.Add(1);</span><br><span class="line">list.insert(3,0);</span><br></pre></td></tr></table></figure></p><p>由于ArrayList中元素的类型位Object，若要使用foreach语句则为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach (object obj in list)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>删除数组元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Remove(2);</span><br><span class="line">list.RemoveAt(1);</span><br><span class="line">list.RemoveRange(2,5);</span><br></pre></td></tr></table></figure></p><hr><p>打这么多名字有点累，可能会出错，但是报错应该还是很友好的，百度一下就知道该怎么用了。</p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于之前学过Java的相关知识，但是由于Java在桌面程序表现的无力，决定选择新的语言，在QT和C#中还是选择了C#，不瞎扯了，我也不会扯，简单粗暴一点，C#语法和Java也很类似。&lt;br&gt;老规矩，我写的教程一向都是伪教程，指不定哪天我都看不懂的那种。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="C#" scheme="https://bluerbk.top/categories/C/"/>
    
    
      <category term="编程" scheme="https://bluerbk.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C#" scheme="https://bluerbk.top/tags/C/"/>
    
      <category term="dotnet" scheme="https://bluerbk.top/tags/dotnet/"/>
    
      <category term="Microsoft" scheme="https://bluerbk.top/tags/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title>使用HEXO+GITHUB搭建自己的博客</title>
    <link href="https://bluerbk.top/2018/03/15/hexo_use/"/>
    <id>https://bluerbk.top/2018/03/15/hexo_use/</id>
    <published>2018-03-15T15:47:44.000Z</published>
    <updated>2018-03-17T15:53:01.433Z</updated>
    
    <content type="html"><![CDATA[<p>博客这个东西很多网站都有，什么博客园、CSDN、简书之类的。上周还在考虑在网站上写博客，因为我一直都是自己在本地写word或者txt来记录的。突发奇想自己搭一个博客来写，又高大上还记录了还练手了。说做就做，用了两天时间差不多把基本功能实现了。</p><h4 id="使用的工具和环境"><a href="#使用的工具和环境" class="headerlink" title="使用的工具和环境"></a>使用的工具和环境</h4><ul><li>Windows7 x64</li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js v8.1</a></li><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git 2.16.2</a></li><li><a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkdownPad 2</a></li></ul><p>本文主要说一下博客的搭建，hexo和github联系起来，初步发布文章，修改主题，还会说一些存在的坑。（随缘配图）<br><a href="https://www.appinn.com/markdown/#img" target="_blank" rel="noopener">点击此处查看Markdown语法说明</a></p><h2 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h2><h3 id="node-js的安装"><a href="#node-js的安装" class="headerlink" title="node.js的安装"></a>node.js的安装</h3><p>运行node.js安装包，一路next，完成安装，退出。<br>随后打开控制台界面（ctrl-R，输入cmd回车）<br>运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果依次出现相对应的版本号，则表示安装成功。</p><h3 id="Git的安装和配置"><a href="#Git的安装和配置" class="headerlink" title="Git的安装和配置"></a>Git的安装和配置</h3><p>运行下载的Git安装包，进入Git的安装<br>当到了Git PATH的步骤时，选择“Use Git from the Windows Command Prompt“这个选项，这是为了将Git添加到系统环境变量里，不用再单独打开git bash运行命令了，cmd即可运行。<br>安装成功后，执行如下命令，若安装成功则会出现Git的版本号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -version</span><br></pre></td></tr></table></figure></p><h3 id="github账号的注册和配置"><a href="#github账号的注册和配置" class="headerlink" title="github账号的注册和配置"></a>github账号的注册和配置</h3><p><a href="https://github.com/" target="_blank" rel="noopener">点击此处</a>或打开链接<a href="https://github.com/，进行账号注册" target="_blank" rel="noopener">https://github.com/，进行账号注册</a><br>之后进入注册时填的邮箱，确认账号，不然无法成功。注册成功后，点击右上角的头像，点击 New repository，在Repository name下填写yourname.github.io，即你的github page网站的名字（比如我的是 RBK.github.io)<br>创建成功后，代码库的右上角点击 Setting，向下找Github Page，选择master然后配置主题什么的，之后直接登录你的网站即可看到你的github page。<br>如登陆 blueprok.github.io/RBK.github.io 就是我的主页。在Setting页面的最右下也有写你的网站地址。</p><h3 id="HEXO的安装和配置"><a href="#HEXO的安装和配置" class="headerlink" title="HEXO的安装和配置"></a>HEXO的安装和配置</h3><p>最关键的地方来了，我在搭建的时候就在这折腾了一天。后面会写碰到的问题。关于安装hexo好像很有争议，在此我写一个我用的方法：<br>在一个位置新建一个文件夹，最好是某个盘的根目录吧，比如我的位置时 D：\hexo，然后运行以下命令，Hexo就安装成功了。可以通过查看版本判断是否安装成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure></p><p>随后进行创建站点。以此执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init [new empty folder]</span><br><span class="line">cd [new empty folder]</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>切记一定要是一个空的文件夹不然会报错，之后的所有步骤都要在<strong>[new empty folder]</strong>这个目录下执行命令<br>还有要注意<strong>node.js版本</strong>，最开始我就因为node.js版本太低，导致安装hexo失败，因为npm安装的hexo是最新的，node版本也需要更新。<br>执行完命令后执行以下命令，来生成静态页面<br><code>hexo g</code><br>或者<br><code>hexo generate</code></p><p>执行<code>hexo s</code><br>或者<br><code>hexo server</code><br>来开启本地web服务,会提示<br><code>INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code><br>在浏览器中输入<a href="http://localhost:4000/即可看到网页了。" target="_blank" rel="noopener">http://localhost:4000/即可看到网页了。</a></p><h3 id="将github-page和hexo联系起来"><a href="#将github-page和hexo联系起来" class="headerlink" title="将github page和hexo联系起来"></a>将github page和hexo联系起来</h3><p>执行命令来设置Git账户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;BluePROK&quot;</span><br><span class="line">git config --global user.email &quot;568406972@qq.com&quot;</span><br></pre></td></tr></table></figure><p>生成密钥（登录时需要，执行命令后按三次回车即可)<br><code>ssh-keygen -t rsa -C &quot;568406972@qq.com&quot;</code><br>如果提示找不到命令，说明ssh-keygen没有配置环境变量，切换路径到Git\usr\bin即可运行ssh-keygen。在Users文件夹里搜索密钥文件***.pub，把它打开，复制里面的内容。打开github的账户Setting，设置SSH安全，标题随便写，把pub内容复制出来完成即可，不然后面会出现无法提交网页到github的情况。<br>在根目录的_config.yml里找到Deploy，修改信息</p><ol><li>deploy:</li><li>type: git</li><li>repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:BluePROK/RBK.github.io.git</li><li>branch: master<br>这样就配置完成了</li></ol><p>新建博客，执行命令<br><code>hexo new post &quot;article title&quot;</code></p><p>会在hexo的根目录source_post里看到artitle title.md，这就是发布的文章，语法为Markdown。<br>执行命令发布文章，每次修改都要这样<br><code>hexo d -g</code><br>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>到目前为止hexo博客搭建完成，访问 blueprok.github.io/RBK.github.io即可看到我的网页。</p><p>PS.可能需要一个扩展，命令如下<br><code>npm install hexo-deployer-git --save</code></p><p>在此列出借鉴的两个文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://blog.csdn.net/gdutxiaoxu/article/details/53576018</span><br><span class="line">https://www.cnblogs.com/blogjun/articles/8289977.html</span><br></pre></td></tr></table></figure><h2 id="主题的设置"><a href="#主题的设置" class="headerlink" title="主题的设置"></a>主题的设置</h2><p>这是HEXO的主页：<a href="https://hexo.io/，上面有关于hexo的安装、命令、使用、主题等各种内容。" target="_blank" rel="noopener">https://hexo.io/，上面有关于hexo的安装、命令、使用、主题等各种内容。</a><br>我在这个网站上找的一个主题BlueLake，巧了，正好也是Blue，地址是这个<br><a href="http://chaoo.oschina.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.html" target="_blank" rel="noopener">http://chaoo.oschina.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.html</a><br>这是完整的教程，可以跟着做，我就不一一写出来了。<br>更换主题的时候也有一个小问题，hexo s本地网站主题更换了，但是更新github主题却无法显示出来。这是第二个难题，经过多方查找，需要修改以下配置文件，根_config.yml里的URL属性修改一下，我是这样修改的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https://blueprok.github.io/RBK.github.io/</span><br><span class="line">root: /RBK.github.io</span><br></pre></td></tr></table></figure></p><p>url的属性即为github page网站的地址，root属性为github page仓库项目的名字。然后再hexo d -g就可以成功修改github page的主题了。</p><h2 id="域名的绑定解析"><a href="#域名的绑定解析" class="headerlink" title="域名的绑定解析"></a>域名的绑定解析</h2><p>购买了域名之后，供应商都应该提供解析服务，我用的是阿里云，以这个为例。</p><ol><li>在阿里云控制台，设置主机记录www，记录类型为A，记录值是IP192.30.252.153。其中192.30.252.153是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Github Pages。</li><li>在阿里云控制台，设置主机记录www，记录类型为A，记录值是IP192.30.252.154。同上。</li><li>在阿里云控制台，设置主机记录@，记录类型为CNAME，记录值是bluerbk.github.io.。表示将<a href="http://bluerbk.top这个主域名映射bluerbk.github.io。在这里千万不要忘记记录值中.io后面还有一个点.！" target="_blank" rel="noopener">http://bluerbk.top这个主域名映射bluerbk.github.io。在这里千万不要忘记记录值中.io后面还有一个点.！</a></li></ol><hr><p>解析设置完成之后，在本地hexo\source新建一个文件，名字为CNAME，不要后缀，内容为域名即可（即bluerbk.top)。因为如果在github上建立文件的话下次上传的时候这个文件就被覆盖了，所以添加到本地文件，以便每次都可以保证上传，不丢失。<br>但是此时需要修改一下根_config.yml的配置信息，即上文所说的URL信息，修改为如下，否则主题又将不能应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https://bluerbk.top/</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure></p><h2 id="OK-THANKS-FOR-READING-BYE-BYE"><a href="#OK-THANKS-FOR-READING-BYE-BYE" class="headerlink" title="OK,THANKS FOR READING.BYE BYE~"></a>OK,THANKS FOR READING.BYE BYE~</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客这个东西很多网站都有，什么博客园、CSDN、简书之类的。上周还在考虑在网站上写博客，因为我一直都是自己在本地写word或者txt来记录的。突发奇想自己搭一个博客来写，又高大上还记录了还练手了。说做就做，用了两天时间差不多把基本功能实现了。&lt;/p&gt;
&lt;h4 id=&quot;使用的
      
    
    </summary>
    
      <category term="Hexo" scheme="https://bluerbk.top/categories/Hexo/"/>
    
    
      <category term="博客" scheme="https://bluerbk.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="https://bluerbk.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://bluerbk.top/2018/03/14/article-title/"/>
    <id>https://bluerbk.top/2018/03/14/article-title/</id>
    <published>2018-03-14T15:29:26.697Z</published>
    <updated>2018-03-23T11:42:04.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Welcome-to-MarkdownPad-2"><a href="#Welcome-to-MarkdownPad-2" class="headerlink" title="Welcome to MarkdownPad 2"></a>Welcome to MarkdownPad 2</h2><p><strong>MarkdownPad</strong> is a full-featured Markdown editor for Windows.</p><h3 id="Built-exclusively-for-Markdown"><a href="#Built-exclusively-for-Markdown" class="headerlink" title="Built exclusively for Markdown"></a>Built exclusively for Markdown</h3><p>Enjoy first-class Markdown support with easy access to  Markdown syntax and convenient keyboard shortcuts.</p><p>Give them a try:</p><ul><li><strong>Bold</strong> (<code>Ctrl+B</code>) and <em>Italic</em> (<code>Ctrl+I</code>)</li><li>Quotes (<code>Ctrl+Q</code>)</li><li>Code blocks (<code>Ctrl+K</code>)</li><li>Headings 1, 2, 3 (<code>Ctrl+1</code>, <code>Ctrl+2</code>, <code>Ctrl+3</code>)</li><li>Lists (<code>Ctrl+U</code> and <code>Ctrl+Shift+O</code>)</li></ul><h3 id="See-your-changes-instantly-with-LivePreview"><a href="#See-your-changes-instantly-with-LivePreview" class="headerlink" title="See your changes instantly with LivePreview"></a>See your changes instantly with LivePreview</h3><p>Don’t guess if your <a href="http://markdownpad.com" target="_blank" rel="noopener">hyperlink syntax</a> is correct; LivePreview will show you exactly what your document looks like every time you press a key.</p><h3 id="Make-it-your-own"><a href="#Make-it-your-own" class="headerlink" title="Make it your own"></a>Make it your own</h3><p>Fonts, color schemes, layouts and stylesheets are all 100% customizable so you can turn MarkdownPad into your perfect editor.</p><h3 id="A-robust-editor-for-advanced-Markdown-users"><a href="#A-robust-editor-for-advanced-Markdown-users" class="headerlink" title="A robust editor for advanced Markdown users"></a>A robust editor for advanced Markdown users</h3><p>MarkdownPad supports multiple Markdown processing engines, including standard Markdown, Markdown Extra (with Table support) and GitHub Flavored Markdown.</p><p>With a tabbed document interface, PDF export, a built-in image uploader, session management, spell check, auto-save, syntax highlighting and a built-in CSS management interface, there’s no limit to what you can do with MarkdownPad.<br><img src="C:/Users/Administrator/Desktop/2.png" alt="image"><br><img src="C:\Users\Administrator\Desktop\2.png" alt="image">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Welcome-to-MarkdownPad-2&quot;&gt;&lt;a href=&quot;#Welcome-to-MarkdownPad-2&quot; class=&quot;headerlink&quot; title=&quot;Welcome to MarkdownPad 2&quot;&gt;&lt;/a&gt;Welcome to Mar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bluerbk.top/2018/03/14/hello-world/"/>
    <id>https://bluerbk.top/2018/03/14/hello-world/</id>
    <published>2018-03-14T15:06:10.005Z</published>
    <updated>2018-03-14T15:06:10.005Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
